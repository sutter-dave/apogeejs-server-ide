// File: apogeejs-app-bundle.js
// Version: 2.0.0-p1
// Copyright (c) 2016-2021 Dave Sutter
// License: MIT

'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

function _interopNamespace(e) {
    if (e && e.__esModule) { return e; } else {
        var n = {};
        if (e) {
            Object.keys(e).forEach(function (k) {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () {
                        return e[k];
                    }
                });
            });
        }
        n['default'] = e;
        return n;
    }
}

var esprima = _interopDefault(require('esprima'));
var prosemirrorTransform_es_js = require('prosemirror-transform');
var prosemirrorState_es_js = require('prosemirror-state');
var prosemirrorKeymap_es_js = require('prosemirror-keymap');
var prosemirrorView_es_js = require('prosemirror-view');
var prosemirrorModel_es_js = require('prosemirror-model');
var ace = _interopDefault(require('ace-builds'));
var Handsontable = _interopDefault(require('handsontable'));
var prosemirrorCommands_es_js = require('prosemirror-commands');

/** 
 * This namespace includes some utility functions available to the user.
 * @namespace
 */
let apogeeutil$1 = {};

/** None State - used by members. This indicates no state information is present. */
apogeeutil$1.STATE_NONE = "none";

/** Normal State - used by members */
apogeeutil$1.STATE_NORMAL = "normal";

/** Pending State - used by members */
apogeeutil$1.STATE_PENDING = "pending";

/** Error State - used by members */
apogeeutil$1.STATE_ERROR = "error";

/** Invalid State - used by members */
apogeeutil$1.STATE_INVALID = "invalid";

/** Standard dependency 
 * @private */
apogeeutil$1.NORMAL_DEPENDENCY = 1;

/** Pass through dependency 
 * @private */
apogeeutil$1.PASS_THROUGH_DEPENDENCY = 2;

/** 
 * This value can be assigned to a data table to signify that data is not valid.
 * Any other member depending on this value will withhold the calcalation and also
 * return this invalid value.
 */
apogeeutil$1.INVALID_VALUE = {"apogeeValue":"INVALID VALUE"};

/**
 * This is a special throwable that is used to exit a function when the function definition depends
 * on another invalid value. I don't like to use exceptions for non-exceptional cases, which 
 * I consider this to be, but I couldn't figure out how else to exit the function.  */
apogeeutil$1.MEMBER_FUNCTION_INVALID_THROWABLE = {"apogeeException":"invalid"};

/**
 * This is a special throwable that is used to exit a function when the function definition depends
 * on another pending value. I don't like to use exceptions for non-exceptional cases, which 
 * I consider this to be, but I couldn't figure out how else to exit the function.  */
apogeeutil$1.MEMBER_FUNCTION_PENDING_THROWABLE = {"apogeeException":"pending"};

/** 
 * This function should be called from the body of a function table
 * to indicate the function will not return a valid value. (The actual invalid value
 * can not be returned since this typically will not have the desired effect.)
 */
apogeeutil$1.invalidFunctionReturn = function() {
    throw apogeeutil$1.MEMBER_FUNCTION_INVALID_THROWABLE;
};

/** This function reads any proeprty of the mixinObject and adds it
 * fo the prototypr of the destObject. This is intended to apend functions and
 * other properties to a cless directly without going through inheritance. 
 * Note this will overwrite and similarly named object in the dest class.
 * @private */
apogeeutil$1.mixin = function(destObject,mixinObject) {
    for(var key in mixinObject) {
        destObject.prototype[key] = mixinObject[key];
    }
};

/** 
 * This method creates an integer hash value for a string. 
 * 
 * @param {String} string - This is the string for which a hash number is desired.
 * @return {integer} This is the hash value for the string.
 */
apogeeutil$1.stringHash = function(string) {
    var HASH_SIZE = 0xffffffff;
    var hash = 0;
    var ch;
    for (var i = 0; i < string.length; i++) {
        ch = string.charCodeAt(i);
        hash = (31 * hash + ch) & HASH_SIZE;
    }
    return hash;
};

/** 
 * This method creates an integer hash value for a JSON object. 
 * 
 * @param {JSON} object - This is the json valued object for which a hash number is desired.
 * @return {integer} This is the hash value for the JSON.
 */
apogeeutil$1.objectHash = function(object) {
    //this is not real efficient. It should be implemented differently
    var string = JSON.stringify(object);
    return stringHash(string);
};

/**
 * @private
 */
apogeeutil$1.constructors = {
    "String": ("").constructor,
    "Number": (3).constructor,
    "Boolean": (true).constructor,
    "Date": (new Date()).constructor,
    "Object": ({}).constructor,
    "Array": ([]).constructor,
    "Function": (function(){}).constructor
};

/** This method returns the object type. The Allowed types are:
 * String, Number, Boolean, Date, Object, Array, Function, null, undefined.
 * @param {Object} object - This is the object for which the type is desired.
 * @returns {String} This is the type for the object. 
 */
apogeeutil$1.getObjectType = function(object) {
    if(object === null) return "null";
    if(object === undefined) return "undefined";
    
    var constructor = object.constructor;
    for(var key in apogeeutil$1.constructors) {
        if(constructor == apogeeutil$1.constructors[key]) {
            return key;
        }	
    }
    //not found
    return "Unknown";
};

/** This returns true if the object is a string. */
apogeeutil$1.isString = function(object) {
    return (typeof object == "string");
};

/** This method creates a deep copy of an object, array or value. Note that
 * undefined is not a valid value in JSON. 
 * 
 * @param {JSON} data - This is a JSON valued object
 * @returns {JSON} A JSON object which is a deep copy of the input.
 */
apogeeutil$1.jsonCopy = function(data) {
    if(data === null) return null;
    if(data === undefined) return undefined;
    return JSON.parse(JSON.stringify(data));
};

/** This method takes a field which can be an object, 
 *array or other value. If it is an object or array it 
 *freezes that object and all of its children, recursively.
 * Warning - this does not check for cycles (which are not in JSON 
 * objects but can be in javascript objects)
 * Implementation from Mozilla */
apogeeutil$1.deepFreeze = function(obj) {
    if((obj === null)||(obj === undefined)) return;
    
    //retrieve the property names defined on obj
    var propNames = Object.getOwnPropertyNames(obj);

    //freeze properties before freezing self
    propNames.forEach(function(name) {
        var prop = obj[name];

        //freeze prop if it is an object
        if(typeof prop == 'object' && prop !== null) apogeeutil$1.deepFreeze(prop);
    });

    //freeze self (no-op if already frozen)
    return Object.freeze(obj);
};

/** This method does format string functionality. Text should include
 * {i} to insert the ith string argument passed. 
 *  @param {String} format - This is a format string to format the output.
 *  @param {Array} stringArgs - These are the values which should be placed into the format string.
 *  @returns {String} The format string with the proper inserted values is returned.  
 */
apogeeutil$1.formatString = function(format,stringArgs) {
    var formatParams = arguments;
    return format.replace(/{(\d+)}/g, function(match,p1) {
        var index = Number(p1) + 1;
        return formatParams[index]; 
    });
};

/** This method reads the query string from a url
 * 
 *  @param {String} field - This is the field that should be read from the url query string
 *  @param {String} url - This is the url from which we read the query string
 *  @returns {String} The value associated with the query string key passed in. 
 */
apogeeutil$1.readQueryField = function(field,url) {
    var href = url ? url : window.location.href;
    var reg = new RegExp( '[?&]' + field + '=([^&#]*)', 'i' );
    var string = reg.exec(href);
    return string ? string[1] : null;
};

/** 
 * This is a not-so-efficient equals for json objects. For JSON objects it
 * does not require order matching of the keys. For JSON arrays it does require
 * order matching of the array values.
 * 
 *  @param {JSON} json1 - This is a JSON valued object 
 *  @param {JSON} json1 - This is a JSON valued object 
 *  @returns {Boolean}  - Returns whether or not the objects are equal
 */
apogeeutil$1.jsonEquals = function(json1,json2) {
    var string1 = JSON.stringify(apogeeutil$1.getNormalizedCopy(json1));
    var string2 = JSON.stringify(apogeeutil$1.getNormalizedCopy(json2));
    return (string1 == string2);
};

/** 
 * This method returns a copied json that has the order in all JSON objects/"maps" normalized to alphabetical. 
 * The order of JSON arrays is NOT modified.
 * This is intended for the purpose of comparing json objects. 
 * 
 *  @param {JSON} json1 - This is a JSON valued object 
 *  @returns {JSON} - Returns a order-modified version of the object
 */  
apogeeutil$1.getNormalizedCopy = function(json) {
    var copiedJson;

    var objectType = apogeeutil$1.getObjectType(json);
    
    switch(objectType) {
        case "Object":
            copiedJson = apogeeutil$1.getNormalizedObjectCopy(json);
            break;
            
        case "Array": 
            copiedJson = apogeeutil$1.getNormalizedArrayCopy(json);
            break;
            
        default:
            copiedJson = json;
    }
    
    return copiedJson;
};

/** this orders the keys apphabetically, since order is not important in a json object 
 * @private
 */
apogeeutil$1.getNormalizedObjectCopy = function(json) {
    var copiedJson = {};
    
    var keys = [];
    var key;
    for(key in json) {
        keys.push(key);
    }
    
    keys.sort();
    
    for(var i = 0; i < keys.length; i++) {
        key = keys[i];
        copiedJson[key] = apogeeutil$1.getNormalizedCopy(json[key]);
    }
    return copiedJson;
};

/** This method counts the properties in a object. */
apogeeutil$1.jsonObjectLength = function(jsonObject) {
    var count = 0;

    for(var key in jsonObject) {
        count++;
    }

    return count;
};

/** This makes a copy of with any contained objects normalized. 
 * @private 
 */
apogeeutil$1.getNormalizedArrayCopy = function(json) {
    var copiedJson = [];
    for(var i = 0; i < json.length; i++) {
        var element = json[i];
        copiedJson.push(apogeeutil$1.getNormalizedCopy(element));
    }
    return copiedJson;
};

//=================
// Some other generic utils
//=================

/** This methdo parses an arg list string to make an arg list array. It is
 * also used outisde this class. */
apogeeutil$1.parseStringArray = function(argListString) {
    var argList = argListString.split(",");
    for(var i = 0; i < argList.length; i++) {
        argList[i] = argList[i].trim();
    }
    return argList;
};

//=================
// Network request utils
//=================


/** 
 * This method does a standard callback request. It includes the following options:
 * - "method" - HTTP method, default value is "GET"
 * - "body" - HTTP body for the request
 * - "header" - HTTP headers, example: {"Content-Type":"text/plain","other-header":"xxx"}
 * @param {String} url - This is the url to be requested
 * @param {function} onSuccess - This is a callback that will be called if the request succeeds. It should take a String request body argument.
 * @param {function} onError - This is the callback that will be called it the request fails. It should take a String error message argument. 
 * @param {Object} options - These are options for the request.
 */
apogeeutil$1.callbackRequest = function(url,onSuccess,onError,options) {
    
    var xmlhttp=new XMLHttpRequest();

    xmlhttp.onreadystatechange=function() {
        var msg;
        if(xmlhttp.readyState==4) {
            if((xmlhttp.status>=200)&&(xmlhttp.status<=399)) {
                try {
                    onSuccess(xmlhttp.responseText);
                }
                catch(error) {
                    onError(error.message);
                }

            }
            else if(xmlhttp.status >= 400)  {
                msg = "Error in http request. Status: " + xmlhttp.status;
                onError(msg);
            }
            else if(xmlhttp.status == 0) {
                msg = "Preflight error in request. See console";
                onError(msg);
            }
        }
    };

    if(!options) options = {};
    
    var method = options.method ? options.method : "GET";
    xmlhttp.open(method,url,true);
    
    if(options.header) {
        for(var key in options.header) {
            xmlhttp.setRequestHeader(key,options.header[key]);
        }
    }
    
    xmlhttp.send(options.body);
};

/** 
 * This method returns a promise object for an HTTP request. The promist object
 * returns the text body of the URL if it resolves successfully.
 *  
 * @param {String} url - This is the url to be requested
 * @param {Object} options - These are options for the request. See {@link apogeeutil.callbackRequest} for the options definition.
 * @return {Promise} This method returns a promise object with the URL body as text.
 */
apogeeutil$1.textRequest = function(url,options) {
    return new Promise(function(onSuccess,onError) {
        apogeeutil$1.callbackRequest(url,onSuccess,onError,options);
    });
};

/** 
 * This method returns a promise object for an HTTP request. The promist object
 * returns the JSON body of the URL if it resolves successfully.
 *  
 * @param {String} url - This is the url to be requested
 * @param {Object} options - These are options for the request. See {@link apogeeutil.callbackRequest} for the options definition.
 * @return {Promise} This method returns a promise object with the URL body as text.
 */
apogeeutil$1.jsonRequest = function(url,options) {
    return apogeeutil$1.textRequest(url,options).then(JSON.parse);
};

/** This method returns a random string which should be unique. */
apogeeutil$1.getUniqueString = function() {
    return Math.random().toString(36).substring(2, 15);
};

/* 
 * This is a mixin to give event functionality.
 */
var EventManager = {};
    
/** This serves as the constructor. */
EventManager.eventManagerMixinInit = function() {
     /** This field holds the event listeners
    * @private */
    this.listenerTable = {};
    
    /** This field holds the event handlers
    * @private */
    this.handlerTable = {};
};

/** This method adds a listener for the given event. */
EventManager.addListener = function(eventName, callback) {
    var callbackList = this.listenerTable[eventName];
    if(!callbackList) {
        callbackList = [];
        this.listenerTable[eventName] = callbackList;
    }
    //make sure the object is not already in the list
    for(var i = 0; i < callbackList.length; i++) {
        var c = callbackList[i];
        if(c == callback) {
            return;
        }
    }
    //add to the list
    callbackList.push(callback);
};

/** This method removes a listener for the event. */
EventManager.removeListener = function(eventName, callback) {
    var callbackList = this.listenerTable[eventName];
    if(callbackList) {
        var index = callbackList.indexOf(callback);
        if(index >= 0) {
            callbackList.splice(index,1);
        }
    }
};

/** THis method dispatches an event. */
EventManager.hasListeners = function(eventName) {
    return this.listenerTable[eventName] ? true : false;
};

/** THis method dispatches an event. */
EventManager.dispatchEvent = function(eventName, eventData) {
    var callbackList = this.listenerTable[eventName];
    if(callbackList) {
        for(var i = 0; i < callbackList.length; i++) {
            var callback = callbackList[i];
            callback.call(null,eventData);
        }
    }
};


/** This method adds a handler. */
EventManager.addHandler = function(handlerName, callback) {
    this.handlerTable[handlerName] = callback;
};

/** This method clears a handler. */
EventManager.removeHandler = function(handlerName) {
    delete this.handlerTable[handlerName];
};

/** This method calls a handler by name and returns the result. If no 
 * handler is found undefined is returned. */
EventManager.callHandler = function(handlerName, handlerData) {
    var callback = this.handlerTable[handlerName];
    if(callback) {
        return callback(handlerData)
    }
    else {
        return undefined;
    }
};

/** This resets all the listeners and handlers */
EventManager.clearListenersAndHandlers = function() {
    this.listenerTable = {};
    this.handlerTable = {};
};

/** This is a class for the field object formalism. It is used to store fields
 * and track modifications. It allows you to lock the object so that no more changes
 * can be made. */
class FieldObject {

    /** constructor.
     * - objectType - a text only string giving the name of the object type. This
     * is used in the id string.
     * - instanceToCopy - if this argument is defined, the created instance will be a shallow copy
     * of the this passed instance. By default it will have the updated fields flag cleared, but this
     * can be changed with the "keepUpdatedFixed" flag The new instance will be unlocked.
     * - keepUpdatedFixed - This should only be used when an instance is copied. If this is true
     * the copied instance will keep the same fields updated flags. Otherwise they will be cleared.
     * - specialCaseIdValue - This can be set if you wnt to create a new instance with a specific ID value. 
     * This should be done only in special circumstances. One example is "redo" creation of an object (after an undo)
     * subsequent commands for this object will reference its original ID. This is a way to set the ID of the recreaeted
     * object to match the original.
     */
    constructor(objectType,instanceToCopy,keepUpdatedFixed,specialCaseIdValue) {
        //this is a (semi-) unique number of each instance (There is no provision for wrapping - so there could be repeats)
        this.instanceNumber = _getInstanceNumber();

        if(!instanceToCopy) {
            if(specialCaseIdValue) {
                this.id = specialCaseIdValue;
            }
            else {
                this.id = _createId(objectType);
            }
            this.objectType = objectType;
        }
        else {
            this.id = instanceToCopy.id;
            this.objectType = instanceToCopy.objectType;
        }

        this.fieldMap = {};
        if(instanceToCopy) {
            Object.assign(this.fieldMap,instanceToCopy.fieldMap);
        }

        this.updated = {};
        if(keepUpdatedFixed) {
            Object.assign(this.updated,instanceToCopy.updated);
        }

        this.isLocked = false;
    }

    /** This sets a field value. It will throw an exception if the object is locked. */
    setField(name,value) {
        if(this.isLocked) {
            throw new Error("Attempting to set a value on a locked object.");
        }

        this.fieldMap[name] = value;
        this.updated[name] = true;
    }

    /** This will clear the value of a field. */
    clearField(name) {
        if(this.fieldMap[name] !== undefined) {
            delete this.fieldMap[name];
            this.updated[name] = true;
        }
    }

    /** This ges a field value, by name. */
    getField(name) {
        return this.fieldMap[name];
    }

    /** This method locks the object. On instantiation the object is unlocked and
     * fields can be set. Once it it locked the fields can not be changed. */
    lock() {
        this.isLocked = true;
    }

    getIsLocked() {
        return this.isLocked;
    }

    /** This returns a map of the updated fields for this object.  */
    getUpdated() {
        return this.updated;
    }

    /** This returns true if the given field is updated. */
    isFieldUpdated(field) {
        return this.updated[field] ? true : false;
    }

    /** This returns true if any fields in the give list have been updated. */
    areAnyFieldsUpdated(fieldList) {
        return fieldList.some( field => this.updated[field]);
    }

    /** This method should be implemented for any object using this mixin. 
     * This should give a unique identifier for all objects of the given object type, below.
     * A unique id may optionally be generated using the statid FieldObject method createId. */
    getId() {
        return this.id;
    }

    /** Thie method should be implemented for any object using this method. 
     * It identifies the type of object. */
    getType() {
        return this.objectType;
    }

    /** This static functions returns the type of an object given the ID. */
    static getTypeFromId(id) {
        let typeEnd = id.indexOf("|");
        if(typeEnd < 0) {
            throw new Error("Invalid ID");
        }
        else {
            return id.substr(0,typeEnd);
        }
    }

    /** This static function indicates if the given ID is an object of the given type. */
    static idIsTypeOf(id,type) {
        return id.startsWith(type + "|");
    }

    /** This loads the current field object to have a copy of the data from the given field object.
     * The update field is however cleared. This method will throw an exception is you try to copy 
     * into a loacked object. */
    copyFromFieldsObject(otherFieldObject) {
        if(this.isLocked) {
            throw new Error("Attempting to copy fields into a locked object.");
        }

        for(name in otherFieldObject.fieldMap) {
            this.fieldMap[name] = otherFieldObject.fieldMap[name];
        }
        this.updated = {};
    }

    //================================
    // Static Methods
    //================================

    

}

/** This function generates a ID that is unique over the span of this application execution (until the 
 * integers wrap). This is suitable for creating the field object ID for an instance.
 * At some point we shouldhandle wrapping, and the three cases it can cause - negative ids, 0 id, and most seriously,
 * a reused id.
 * 
 * Currently planned future solution to wrapping: make this an operation issue. And event can be issued when we 
 * have reached given id values. Then it is the responsibility of the operator to restart the sytems. This is probably safer
 * than trying to com eup with some clever remapping solution. */
function _createId(objectType) {
    return objectType + "|" + nextId++;
}

/** This is used for Id generation.
 * @private */
let nextId = 1;


/** This is intended for debug use only. It gives a unique number for each instance created. There is no provision made
 * for wrapping of this number, and it should be used in a way where that doesn't matter. */
function _getInstanceNumber() {
    return nextInstanceNumber++;
}

/** This is used for unique instance number generation.
 * @private */
let nextInstanceNumber = 1;

//This is a single module that exports utility classes and object used internally across the apogee workspace

var apogeebase = /*#__PURE__*/Object.freeze({
    __proto__: null,
    EventManager: EventManager,
    FieldObject: FieldObject
});

/** This class manages variable scope for the user code. It is used to look up 
 * variables both to find dependencies in member code or to find the value for
 * member code execution.
 * 
 * It has two lookup functions. "getMember" looks up members and is used to 
 * find dependencies. "getValue" looks up member values, for evaluating member values.
 * 
 * When a lookup is done, the named member/value is looked up in the local member scope. If it is not found,
 * the search is then done in the parent of the member. This chain continues until we reach a "root" object,
 * an example of which is the model object itself.
 * 
 * The root object has a lookup like the other context manager objects, however, if a lookup fails
 * to fins something, it does a lookup on global javascript variables. (Any filtering on this is TBD)
 * 
 * In the local scope for each context holder there is a context list, that allows for a number of entries. 
 * Currently the only one type of entry - parent entry. It looks up children of the current object.
 * 
 * In the future we can add imports for the local scope, and potentially other lookup types. 
 * */
function ContextManager(contextHolder) {
    this.contextHolder = contextHolder;

    this.contextList = [];
}

ContextManager.prototype.addToContextList = function(entry) {
    this.contextList.push(entry);
};

ContextManager.prototype.removeFromContextList = function(entry) {
    var index = this.contextList.indexOf(entry);
    if(index >= 0) {
        this.contextList.splice(index,1);
    }
};

ContextManager.prototype.clearContextList = function() {
    this.contextList = [];
};

ContextManager.prototype.getValue = function(model,varName) {
    var data = this.lookupValue(model,varName);
    
    //if the name is not in this context, check with the parent context
    if(data === undefined) {
        if((this.contextHolder)&&(!this.contextHolder.getIsScopeRoot())) {
            var parent = this.contextHolder.getParent(model);
            if(parent) {
                var parentContextManager = parent.getContextManager();
                data = parentContextManager.getValue(model,varName);
            }
        }
    }
    
    return data;
};

ContextManager.prototype.getMember = function(model,pathArray,optionalParentMembers) {
    let index = 0;
    var impactor = this.lookupMember(model,pathArray,index,optionalParentMembers);
    
    //if the object is not in this context, check with the parent context
    if(!impactor) {
        if((this.contextHolder)&&(!this.contextHolder.getIsScopeRoot())) {
            var parent = this.contextHolder.getParent(model);
            if(parent) {
                var parentContextManager = parent.getContextManager();
                impactor = parentContextManager.getMember(model,pathArray,optionalParentMembers);
            }
        }
    }
    
    return impactor;
};

//==================================
// Private Methods
//==================================

/** Check each entry of the context list to see if the data is present. */
ContextManager.prototype.lookupValue = function(model,varName) {
    var data;
    let childFound = false;
    for(var i = 0; i < this.contextList.length; i++) {
        var entry = this.contextList[i];        
        if(entry.contextHolderAsParent) {
            //for parent entries, look up the child and read the data
            var child = this.contextHolder.lookupChild(model,varName);
            if(child) {
                data = child.getData();
                childFound = true;
            }
        }
        
        if(childFound) return data;
    }

    if(this.contextHolder.getIsScopeRoot()) {
        data = this.getValueFromGlobals(varName);

        if(data != undefined) {
            return data;
        }
    }
    
    return undefined;
};

ContextManager.prototype.lookupMember = function(model,pathArray,index,optionalParentMembers) {
    var impactor;
    for(var i = 0; i < this.contextList.length; i++) {
        var entry = this.contextList[i];        
        if(entry.contextHolderAsParent) {
            //for parent entries, look up the child and read the data
            impactor = this.contextHolder.lookupChild(model,pathArray[index]);

            if((impactor)&&(impactor.isContextHolder)) {
                let childImpactor = impactor.getContextManager().lookupMember(model,pathArray,index+1);
                if(childImpactor) {
                    if(optionalParentMembers) {
                        optionalParentMembers.push(impactor);
                    }
                    impactor = childImpactor;
                }
            }

        }
        //no lookup in data entries
        
        if(impactor) return impactor;
    }
    
    return undefined;
};

ContextManager.prototype.getValueFromGlobals = function(varName) {
    ///////////////////////////////////
    //CLUDGE - Here we can added additional values that are not in globals
    //This is here because, for now, on the server require did not appear in globals, so we put it here.
    //I think this is because it is only exposed in certain places, possibly related to their es module
    //implementation.  
    if(__globals__.__apogee_globals__) {
        let value = __globals__.__apogee_globals__[varName];
        if(value !== undefined) return value; 
    }
    /////////////////////////////////////

    //for now don't do any filtering
    //in the future we may want to do something so people don't deine their own globals - TBD
    return __globals__[varName];
};

/** This component encapsulates an object that has a context manager.
 * 
 * This is a mixin and not a class. It is used for the prototype of the objects that inherit from it.
 * 
 * COMPONENT DEPENDENCIES:
 */
let ContextHolder = {};

/** This initializes the component */
ContextHolder.contextHolderMixinInit = function(isScopeRoot) {
    this.isScopeRoot = isScopeRoot;

    //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
    //What kind of field is this? Dependent?
    //will be set on demand
    this.contextManager = null;
    //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
};

ContextHolder.isContextHolder = true;

/** This method retrieves the context manager. */
ContextHolder.getContextManager = function() {
    if(!this.contextManager) {
        //set the context manager
        this.contextManager = this.createContextManager();
    }
    
    return this.contextManager;
};

ContextHolder.getIsScopeRoot = function() {
    return this.isScopeRoot;
};

//this method must be implemneted in extending classes
///** This method retrieve creates the loaded context manager. */
//ContextHolder.createContextManager = function();

/** This component encapsulates an parent object that is a member and contains children members, creating  a 
 * hierarchical structure in the model. Each child has a name and this name
 * forms the index of the child into its parent. (I guess that means it doesn't
 * have to be a string, in the case we made an ArrayFolder, which would index the
 * children by integer.)
 * 
 * This is a mixin and not a class. It is used for the prototype of the objects that inherit from it.
 */
let Parent = {};

/** This initializes the component.
 * - isCopy - this should be set to true (or another value that evaluates to true) if this parent is being initialized
 * as a copy of aother instance.
 */
Parent.parentMixinInit = function(isCopy) {
    //default value. Can be reconfigured
    this.childrenWriteable = true;

    if(!isCopy) {
        //initialize the child mape
        this.setField("childIdMap",{});
    }
};

Parent.isParent = true;

/** This method returns the map of the children. */
Parent.getChildIdMap = function() {
    return this.getField("childIdMap");
};

/** This method looks up a child from this parent.  */
Parent.lookupChildId = function(name) {
    //check look for object in this folder
    let childIdMap = this.getField("childIdMap");
    return childIdMap[name];
};

/** This method looks up a child from this parent.  */
Parent.lookupChild = function(model,name) {
    let childId = this.lookupChildId(name);
    if(childId) {
        return model.lookupMemberById(childId);
    }
    else {
        return null;
    }
};

/** This method allows the UI to decide if the user can add children to it. This
 * value defaults to true. */
Parent.getChildrenWriteable = function() {
    return this.childrenWriteable;
};

/** This method sets the writeable property for adding child members. This value of
 * the method is not enforced (since children must be added one way or another). */
Parent.setChildrenWriteable = function(writeable) {
    this.childrenWriteable = writeable; 
};

/** This method adds a table to the folder. It also sets the folder for the
 *table object to this folder. It will fail if the name already exists.  */
Parent.addChild = function(model,child) {
    
    //check if it exists first
    let name = child.getName();
    let childIdMap = this.getField("childIdMap");
    if(childIdMap[name]) {
        //already exists! not fatal since it is not added to the model yet,
        throw new Error("There is already an object with the given name.");
    }

    //make a copy of the child map to modify
    let newChildIdMap = {};
    Object.assign(newChildIdMap,childIdMap);

    //add object
    newChildIdMap[name] = child.getId();
    this.setField("childIdMap",newChildIdMap);
    
    //set all children as dependents
    if(this.onAddChild) {
        this.onAddChild(model,child);
    }
};

//This method should optionally be implemented for any additional actions when a Child is added.
//Parent.onAddChild(model,child);

/** This method removes a table from the folder. */
Parent.removeChild = function(model,child) {
    //make sure this is a child of this object
    var parent = child.getParent(model);
    if((!parent)||(parent !== this)) return;
    
    //remove from folder
    var name = child.getName();
    let childIdMap = this.getField("childIdMap");
    //make a copy of the child map to modify
    let newChildIdMap = {};
    Object.assign(newChildIdMap,childIdMap);
    
    delete(newChildIdMap[name]);
    this.setField("childIdMap",newChildIdMap);
    
    //set all children as dependents
    if(this.onRemoveChild) {
        this.onRemoveChild(model,child);
    }
};

//This method should optionally be implemented for any additional actions when a Child is removed.
//Parent.onRemoveChild(model,child);

/** This method is called when a child valud changes. */
Parent.childDataUpdate = function(model,child) {
    if(this.onChildDataUpdate) {
        this.onChildDataUpdate(model,child);
    }
};

//This method should optionally be implemented for any additional actions when a Child value is changed.
//Parent.onChildDataUpdate(model,child);

///** This method is called when the model is closed. 
//* It should do any needed cleanup for the object. */
Parent.onClose = function(model) {
    let childIdMap = this.getField("childIdMap");
    for(var key in childIdMap) {
        var childId = childIdMap[key];
        let child = model.lookupMemberById(childId);
        if((child)&&(child.onClose)) child.onClose(model);
    }

    if(this.onCloseAddition) {
        this.onCloseAddition();
    }
};

//This method should optionally be implemented if there are any additional actions when the parent is closed.
//This method will be called after all children have been closed.
//Parent.onCloseAddition();

//This method should be implemented to give the base name the children inherit for the full name. */
//Parent.getPossesionNameBase = function(model);

/** This method returns the full name in dot notation for this object. */
Parent.getChildFullName = function(model,childName) {
    return this.getPossesionNameBase(model) + childName;
};

/** This method looks up a member by its full name. */
Parent.getMemberByFullName = function(model,fullName) {
    var path = fullName.split(".");
    return this.lookupChildFromPathArray(model,path);
};

/** This method looks up a child using an arry of names corresponding to the
 * path from this folder to the object.  The argument startElement is an optional
 * index into the path array for fodler below the root folder. 
 * The optional parentMemberList argument can be passed in to load the parent members 
 * for the given member looked up. */
Parent.lookupChildFromPathArray = function(model,path,startElement,optionalParentMemberList) {
    if(startElement === undefined) startElement = 0;
    
    var childMember = this.lookupChild(model,path[startElement]);
    if(!childMember) return undefined;
    
    if(startElement < path.length-1) {
        if(childMember.isParent) {
            let grandChildMember = childMember.lookupChildFromPathArray(model,path,startElement+1,optionalParentMemberList);
            //record the parent path, if requested
            if((grandChildMember)&&(optionalParentMemberList)) {
                optionalParentMemberList.push(childMember);
            }
            return grandChildMember;
        }
        else {
            return childMember;
        }
    }
    else {
        return childMember;
    }
};

/** This is the model. 
 * -instanceToCopy - if the new instance should be a copy of an existing instance, this
 * argument should be populated. The copy will have the same field values but it will be unlocked 
 * and by default the update fields will be cleared. The event listeners are also cleared.
 * - keepUpdatedFixed - If this argument is set to true, the updated field values will be maintained.
 * */
class Model extends FieldObject {

    constructor(runContext,instanceToCopy,keepUpdatedFixed) {
        //base init
        super("model",instanceToCopy,keepUpdatedFixed);

        //mixin initialization
        this.eventManagerMixinInit();
        //this is a root for the context
        this.contextHolderMixinInit(true);
        this.parentMixinInit(instanceToCopy);

        this.runContext = runContext;

        //==============
        //Fields
        //==============
        //Initailize these if this is a new instance
        if(!instanceToCopy) {
            this.setField("name",Model.DEFAULT_MODEL_NAME);
            this.setField("impactsMap",{});
            //create the member map, with the model included
            let memberMap = {};
            memberMap[this.getId()] = this;
            this.setField("memberMap",memberMap);
        }

        //==============
        //Working variables
        //==============
        this.workingImpactsMap = null;
        this.workingMemberMap = null;
        this.workingChangeMap = {};

        //add a change map entry for this object
        this.workingChangeMap[this.getId()] = {action: instanceToCopy ? "updated" : "created", instance: this};

        // This is a queue to hold actions while one is in process.
        this.actionInProgress = false;
        this.messengerActionList = [];
        this.consecutiveActionCount = 0;
        this.activeConsecutiveActionLimit = Model.CONSECUTIVE_ACTION_INITIAL_LIMIT;
    }

    /** This method returns a mutable copy of this instance. If the instance is already mutable
     * it will be returned rather than making a new one.  */
    getMutableModel() {
        if(this.getIsLocked()) {
            //create a new instance that is a copy of this one
            let newModel = new Model(this.runContext,this);

            //update the member map for the new model
            let newMemberMap = {};
            let oldMemberMap = newModel.getField("memberMap");
            Object.assign(newMemberMap,oldMemberMap);
            newMemberMap[newModel.getId()] = newModel;
            newModel.setField("memberMap",newMemberMap);

            return newModel;
        }
        else {
            //return this instance since it si already unlocked
            return this;
        }
    }

    /** This gets a copy of the model where any unlocked members are replaced with new instance copies.
     * This ensures if we look up a mutable member from here we get a different instance from what was 
     * in our original model instance. */
    getCleanCopy(newRunContext) {
        //make sure the stored fields are up to date
        if(this.workingImpactsMap) this.finalizeImpactsMap();
        if(this.workingMemberMap) this.finalizeMemberMap();

        let newModel = new Model(newRunContext,this);

        //update the member map for the new model
        let oldMemberMap = this.getField("memberMap");

        newModel._populateWorkingMemberMap();
        newModel.workingMemberMap[newModel.getId()] = newModel;

        for(let memberId in oldMemberMap) {
            let member = oldMemberMap[memberId];
            if((member != this)&&(!member.getIsLocked())) {
                //create a new copy of the member and register it.
                let newMember = new member.constructor(member.getName(),member);
                newModel.workingMemberMap[newMember.getId()] = newMember;
            }
        }

        return newModel;
    }

    /** This method locks all member instances and the model instance. */
    lockAll() {
        //clear up working fields
        this.workingChangeMap = null;

        //make sure the other working fields have been saved
        if(this.workingImpactsMap) this.finalizeImpactsMap();
        if(this.workingMemberMap) this.finalizeMemberMap();

        //member map includes all members and the model
        let memberMap = this.getField("memberMap");
        for(let id in memberMap) {
            //this will lock the model too
            //we maybe shouldn't be modifying the members in place, but we will do it anyway
            memberMap[id].lock();
        }
    }

    /** This completes any lazy initialization. This must be done before the model and the members are locked. 
     * Any member not yet initialized would be a lazy initialize function that was neever called. */
    completeLazyInitialization() {
        //member map includes all members and the model
        let activeMemberMap = this._getActiveMemberMap();
        for(let id in activeMemberMap) {
            let member = activeMemberMap[id];
            if(member.lazyInitializeIfNeeded) {
                member.lazyInitializeIfNeeded();
            }
        }
    }

    /** This shoudl be called after all dependencies have been updated to store the
     * impacts map (We kept a mutable working copy during construction for efficiency)  */
    finalizeImpactsMap() {
        if(this.workingImpactsMap) {
            this.setField("impactsMap",this.workingImpactsMap);
            this.workingImpactsMap = null;
        } 
    }

    finalizeMemberMap() {
        if(this.workingMemberMap) {
            this.setField("memberMap",this.workingMemberMap);
            this.workingMemberMap = null;
        }
    }

    /** This returns a map of the changes to the model. It is only valid while the 
     * model instance is unlocked. */
    getChangeMap() {
        return this.workingChangeMap;
    }

    /** This function should be used to execute any action that is run asynchronously with the current
     * action. The action is run on a model and it is uncertain whether the existing model will still be 
     * current when this new action is run. An example of when this is used is to populate a data table in
     * response to a json request completing.  */
    doFutureAction(actionData) {
        //run this action asynchronously
        this.runContext.doAsynchActionCommand(this.getId(),actionData);
    }

    /** This method returns the root object - implemented from RootHolder.  */
    setName(name) {
        this.setField("name",name);
    }

    /** This method returns the root object - implemented from RootHolder.  */
    getName() {
        return this.getField("name");
    }

    /** This method updates the dependencies of any children
     * based on an object being added. */
    updateDependeciesForModelChange(additionalUpdatedMembers) {
        //call update in children
        let childIdMap = this.getChildIdMap();
        for(var name in childIdMap) {
            var childId = childIdMap[name];
            let child = this.lookupMemberById(childId);
            if((child)&&(child.isDependent)) {
                child.updateDependeciesForModelChange(this,additionalUpdatedMembers);
            }
        }
    }

    //------------------------------
    // Queded Action Methods
    //------------------------------

    /** This function triggers the action for the queued action to be run when the current thread exits. */
    isActionInProgress() {
        return this.actionInProgress;
    }

    setActionInProgress(inProgress) {
        this.actionInProgress = inProgress;
    }

    saveMessengerAction(actionInfo) {
        this.messengerActionList.push(actionInfo);
    }

    getSavedMessengerAction() {
        if(this.messengerActionList.length > 0) {
            var actionData = {};
            actionData.action = "compoundAction";
            actionData.actions = this.messengerActionList;
            this.messengerActionList = [];
            return actionData;
        }
        else {
            return null;
        }
    }

    /** This method should be called for each consecutive queued action. It checks it if there are 
     * too many. If so, it returns true. In so doing, it also backs of the consecutive queued 
     * action count so next time it will take longer. Any call to clearConsecutiveQueuedActionCount
     * will return it to the default initial value.
     */
    checkConsecutiveQueuedActionLimitExceeded() {
        this.consecutiveActionCount++;
        
        //check the limit
        var exceedsLimit = (this.consecutiveActionCount > this.activeConsecutiveActionLimit);
        if(exceedsLimit) {
            //back off limit for next time
            this.activeConsecutiveActionLimit *= 2;
        }
        
        return exceedsLimit;
    }

    /** This should be called when there is not a queued action. */
    clearConsecutiveQueuedTracking() {
        this.consecutiveActionCount = 0;
        this.activeConsecutiveActionLimit = Model.CONSECUTIVE_ACTION_INITIAL_LIMIT;
    }

    /** This method resets the command queue */
    clearCommandQueue() {
        //reset queued action variables
        this.messengerActionList = [];
        this.clearConsecutiveQueuedTracking();
    }


    //------------------------------
    // Parent Methods
    //------------------------------

    /** this method gets the hame the children inherit for the full name. */
    getPossesionNameBase(model) {
        //the name starts over at a new model
        return "";
    }

    //------------------------------
    //ContextHolder methods
    //------------------------------

    /** This method retrieve creates the loaded context manager. */
    createContextManager() {
        //set the context manager
        var contextManager = new ContextManager(this);

        //add an entry for this folder. This is for multiple folders in the model base
        //which as of the time of this comment we don't have but plan on adding
        //(at which time this comment will probably be left in by accident...)
        var myEntry = {};
        myEntry.contextHolderAsParent = true;
        contextManager.addToContextList(myEntry);
        
        return contextManager;
    }

    //============================
    // MemberMap Functions
    //============================

    lookupMemberById(memberId) {
        let activeMemberMap = this._getActiveMemberMap();
        return activeMemberMap[memberId];
    }

    /** This method returns a mutable member for the given ID. If the member is already unlocked, that member will be
     * returned. Otherwise a copy of the member will be made and stored as the active instance for the member ID.  */
    getMutableMember(memberId) {
        if(this.getIsLocked()) throw new Error("The model must be unlocked to get a mutable member.");

        let member = this.lookupMemberById(memberId);
        if(member) {
            if(member.getIsLocked()) {
                //create a unlocked copy of the member
                let newMember = new member.constructor(member.getName(),member);

                //update the saved copy of this member in the member map
                this.registerMember(newMember);
                return newMember;
            }
            else {
                return member;
            }
        }
        else {
            return null;
        }
    }

    registerMember(member) {
        if(!this.workingMemberMap) {
            this._populateWorkingMemberMap();
        }

        let memberId = member.getId();

        //update the change map for this member change
        let changeMapEntry = this.workingChangeMap[memberId];
        if(!changeMapEntry) {
            //if it already existed we don't need to change it (that means it was a create and we want to keep that)
            //otherwise add a new entry
            if(this.workingMemberMap[memberId]) {
                //this is an update
                this.workingChangeMap[memberId] = {action: "updated", instance: member};
            }
            else {
                //this is a create
                this.workingChangeMap[memberId] = {action: "created", instance: member};
            }
        }

        //add or update the member in the working member map
        this.workingMemberMap[memberId] = member;
    }

    unregisterMember(member) {
        if(!this.workingMemberMap) {
            this._populateWorkingMemberMap();
        }

        let memberId = member.getId();

        //update the change map for this member change
        let changeMapEntry = this.workingChangeMap[memberId];
        if(changeMapEntry) {
            if(changeMapEntry.action == "updated") {
                changeMapEntry.action = "deleted";
            }
            else if(changeMapEntry.action == "created") {
                //these cancel! however, we will keep the entry around and label
                //it as "transient", in case we get another entry for this member
                //I don't think we should get on after delete, but just in case
                changeMapEntry.action = "transient";
            }
            else if(changeMapEntry.action == "transient") ;
            else {
                //this shouldn't happen. We will just mark it as delete
                changeMapEntry.action = "deleted";
            }
        }
        else {
            changeMapEntry = {action: "deleted", instance: member};
            this.workingChangeMap[memberId] = changeMapEntry;
        }

        //remove the member entry
        delete this.workingMemberMap[memberId];
    }

    /** This should be called to get a copy of the active working map when no changes are being
     * made to the map. If changes are being made, typically they should be done to the workingMemberMap.  */
    _getActiveMemberMap() {
        return this.workingMemberMap ? this.workingMemberMap : this.getField("memberMap");
    }

    /** This method makes a mutable copy of the member map, and places it in the working member map. */
    _populateWorkingMemberMap() {
        let memberMap = this.getField("memberMap");
        let newMemberMap = {};
        Object.assign(newMemberMap,memberMap);
        this.workingMemberMap = newMemberMap;
    }

    //============================
    // Impact List Functions
    //============================

    /** This returns an array of members this member impacts. */
    getImpactsList(member) {
        let impactsMap = this.getField("impactsMap");
        let impactsList = impactsMap[member.getId()];
        if(!impactsList) impactsList = [];
        return impactsList;
    }
    
    /** This method adds a data member to the imapacts list for this node.
     * The return value is true if the member was added and false if it was already there. 
     * NOTE: the member ID can be a string or integer. This dependentMemberId should be an int. */
    addToImpactsList(depedentMemberId,memberId) {
        //don't let a member impact itself
        if(memberId === depedentMemberId) return;

        let workingMemberImpactsList = this.getWorkingMemberImpactsList(memberId);

        //add to the list iff it is not already there
        if(workingMemberImpactsList.indexOf(depedentMemberId) === -1) {
            workingMemberImpactsList.push(depedentMemberId);
            return true;
        }
        else {
            return false;
        }
    }

    /** This method removes a data member from the imapacts list for this node. */
    removeFromImpactsList(depedentMemberId,memberId) {

        let workingMemberImpactsList = this.getWorkingMemberImpactsList(memberId);

        //it should appear only once
        for(var i = 0; i < workingMemberImpactsList.length; i++) {
            if(workingMemberImpactsList[i] == depedentMemberId) {
                workingMemberImpactsList.splice(i,1);
                return;
            }
        }
    }
    
    /** This gets a edittable copy of a member impacts list.  */
    getWorkingMemberImpactsList(memberId) {
        //make sure our working impacts map is populated
        //we will use this wile buildign the impacts map and then set the impacts map field
        if(!this.workingImpactsMap) {
            this._populateWorkingImpactsMap();
        }

        let memberImpactsList = this.workingImpactsMap[memberId];
        if(!memberImpactsList) {
            memberImpactsList = [];
            this.workingImpactsMap[memberId] = memberImpactsList;
        }

        return memberImpactsList;
    }

    /** This method will load a mutable copy of the impacts map field to be used
     * when we update the impacts map. We use a working variable since the reconstruction
     * spans many calls to the add/remove function. In the copy, it makes a shallow copy of 
     * each impacts list in the map. */
    _populateWorkingImpactsMap() {
        let impactsMap = this.getField("impactsMap");
        let newImpactsMap = {};
        for(let idString in impactsMap) {
            let impactsList = impactsMap[idString];
            //shallow copy each array
            newImpactsMap[idString] = [...impactsList];
        }
        this.workingImpactsMap = newImpactsMap;
    }

    //============================
    // Save and Load Functions
    //============================

    /** This saves the model */
    toJson() {
        let json = {};
        json.fileType = Model.SAVE_FILE_TYPE;
        json.version = Model.SAVE_FILE_VERSION;

        json.name = this.getField("name");
        json.children = {};
        let childIdMap = this.getField("childIdMap");
        for(var name in childIdMap) {
            var childId = childIdMap[name];
            let child = this.lookupMemberById(childId);
            if(child) {
                json.children[name] = child.toJson(this);
            }
        }

        return json;
    }

    /** This method creates a headless model json from a folder json. It
     * is used in the folder function. */
    static createModelJsonFromFolderJson(name,folderJson) {
        let json = {};
        json.fileType = Model.SAVE_FILE_TYPE;
        json.version = Model.SAVE_FILE_VERSION;

        //let the workspace inherit the folder name
        json.name = name;
        json.children = {};

        //attach a single child named main
        json.children[folderJson.name] = folderJson;

        return json
    }

    //================================
    // Member generator functions
    //================================

    /** This methods retrieves the member generator for the given type. */
    static getMemberGenerator(type) {
        return memberGenerators[type];
    }

    /** This method registers the member generator for a given named type. */
    static addMemberGenerator(generator) {
        memberGenerators[generator.type] = generator;
    }

}

//add mixins to this class
apogeeutil$1.mixin(Model,EventManager);
apogeeutil$1.mixin(Model,ContextHolder);
apogeeutil$1.mixin(Model,Parent);

let memberGenerators = {};

Model.DEFAULT_MODEL_NAME = "Workspace";
Model.ROOT_FOLDER_NAME = "main";

/** This is the supported file type. */
Model.SAVE_FILE_TYPE = "apogee model";

/** This is the supported file version. */
Model.SAVE_FILE_VERSION = 0.3;

Model.CONSECUTIVE_ACTION_INITIAL_LIMIT = 500;

Model.EMPTY_MODEL_JSON = {
    "fileType": Model.SAVE_FILE_TYPE,
    "version": Model.SAVE_FILE_VERSION,
    "name": Model.DEFAULT_MODEL_NAME,
    "children": {
        "main": {
            "name": Model.ROOT_FOLDER_NAME,
            "type": "apogee.Folder"
        }
    }
};

/** This module contains functions to process an update to an member
 * which inherits from the FunctionBase component. */


/** This moethod should be called on an member (impactor or dependent) that changes.
 * This will allow for any Dependents to be recaculated. */
function addToRecalculateList(model,recalculateList,member) {
    //if it is in the list, return
    if(recalculateList.indexOf(member) >= 0) return;
     
    //add this member to recalculate list if it needs to be executed
    if((member.isDependent)&&(member.memberUsesRecalculation())) {
        recalculateList.push(member);
        member.prepareForCalculate();
    }
        
    addDependsOnToRecalculateList(model,recalculateList,member);
}

function addDependsOnToRecalculateList(model,recalculateList,member) {
    //add any member that depends on this one  
    var impactsList = model.getImpactsList(member);
    for(var i = 0; i < impactsList.length; i++) {
        let dependent = model.getMutableMember(impactsList[i]);
        addToRecalculateList(model,recalculateList,dependent);
    }
}



/** This calls execute for each member in the recalculate list. The return value
 * is false if there are any errors. */
function callRecalculateList(model,recalculateList) {
    var dependent;
    var i;
    var success = true;
    for(i = 0; i < recalculateList.length; i++) {
        dependent = recalculateList[i];
        if(dependent.getCalcPending()) {
            dependent.calculate(model);   
        }
    }
    
    return success;
}

/**
 * Action Module
 * An action is an operation on the data model. A mutable (unlocked) model must be passed in. 
 * After the action is completed, the model will be locked, and represent immutable data state.
 * 
 * The code in this module handles
 * the generic parts of the action process, and the action specific code is placed
 * elsewhere.
 * 
 * Generic Action:
 * - The action is represented by a data object "actionData". 
 * - The method doAction is called to exectue the action.
 * - Available actions are registered through the method addActionInfo.
 *   this allows the doAction method to dispatch the actionData to the proper
 *   action specific code.
 * - Included in doing that action is any updates to dependent tables and the 
 * firing of any events for the changes.
 *   
 * Registering a specific action:
 * To register a specific action, addActionInfo must be called with 
 * the name of the action and the function taht executes the action. The function
 * should be of the form: 
 * actionResult = function actionFunction(model,actionData)
 * 
 * Action Data Format:
 * The action data is used to pass data into the action specific code, Format:
 * actionData format: {
 *   "action": (The name of the action to execute),
 *   "member": (The data object that is acted upon , if applicable),
 *   (other, multiple): (Specific data for the action)
 * }
 * 
 * ChangeResult:
 * The return value of the doAction function is a change result. This is a listing of all data objects whcih changed, in the success case.
 * The format is as follows:
 * Format: {
 *  actionDone: (true/false)
 *  actionPending: (Rather than actionDone, actionPending will be returned if doAction is called while another action is in
 *      process. This should only happen for actions being called by the messenger.)
 *  errorMsg: (An error message in the case actionDone is false.)
 *  model: (The model object which was acted on. This is not returned if the action was not done.)
 *  changeList: (An array of changed objects:)
 *      - event: (the change to the object: created/updated/deleted)
 *      - model: (the model, if the object was the model)
 *      - member: (the member, if the object was a member)
 * }
 *  *   "actionPending": (This flag is returned if the action is a queued action and will be run after the
 *                  current action completes.)
 * 
 * ActionResult:
 * The return value of the an action function (not the doAction function) is an ActionResult struct, with the data below. The function should return
 * an action result for each member/model that changes. There should be a single top level action result and then there can be 
 * child action results, in the childActionResults field. An important function of the action result is to tell the doAction function
 * how to calculate updates to the model based on changes to specific members. The flags recalculateMember, recalculateDependsOnMember,
 * updateMemberDependencies and updateModelDependencies serve this purpose and are described below.
 * Format: {
 *   "actionDone": (If this is returned true the action was done. This does not mean it was error free, rather
 *                  if means the action completed and can be undone. For example, it may be setting code in a member
 *                  and the code may be invalid. That is OK. It is displayed in the UI as an error and "actionDone" = true.
 *                  ActionDone should be false there was an error such that the state of the program is compromised and the 
 *                  action can not be undone. In this case, the program will keep the original state rather than adopting 
 *                  the new state the results from the action.
 *   "actionPending": (This flag is returned if the action is a queued action and will be run after the
 *                  current action completes.)
 *   "model": (The model on which the action is acting)
 *   "member": (The object modified in the action, if it is a member. Another option is a model update, in which 
 *                  case this field is left undefined, but a model event will be included. It is also possible that
 *                  there is no member listed because the action result does not corrspond to an action on a member of 
 *                  the model. This is true on the top level result of a compound action.)
 *   "event": (This is the event that should be fired as a result of this action/actionResult. The options are:
 *                  "created", "updated" and "deleted", prefixed by the object acted upon, "member_" or "model_")
 *   "errorMsg": (This is the error message for is the actionDone is false)
 *   "childActionResults" - (This is a list of action results if there are additional child actions done with this
 *                  action. Examples where this is used are on creating, moving or deleting a folder that has chilren.)
 *   "recalculateMember" - (This is an optional action flag. The is set of the member is a dependent and it must be recalculated.)
 *   "recalculateDependsOnMember" - (This is an optional action flag. This is set if the member has its value changed, but the 
 *                  member does not need to be recalculated. The members that depend on this do however need to be recalculated.)
 *   "updateMemberDependencies" - (This is an optional action flag. The is set of the member is a dependent and it must have its dependencies
 *                  recalculated, such as if the code changes.)
 *   "updateModelDepedencies" - (This is an optional action flag. The is set of the member is a dependent and it is created, deleted or moved.
 *                  In this case, all members in the model should be checked to see if they have any dependency changes.)
 * }
 * 
 */ 

/** This structure holds the processing information for all the actions. It is set by each action. 
 * @private */
let actionInfoMap = {
};

/** This method is used to execute an action for the data model. The model object passed in should be _unlocked_.
 * At the completion of the action, before returning, the model will be locked, meaning it can not longer be changed. */
function doAction(model,actionData) {
    
    //only allow one action at a time
    if(model.isActionInProgress()) {
        //this is a messenger action - we will save it and execute it after this computation cycle is complete
        model.saveMessengerAction(actionData);
        
        //mark command as pending
        let changeResult = {};
        changeResult.actionPending = true;
        return changeResult;
    }
    
    //execute the main action
    let {success, errorMsg} = internalDoAction(model,actionData);
    if(!success) {
        let changeResult = {};
        changeResult.actionDone = false;
        changeResult.errorMsg = errorMsg;
        return changeResult;
    }
    
    //trigger any pending actions
    //these will be done asynchronously
    var savedMessengerAction;
    while(savedMessengerAction = model.getSavedMessengerAction()) {
        var runQueuedAction = true;

        if(model.checkConsecutiveQueuedActionLimitExceeded()) {
            //ask user if about continueing - THIS MUST BE SYNCHRONOUS FOR NOW. Default to cancel calculation
            var doContinue = apogeeUserConfirmSynchronous("The calculation is taking a long time: Continue?","Continue","Cancel",false);
            if(!doContinue) {
                let changeResult = {};
                changeResult.actionDone = false;
                changeResult.errorMsg = "The calculation was canceled";
                return changeResult;         
            }
        }

        if(runQueuedAction) {
            //this action is run synchronously
            let {success, errorMsg} = internalDoAction(model,savedMessengerAction);
            if(!success) {
                let changeResult = {};
                changeResult.actionDone = false;
                changeResult.errorMsg = errorMsg;
                return changeResult;
            }
        }
    }
    
    model.clearConsecutiveQueuedTracking(); 

    //check if any lazy initialized functions have not been initialized yet
    model.completeLazyInitialization();
    
    //fire the events
    let changeList = changeMapToChangeList(model.getChangeMap());
    fireEvents(model,changeList);

    //lock the model
    model.lockAll();

    //return result
    let changeResult = {};
    changeResult.actionDone = true;
    changeResult.model = model;
    changeResult.changeList = changeList;
    return changeResult;
}

/** This function is used to register an action. */
function addActionInfo(actionName,actionFunction) {
    actionInfoMap[actionName] = actionFunction;
}

//=======================================
// Internal Methods
//=======================================

/** This method executes a single action function, */
function internalDoAction(model,actionData) {

    let success, errorMsg;

    //flag action in progress
    model.setActionInProgress(true);  

    try {

        //do the action
        let actionResult = callActionFunction(model,actionData); 
        
        //flatten action result tree into a list of objects modified in the action
        var {actionModifiedMembers, actionDone, errorMsgList} = flattenActionResult(actionResult);

        //return in the failure case
        if(actionDone) {
            //this list will be additional modified members - from dependency changes
            //due to adding and deleting members (This happens when a new remote member is referenced
            //a member formula because of creating or deleting. This is not a common event, but it does happen)
            var additionalUpdatedMembers = [];
            
            //figure out other objects that need to be updated
            //also update dependencies (and the inverse - impacts)
            var updateAllDep = checkUpdateAllDep(actionModifiedMembers);
            if(updateAllDep) {
                //update entire model - see conditions bewlo
                model.updateDependeciesForModelChange(additionalUpdatedMembers);
            }
            else {
                updateDependenciesFromAction(model,actionModifiedMembers);
            }

            //commit the updated impacts map (inverse of dependency map) 
            model.finalizeImpactsMap();
            model.finalizeMemberMap();

            //populate recalc list
            let recalculateList = createRecalculateList(model,actionModifiedMembers,additionalUpdatedMembers);
   
            //recalculate all needed objects
            callRecalculateList(model,recalculateList);

            success = true;
        }
        else {
            success = false;
            errorMsg = errorMsgList.join("; ");
        }

    }
	catch(error) {
        if(error.stack) console.error(error.stack);
        success = false;
        errorMsg = "Unknown error updating model: " + error.message;
    }

    //flag action in progress
    model.setActionInProgress(false);

    return {success, errorMsg};
}

/** This function looks up the proper function for an action and executes it. */
function callActionFunction(model,actionData) {

    let actionResult;

    //do the action
    var actionFunction = actionInfoMap[actionData.action];
    if(actionFunction) {
        actionResult = actionFunction(model,actionData);
    }
    else {
        actionResult = {};
        actionResult.actionDone = false;
        actionResult.errorMsg = "Unknown action: " + actionData.action;
    }  

    return actionResult;
}

/** This method makes sure the member dependencies in the model are properly updated. 
 * @private */
function updateDependenciesFromAction(model,actionModifiedMembers) {
    //upate dependencies on table with updated code
    actionModifiedMembers.forEach(actionResult => {
        if((actionResult.member)&&(actionResult.member.isCodeable)&&(actionResult.updateMemberDependencies)) {
            actionResult.member.initializeDependencies(model);
        }
    });
}

/** This method takes the members that are updated (either by code or value) and
 * adds them to the list of members that need to be recalculated. To do this, we must
 * first have all dependencies updated, sicne it relies on the impacts list. */
function createRecalculateList(model,actionModifiedMembers,additionalUpdatedMembers) {
    let recalculateList = [];

    //add members from each action and/or fields they impact, if applicable
    actionModifiedMembers.forEach( actionResult => {
        //update the recalc list
        if(actionResult.recalculateMember) {
            addToRecalculateList(model,recalculateList,actionResult.member);            
        }
        else if(actionResult.recalculateDependsOnMembers) {
            addDependsOnToRecalculateList(model,recalculateList,actionResult.member);                         
        }
    });

    //add any other modified members to the racalculate list
    additionalUpdatedMembers.forEach(member => addToRecalculateList(model,recalculateList,member));

    return recalculateList;
}

/** This function fires the proper events for the  It combines events to 
 * fire a single event for each member.
 * @private */
function fireEvents(model,changeList) {
    changeList.forEach(changeListEntry => {
        model.dispatchEvent(changeListEntry.event,changeListEntry.instance);
    });
}

function changeMapToChangeList(changeMap) {
    let changeList = [];
    for(let id in changeMap) {
        let changeMapEntry = changeMap[id];

        //ignore the transient objects
        if(changeMapEntry.action == "transient") continue;

        let changeListEntry = {};
        changeListEntry.event = changeMapEntry.instance.getType() + "_" + changeMapEntry.action;
        changeListEntry.instance = changeMapEntry.instance;
        changeList.push(changeListEntry);
    }
    return changeList;
}

/** This method determines if updating all dependencies is necessary. Our dependency 
 * tracking may be in error if a new member is created, a member is deleted or
 * a member is moved. In these actions we flag that the entire model should be
 * updated.*/
function checkUpdateAllDep(completedResults) {
    //return true if any results have the updateModelDependencies flag set
    return completedResults.some(result => result.updateModelDependencies)
}

/** This method unpacks the actionResult and its child reponse into an array of actionResult. */
function flattenActionResult(actionResult) {
    let actionResultInfo = {};
    actionResultInfo.actionModifiedMembers = [];
    actionResultInfo.actionDone = true;
    actionResultInfo.errorMsgList = [];

    addToCompletedResultList(actionResultInfo,actionResult);

    return actionResultInfo;
}

function addToCompletedResultList(actionResultInfo,actionResult) {
    actionResultInfo.actionModifiedMembers.push(actionResult);
    if(!actionResult.actionDone) actionResultInfo.actionDone = false;
    if(actionResult.errorMsgList) actionResultInfo.errorMsgList.push(actionResult.errorMsg);

    if(actionResult.childActionResults) {
        actionResult.childActionResults.forEach( childActionResult => {
            addToCompletedResultList(actionResultInfo,childActionResult);
        });
    }
}

//============================================
// Compound Action
//============================================

/** The compound action is automatically imported when the action module is imported.
 *
 * Action Data format:
 * {
 *  "action": "compoundAction",
 *  "actions": (list of actions in this compound action),
 * }
 */


/** This method is the action function for a compound action. */
function compoundActionFunction(model,actionData) {

    let actionResult = {};

    var actionList = actionData.actions;
    actionResult.childActionResults = [];
    for(var i = 0; i < actionList.length; i++) {
        let childActionData = actionList[i];
        let childActionResult = callActionFunction(model,childActionData);
        actionResult.childActionResults.push(childActionResult);   
    }
    actionResult.actionDone = true;
    return actionResult;
}

//This line of code registers the action 
addActionInfo("compoundAction",compoundActionFunction);

/** This function parses the code and returns a table that gives the variable use
 * in the passed function. The var info table has the following content
 * - it is a map with an entry for each variable accessed. (This refers just to
 * a variable and not to field access on that variable.
 * - the key for an entry is the name of the variable
 * - for each entry there is an array of usages. Each usage as the following info:
 * -- nameUse.path: an array of names constructing the field accessed.
   -- nameUse.scope: a reference to a scope object
   -- nameUse.node: the AST node that identifies this variable
   -- nameUse.isLocal: true if this is a reference to a local variable
   -- nameUse.decalredScope: for local variables only, gives the scope in which the lcoal variable is declared.
 * - additionally, there is a flag indicating if all uses of a name are local variables
 * -- isLocal: true if all uses of a varaible entry are local variables
 **/ 

/** Syntax for AST, names from Esprima.
 * Each entry is a list of nodes inside a node of a given type. the list
 * contains entries with the given fields:
 * {
 *     name:[the name of the field in the node]
 *     list:[true if the field is a list of nodes]
 *     declaration:[boolean indicating if the field corrsponds to a field declaration]
 * @private */
const syntax = {
    AssignmentExpression: [{name:'left'},{name:'right'}],
    ArrayExpression: [{name:'elements',list:true}],
    ArrayPattern: [{name:'elements',list:true}],
    ArrowFunctionExpression: [{name:'params',list:true,declaration:true},{name:'body'},{name:'defaults',list:true}],
    BlockStatement: [{name:'body',list:true}],
    BinaryExpression: [
        {name:'left'},
        {name:'right'}
        //I'm not sure I know all of these. Some may modify the object but we will skip that check here
    ],         
    BreakStatement: [],
    CallExpression: [{name:'callee'},{name:'arguments',list:true}],
    CatchClause: [
        {name:'param',declaration:true},
        {name:'body'}
        //guards omitted - moz specific
    ],
    ConditionalExpression: [{name:'test'},{name:'alternate'},{name:'consequent'}],
    ContinueStatement: [],
    DoWhileStatement: [{name:'body'},{name:'test',list:true}],
    EmptyStatement: [],
    ExpressionStatement: [{name:'expression'}],
    ForStatement: [{name:'init'},{name:'test'},{name:'update',list:true},{name:'body'}],
    ForOfStatement: [{name:'left'},{name:'right'},{name:'body'}],
    ForInStatement: [{name:'left'},{name:'right'},{name:'body'}],
    FunctionDeclaration: [
        {name:'id',declaration:true},
        {name:'params',list:true,declaration:true},
        {name:'body'}
        //no supporting default functions values
    ],
    FunctionExpression: [
        {name:'id',declaration:true},
        {name:'params',list:true,declaration:true},
        {name:'body'}
        //no supporting default functions values
    ],
    Identifier: [], //this is handled specially
    IfStatement: [{name:'test'},{name:'consequent'},{name:'alternate'}],
    Literal: [],
    LabeledStatement: [{name:'body'}],
    LogicalExpression: [{name:'left'},{name:'right'}],
    MemberExpression: [], //this handled specially
    NewExpression: [{name:'callee'},{name:'arguments',list:true}],
    Program: [{name:'body',list:true}],
    Property: [{name:'key'},{name:'value'}], //this is handled specially
    ReturnStatement: [{name:'argument'}],
    RestElement: [{name:'argument'}],
    SequenceExpression: [{name:'expressions',list:true}],
    ObjectExpression: [{name:'properties',list:true}], //this is handled specially 
    ObjectPattern: [{name:'properties',list:true}], 
    SpreadElement: [{name:'argument'}],
    SwitchCase: [{name:'test'},{name:'consequent',list:true}],
    SwitchStatement: [{name:'discriminant'},{name:'cases',list:true}],
    TemplateElement: [],
    TemplateLiteral: [{name:'quasis',list:true},{name:'expressions',list:true}],
    ThisExpression: [],
    ThrowStatement: [{name:'argument'}],
    TryStatement: [
        {name:'block'},
        {name:'handler'},
        {name:'finalizer',list:true}
        //guards omitted, moz specific
    ],
    UnaryExpression: [
        {name:'argument'}
        //the delete operator modifies, but we will skip that error check here
        //"-" | "+" | "!" | "~" | "typeof" | "void" | "delete"
    ],
    UpdateExpression: [{identifierNode:'argument'}],
    VariableDeclaration: [{name:'declarations',list:true,declaration:true}],
    VariableDeclarator: [{name:'id',declaration:true},{name:'init'}],
    WhileStatement: [{name:'body'},{name:'test',list:true}],
    WithStatement: [{name:'object'},{name:'body'}],
    YieldExpression: [
        {name:'argument'}
        //moz spidermonkey specific
    ],

    

    //no support
    AssignmentPattern: null,
    ClassBody: null,
    ClassDeclaration: null,
    ClassExpression: null,
    DebuggerStatement: null,
    ExportAllDeclaration: null,
    ExportDefaultDeclaration: null,
    ExportNamedDeclaration: null,
    ExportSpecifier: null,
    ImportDeclaration: null,
    ImportDefaultSpecifier: null,
    ImportNamespaceSpecifier: null,
    ImportSpecifier: null,
    MetaProperty: null,
    MethodDefinition: null,
    Super: null,
    TaggedTemplateExpression: null

    //if we allowed module import, it would look like this I think
    //but we can not do this in a function, only a module
    //as of the time of this writing, esprima did not support parsing dynamic es6 imports
    // ImportDeclaration: [{name:'specifiers',list:true},{name:'source'}],
    // ImportDefaultSpecifier: [{name:'local'}],
    // ImportNamespaceSpecifier: [{name:'local'}],
    // ImportSpecifier: [{name:'local'},{name:'imported'}],
    
};

/** These are javascript keywords */
const KEYWORDS = {
	"abstract": true,
	"arguments": true,
	"boolean": true,
	"break": true,
	"byte": true,
	"case": true,
	"catch": true,
	"char": true,
	"class": true,
	"const": true,
	"continue": true,
	"debugger": true,
	"default": true,
	"delete": true,
	"do": true,
	"double": true,
	"else": true,
	"enum": true,
	"eval": true,
	"export": true,
	"extends": true,
	"false": true,
	"final": true,
	"finally": true,
	"float": true,
	"for": true,
	"function": true,
	"goto": true,
	"if": true,
	"implements": true,
	"import": true,
	"in": true,
	"instanceof": true,
	"int": true,
	"interface": true,
	"let": true,
	"long": true,
	"native": true,
	"new": true,
	"null": true,
	"package": true,
	"private": true,
	"protected": true,
	"public": true,
	"return": true,
	"short": true,
	"static": true,
	"super": true,
	"switch": true,
	"synchronized": true,
	"this": true,
	"throw": true,
	"throws": true,
	"transient": true,
	"true": true,
	"try": true,
	"typeof": true,
	"var": true,
	"void": true,
	"volatile": true,
	"while": true,
	"with": true,
	"yield": true,
};

/** These are variable names we will not call out in setting the context.
 * NOTE - it is OK if we do not exclude a global variable. It will still work. */
const EXCLUSION_NAMES = {
    "undefined": true,
    "Infinity": true,
    "NaN": true,
    
    "String": true,
    "Number": true,
    "Math": true,
    "Date": true,
    "Array": true,
    "Boolean": true,
    "Error": true,
    "RegExp": true,
    
    "console": true
};

////////////////////////////////////////////////////////////////////////////////
/** This method returns the error list for this formula. It is only valid
 * after a failed call to analyzeCode. 
 *
 *  Error format: (some fields may not be present)
 *  {
 *      "description":String, //A human readable description of the error
 *      "lineNumber":Integer, //line of error, with line 0 being the function declaration, and line 1 being the start of the formula
 *      "index":Integer, //the character number of the error, including the function declaration:  "function() {\n" 
 *      "column":Integer, //the column of the error
 *      "stack":String, //an error stack
 *  }
 * */
////////////////////////////////////////////////////////////////////////////////

/** This method parses the code and returns a list of variabls accessed. It throws
 * an exception if there is an error parsing.
 **/
function analyzeCode(functionText) {

    var returnValue = {};
    
    try {
        var ast = esprima.parse(functionText, { tolerant: true, loc: true, range: true });
    
        //check for errors in parsing
        if((ast.errors)&&(ast.errors.length > 0)) {
            returnValue.success = false;
            let {errorMsg,errorInfo} = createErrorInfoFromAstInfo(functionText,ast.errors);
            returnValue.errorMsg = errorMsg; 
            returnValue.errorInfo = errorInfo;
            return returnValue;
        }
        
        //get the variable list
        var varInfo = getVariableInfo(ast);

        //return the variable info
        returnValue.success = true;
        returnValue.varInfo = varInfo;
        return returnValue;
    }
    catch(internalError) {
        let {errorMsg,errorInfo} = createErrorInfoFromInternalError(functionText,internalError);
        returnValue.errorMsg = errorMsg; 
        returnValue.errorInfo = errorInfo;
        return returnValue;
    }
}

/** This method analyzes the AST to find the variabls accessed from the formula.
 * This is done to find the dependencies to determine the order of calculation. 
 * 
 * - The tree is composed of nodes. Each nodes has a type which correspondds to
 * a specific statement or other program syntax element. In particular, some
 * nodes correspond to variables, which we are collecting here.
 * - The variables are in two types of nodes, a simple Identifier node or a
 * MemberExpression, which is a sequence of Identifers.
 * - If the variable is a table, then this table is stored in the "depends on map"
 * - In addition to determining which variables a fucntion depends on, some modifiers
 * are also collected for how the variable is used. 
 * -- is declaration - this node should contain an identifier that is a declaration
 * of a local variable
 * @private */
function getVariableInfo(ast) {
    
    //create the var to hold the parse data
    var processInfo = {};
    processInfo.nameTable = {};
    processInfo.scopeTable = {};
    
    //create the base scope
    var scope = startScope(processInfo);

    //traverse the tree, recursively
    processTreeNode(processInfo,ast,false);
    
    //finish the base scope
    endScope(processInfo);
    
    //finish analyzing the accessed variables
    markLocalVariables(processInfo);
    
    //return the variable names accessed
    return processInfo.nameTable;
}
    
/** This method starts a new loca variable scope, it should be called
 * when a function starts. 
 * @private */
function startScope(processInfo) {
    //initailize id gerneator
    if(processInfo.scopeIdGenerator === undefined) {
        processInfo.scopeIdGenerator = 0;
    }
    
    //create scope
    var scope = {};
    scope.id = String(processInfo.scopeIdGenerator++);
    scope.parent = processInfo.currentScope;
    scope.localVariables ={};
    
    //save this as the current scope
    processInfo.scopeTable[scope.id] = scope;
    processInfo.currentScope = scope;
}

/** This method ends a local variable scope, reverting to the parent scope.
 * It should be called when a function exits. 
 * @private */
function endScope(processInfo) {
    var currentScope = processInfo.currentScope;
    if(!currentScope) return;
    
    //set the scope to the parent scope.
    processInfo.currentScope = currentScope.parent;
}

/** This method analyzes the AST (abstract syntax tree). 
 * @private */
function processTreeNode(processInfo,node,isDeclaration) {
    
    //process the node type
    if((node.type == "Identifier")||(node.type == "MemberExpression")) {
        //process a variable
        processVariable(processInfo,node,isDeclaration);
    } 
    else if((node.type == "FunctionDeclaration")||(node.type == "FunctionExpression")) {
        //process the functoin
        processFunction(processInfo,node);
        
    }
    else if((node.type === "NewExpression")&&(node.callee.type === "Function")) {
        //we currently do not support the function constructor
        //to add it we need to add the local variables and parse the text body
        throw createParsingError("Function constructor not currently supported!",node.loc); 
    }
    else {
        //process some other node
        processGenericNode(processInfo,node);
    }
}
   
/** This method process nodes that are not variabls identifiers. This traverses 
 * down the syntax tree.
 * @private */
function processGenericNode(processInfo,node) {
    //load the syntax node info list for this node
    var nodeInfoList = syntax[node.type];
    
    //process this list
    if(nodeInfoList === undefined) {
        //node not found
        throw createInternalParsingError("Syntax Tree Node not found: " + node.type,node.loc,node.range);
    }
    else if(nodeInfoList === null) {
        //node not supported
        throw createInternalParsingError("Syntax node not supported: " + node.type,node.loc,node.range);
    }
    else {
        //this is a good node - process it

        //-------------------------
        // process the node list
        //-------------------------
        for(var i = 0; i < nodeInfoList.length; i++) {
            //get node info
            var nodeInfo = nodeInfoList[i];
            
            //check if this field exists in node
            var childField = node[nodeInfo.name];
            if(childField) {
                
                if(nodeInfo.list) {
                    //this is a list of child nodes
                    for(var j = 0; j < childField.length; j++) {
                        processTreeNode(processInfo,childField[j],nodeInfo.declaration);
                    }
                }
                else {
                    //this is a single node
                    processTreeNode(processInfo,childField,nodeInfo.declaration);
                }
            }
        }
    }
}

/** This method processes nodes that are function. For functions a new scope is created 
 * for the body of the function.
 * @private */
function processFunction(processInfo,node) {
    var nodeType = node.type;
    var idNode = node.id;
    var params = node.params;
    var body = node.body;
    
    //difference here between the declaration and expression
    // - in declaration the name of the function is a variable in the parent scope
    // - in expression the name is typically left of. But it can be included, in which case
    //   it is a variable only in the child (function) scope. This lets the function call
    //   itself.
    
    if((nodeType === "FunctionDeclaration")&&(idNode)) {
        //parse id node (variable name) in the parent scope
        processTreeNode(processInfo,idNode,true);
    }
    
    //create a new scope for this function
    var scope = startScope(processInfo);
    
    if((nodeType === "FunctionExpression")&&(idNode)) {
        //parse id node (variable name) in the parent scope
        processTreeNode(processInfo,idNode,true);
    }
    
    //process the variable list
    for(var i = 0; i < params.length; i++) {
        processTreeNode(processInfo,params[i],true);
    }
    
    //process the function body
    processTreeNode(processInfo,body,false);
    
    //end the scope for this function
    endScope(processInfo);
}

/** This method processes nodes that are variables (identifiers and member expressions), adding
 * them to the list of variables which are used in tehe formula.
 * @private */
function processVariable(processInfo,node,isDeclaration) {
    
    //get the variable path and the base name
    var namePath = getVariableDotPath(processInfo,node);
    if(!namePath) return;
    
    var baseName = namePath[0];
    
    //check if it is an excluded name - such as a variable name used by javascript
    if(EXCLUSION_NAMES[baseName]) {
        return;
    }
    
    //add to the name table
    var nameEntry = processInfo.nameTable[baseName];
    if(!nameEntry) {
        nameEntry = {};
        nameEntry.name = baseName;
        nameEntry.uses = [];
        
        processInfo.nameTable[baseName] = nameEntry;
    }
    
    //add a name use entry
    var nameUse = {};
    nameUse.path = namePath;
    nameUse.scope = processInfo.currentScope;
    nameUse.node = node;
    
    nameEntry.uses.push(nameUse);
    
    //if this is a declaration store it as a local varaible
    if(isDeclaration) {
        //store this in the local variables for this scope
        var scopeLocalVariables = processInfo.currentScope.localVariables;
        if(!scopeLocalVariables[baseName]) {
            scopeLocalVariables[baseName] = true;
        }
    }
}

/** This method returns the variable and its fields which are given by the node.
 * It may return null, meaning there is no variable to add to the dependency.  
 * See notes embedded in the code. It is possible to fool this into making a
 * dependecne on a parent (and all children) when all that is required is a 
 * single child. 
 * @private */
function getVariableDotPath(processInfo,node) {
    if(node.type == "Identifier") {
        //read the identifier name
        return [node.name];
    }
    else if(node.type == "MemberExpression") {
        if((node.object.type == "MemberExpression")||(node.object.type == "Identifier")) {
            //MEMBER EXPRESSION OR IDENTIFIER - variable name and/or path
            var variable = getVariableDotPath(processInfo,node.object);

            if(node.computed) {
                //COMPUTED CASE
                //We will not try to figure out what the child is. We will only make a dependence on 
                //the parent. This should work but it is too strong. For example
                //we may be including dependence on a while folder when really we depend
                //on a single child in the folder.
                processTreeNode(processInfo,node.property,false);
            }
            else {
                //append the member expression property to it
                variable.push(node.property.name);
            }

            return variable;
        }
        else {
            //something other than a variable as the object for the member expressoin
            //ignore the variable path after the call. We will set a dependence
            //on the parent which should work but is too strong. For example
            //we may be including dependence on a while folder when really we depend
            //on a single child in the folder.
            processTreeNode(processInfo,node.object,false);
            
            return null;
        }
    }
    else {
        //this shouldn't happen. If it does we didn't code the syntax tree right
        throw createInternalParsingError("Unknown application error: expected a variable identifier node.",node.loc,node.range);
    }
}

/** This method annotates the variable usages that are local variables. 
 * @private */
function markLocalVariables(processInfo) {
    for(var key in processInfo.nameTable) {
        var nameEntry = processInfo.nameTable[key];
        var name = nameEntry.name;
        var existNonLocal = false;
        for(var i = 0; i < nameEntry.uses.length; i++) {
            var nameUse = nameEntry.uses[i];
            var scope = nameUse.scope;
            //check if this name is a local variable in this scope or a parent scope
            var varScope = null;
            for(var testScope = scope; testScope; testScope = testScope.parent) {
                if(testScope.localVariables[name]) {
                    varScope = testScope;
                    break;
                }
            }
            if(varScope) {
                //this is a local variable
                nameUse.isLocal = true;
                nameUse.declarationScope = varScope;
            }
            else {
                existNonLocal = true;
            }
        }
        //add a flag to the name enry if all uses are local
        if(!existNonLocal) {
            nameEntry.isLocal = true;
        }
    }
}


/** This method creates an error object. 
 * format:
 * {
 *     description:[string description],
 *     lineNumber:[integer line number, including function declaration line prepended to formula],
 *     column;[integer column on line number]
 * }
 * @private */
function createInternalParsingError(errorMsg,location,range) {
    let error = new Error(errorMsg);
    error.description = errorMsg;
    if(location) {
        error.column = location.start.column;
        error.lineNumber = location.start.line;
    }
    if(range) {
        error.index = range[0];
    }
    return error;
}

function createErrorInfoFromInternalError(functionText,internalError) {
    let errorInfo = {};
    errorInfo.type = "esprimaParseError";
    errorInfo.description = "Error parsing code: " + internalError.description;
    let errorMsg = internalError.toString();
    let errorData = {};
    if(internalError.lineNumber !== undefined) errorData.lineNumber = internalError.lineNumber;
    if(internalError.index !== undefined) errorData.index = internalError.index;
    if(internalError.column !== undefined) errorData.column = internalError.column;
    errorInfo.errors = [errorData];
    errorInfo.code = functionText;
    return {errorMsg,errorInfo};
}

/** this converts info from code analysis to a proper error */
function createErrorInfoFromAstInfo(functionText,astErrors) {
    let errorTextArray = astErrors.map(errorInfo => errorInfo.description);
    let errorMsg = "Error parsing user code: " + errorTextArray.join("; ");
    let errorInfo = {};
    errorInfo.type = "esprimaParseError";
    errorInfo.description = errorMsg;
    errorInfo.errors = astErrors;
    errorInfo.code = functionText;
    return {errorMsg,errorInfo};
}

/** @private */
const APOGEE_FORBIDDEN_NAMES = {
    "apogeeMessenger": true,
    "__initializer": true,
    "__memberFunction": true,
    "__memberGenerator": true,
    "__memberFunctionDebugHook": true
};

/** @private */
const NAME_PATTERN = /[a-zA-Z_$][0-9a-zA-Z_$]*/;

/** This function validates a table name. It returns 
 * [valid,errorMsg]. */
function validateTableName(name) {
    var nameResult = {};

    //check if it is a keyword
    if(KEYWORDS[name]) {
        nameResult.errorMessage = "Illegal name: " + name + " - Javascript reserved keyword";
        nameResult.valid = false;
    }  
    else if(EXCLUSION_NAMES[name]) {
        nameResult.errorMessage = "Illegal name: " + name + " - Javascript variable or value name";
        nameResult.valid = false;
    }
    else if(APOGEE_FORBIDDEN_NAMES[name]) {
        nameResult.errorMessage = "Illegal name: " + name + " - Apogee reserved keyword";
        nameResult.valid = false;
    }
    else {
        //check the pattern
        var nameResult = NAME_PATTERN.exec(name);
        if((!nameResult)||(nameResult[0] !== name)) {
            if(!nameResult) nameResult = {};
            nameResult.errorMessage = "Illegal name format: " + name;
            nameResult.valid = false;
        }
        else {
            nameResult.valid = true;
        }
    }
    return nameResult;
}

/** This method analyzes the code and creates the object function and dependencies. 
 * The results are loaded into the passed object processedCodeData. */
function processCode(argList,functionBody,supplementalCode,memberName) {
    
    //analyze the code
    let memberFunctionName = memberName + "_mainFunction";
    var combinedFunctionBody = createCombinedFunctionBody(memberFunctionName,argList,functionBody,supplementalCode,memberName);
        
    //get the accessed variables
    //
    //parse the code and get variable dependencies
    var effectiveCombinedFunctionBody = getEffectiveFunctionBodyHeader() + combinedFunctionBody;
    var analyzeOutput = analyzeCode(effectiveCombinedFunctionBody);
    
    var compiledInfo = {};
    
    if(analyzeOutput.success) {
        compiledInfo.varInfo = analyzeOutput.varInfo;
    }
    else {
        compiledInfo.errorMsg = analyzeOutput.errorMsg;
        if(analyzeOutput.errorInfo) compiledInfo.errorInfo = analyzeOutput.errorInfo;
        compiledInfo.valid = false;
        return compiledInfo;
    }

    //create and execute the generator function
    var generatorBody = createGeneratorBody(memberFunctionName,compiledInfo.varInfo, combinedFunctionBody);
    try {
        //execute the generator function to get the member function generator
        //and the memberFunctionContextInitializer
        var generatorFunction = new Function(generatorBody);

        //get the output functions
        var generatedFunctions = generatorFunction();
        compiledInfo.memberFunctionGenerator = generatedFunctions.memberGenerator;
        compiledInfo.memberFunctionContextInitializer = generatedFunctions.initializer;  
        compiledInfo.valid = true; 
        compiledInfo.generatorFunction = generatorFunction;                
    }
    catch(ex) {
        //this is for parse errors not captured in esprmia
        compiledInfo.errorMsg = ex.toString();
        let errorInfo = {};
        errorInfo.type = "javascriptParseError";
        errorInfo.description = compiledInfo.errorMsg;
        if(ex.stack) errorInfo.stack =  ex.stack;
        errorInfo.code = generatorBody;
        compiledInfo.errorInfo = errorInfo;
        compiledInfo.valid = false;
    }
    
    return compiledInfo;   
}


/** This method creates the user code object function body. 
 * @private */
function createCombinedFunctionBody(memberFunctionName,
        argList,
        functionBody, 
        supplementalCode,
        memberName) {
    
    var argListString = argList.join(",");
    
    //create the code body
    var combinedFunctionBody = `//${memberName}

//user private code==============
${supplementalCode}
//end user private code==========

//member main function===========
function ${memberFunctionName}(${argListString}) {
    __memberFunctionDebugHook('${memberName}');

//user main code-----------------
${functionBody}
//end user main code-------------
}
//end member function============
`;
        
    return combinedFunctionBody;
}

/** This method creates (1) a closure function that returns another generator function
 * which makes the member function and (2) a function that initializes any external 
 * variables needed in the member function.
 * This closure wraps the variables that are external to this member, meaning other
 * members in the model.
 * This initializer function allows the code to be compiled once and then used with different
 * values for other data in the model.
 * The generator that makes the member function is a closure to wrap the member private
 * code and any other needed data with the member function.
 * @private */
function createGeneratorBody(memberFunctionName,varInfo, combinedFunctionBody) {
    
    var contextDeclarationText = "";
    var initializerBody = "";

    //add the messenger as a local variable
    contextDeclarationText += "var apogeeMessenger";
    initializerBody += "apogeeMessenger = __messenger";
    
    //set the context - here we only defined the variables that are actually used.
	for(var baseName in varInfo) {        
        var baseNameInfo = varInfo[baseName];
        
        //do not add context variable for local or "returnValue", which is explicitly defined
        if((baseName === "returnValue")||(baseNameInfo.isLocal)) continue;
        
        //add a declaration
        contextDeclarationText += "\nvar " + baseName + ";";
        
        //add to the context setter
        initializerBody += '\n\t' + baseName + ' = __contextManager.getValue(__model,"' + baseName + '");';
    }
    
    //create the generator for the object function
    var generatorBody = `'use strict'
//declare context variables
${contextDeclarationText}

//context setter
function __initializer(__model,__contextManager,__messenger) {
    ${initializerBody}
};

//user code
function __memberGenerator() {
${combinedFunctionBody}
return ${memberFunctionName}
}

return {
    'memberGenerator': __memberGenerator,
    'initializer': __initializer
};
`;
    return generatorBody;    
}

   
/** This line is added when getting the dependencies to account for some local 
 * variables in the member function.
 * @private */
function getEffectiveFunctionBodyHeader(memberFunctionName) {
    return `'use strict'
var apogeeMessenger, __memberFunctionDebugHook;
`
}

/** This is a messenger class for sending action messages. 
 * If the send fails, and exception will be thrown. */
class Messenger {
    
    constructor(model,fromMember) {
        this.model = model;
        this.contextManager = fromMember.getContextManager();
        this.fromMember = fromMember;
    }

    /** This is a convenience method to set a member to a given value.
     * updateMemberName - This is a member name as it would be accessed from the local code
     * data - This is the data to set on the given member. Aside from a JSON value, additional 
     * options are a Promise, to do an asynchronous update, a Error, to send an error to 
     * that table, or apogeeutil.INVALID_VALUE to send the invalid value.
     * These updates are applied after the current calculation is completed. See documentation
     * for more information on the messenger. */
    dataUpdate(updateMemberName,data) {
        
        var member = this._getMemberObject(updateMemberName);
        if(!member) {
            throw new Error("Error calling messenger - member not fond: " + updateMemberName);
        }
        
        //set the data for the table, along with triggering updates on dependent tables.
        var actionData = {};
        actionData.action = "updateData";
        actionData.memberId = member.getId();
        actionData.data = data;
        
        //return is handled above asynchronously
        if(this.model.getIsLocked()) {
            //the messenger would work improperly here
            throw new Error("Error: Messenger must only be called during member formula calculation.");
        }
        else {
            doAction(this.model,actionData);
        }
    }

    /** This is similar to dataUpdate except is allows multiple values to be set.
     * The argument update info is an array with each element representing an individual
     * data update. Each element shoudl be a 2-element array with the first entry being
     * the table name and the second being the data value. */
    compoundDataUpdate(updateInfo) { 
        
        //make the action list
        var actionList = [];
        for(var i = 0; i < updateInfo.length; i++) {
            let updateEntry = updateInfo[i];
            let subActionData = {};
            
            let member = this._getMemberObject(updateEntry[0]);
            if(!member) {
                throw new Error("Error calling messenger - member not fond: " + updateEntry[0]);
            }
            let data = updateEntry[1];
            
            subActionData.action = "updateData";
            subActionData.memberId = member.getId();
            subActionData.data = data;
            actionList.push(subActionData);
        }
        
        //create the single compound action
        var actionData = {};
        actionData.action = "compoundAction";
        actionData.actions = actionList;
        
        //return is handled above asynchronously
        if(this.model.getIsLocked()) {
            //the messenger would work improperly here
            throw new Error("Error: Messenger must only be called during member formula calculation.");
        }
        else {
            doAction(this.model,actionData);
        }
    }
    
    //=====================
    // Private Functions
    //=====================
    
    
    /** This method returns the member instance for a given local member name,
     * as defined from the source object context. */
    _getMemberObject(localMemberName) { 
        var pathArray = localMemberName.split(".");
        var member = this.contextManager.getMember(this.model,pathArray);
        return member;
    }
}

/** This method takes the varInfo table from the code analysis and returns
 * a lit of member objects which this member depends on.
 */
function getDependencyInfo(varInfo,model,contextManager) {
	var dependsOnMap = {};
	
	//cycle through the variables used
	for(var baseName in varInfo) {
			
        //for each use of this name that is not local, find the referenced object
        var nameEntry = varInfo[baseName];
        for(var i = 0; i < nameEntry.uses.length; i++) {
            var nameUse = nameEntry.uses[i];
            if(!nameUse.isLocal) {
                //look up the object
                var namePath = nameUse.path;

                //lookup this object, along with the passthrough dependencies
                let passThroughDependencies = [];
                var impactor = contextManager.getMember(model,namePath,passThroughDependencies);

                //add the impactor to the dependency map
                if(impactor) {
                    //add as dependent
                    var memberId = impactor.getId();
                    if(dependsOnMap[memberId] != apogeeutil$1.NORMAL_DEPENDENCY) {
                        dependsOnMap[memberId] = apogeeutil$1.NORMAL_DEPENDENCY;
                    }
                }

                //add the pass through members to the dependency map (give precedence to normal dependencies)
                // passThroughDependencies.forEach(passThroughMember => {
                //     var memberId = passThroughMember.getId();
                //     if(dependsOnMap[memberId] == undefined) {
                //         dependsOnMap[memberId] = apogeeutil.PASS_THROUGH_DEPENDENCY;
                //     }
                // });
            }
		}
	}
	
	return dependsOnMap;
}

/** This component encapsulates the member functionality for objects in the model.
 * 
 * This is a mixin and not a class. It is used for the prototype of the objects that inherit from it.
 *  
 * COMPONENT DEPENDENCIES:
 * 
 * FIELD NAMES (from update event):
 * - data
 * - name
 * - parent
 * 
 * This class represents a member object. 
 * The parent should be the parent member that holds this member or the object that holds
 * the hierarchy (maybe the model). */
class Member extends FieldObject {

    constructor(name,instanceToCopy,keepUpdatedFixed,specialCaseIdValue) {
        super("member",instanceToCopy,keepUpdatedFixed,specialCaseIdValue);
        
        //==============
        //Fields
        //==============
        //Initailize these if this is a new instance
        if(!instanceToCopy) {
            this.setField("name",name);
            //"data"
            //"pendingPromise"
            this.setField("state",apogeeutil$1.STATE_NONE);
        }
    }

    /** This property tells if this object is a member. */
    get isMember() {
        return true;
    }

    /** this method gets the name. */
    getName() {
        return this.getField("name");
    }

    /** This method returns the full name in dot notation for this object. */
    getFullName(model) {
        let name = this.getField("name");
        let parentId = this.getField("parentId");
        if(parentId) {
            let parent = model.lookupMemberById(parentId);
            if(parent) {
                return parent.getChildFullName(model,name);
            }
        }
        
        //if we get here there is no parent
        return name;
    }

    /** This returns true if the full name changes. */
    isFullNameUpdated(model) {
        if(this.areAnyFieldsUpdated(["name","parentId"])) {
            return true;
        }
        else {
            let parent = this.getParent(model);
            if((parent)&&(parent.isMember)) {
                return parent.isFullNameUpdated(model); 
            } 
            else {
                //if the parent is the model, we don't need to check the full name 
                return false;
            }
        }
    }

    getParentId() {
        return this.getField("parentId");
    }

    /** This returns the parent for this member. */
    getParent(model) {
        let parentId = this.getField("parentId");
        return model.lookupMemberById(parentId);
    }

    /** This returns the parent for this member. For the root folder
     * this value is null. */
    getParentMember(model) {
        let parentId = this.getField("parentId");
        if(parentId) {
            let parent = model.lookupMemberById(parentId);
            if((parent)&&(parent instanceof Member)) {
                return parent;
            }
        }

        //if we get here, there is no parent
        return null;
    }

    //================================================
    // Serialization Methods
    //================================================

    /** This method writes the child to a json. */
    toJson(model) {
        var json = {};
        json.name = this.getField("name");
        json.type = this.constructor.generator.type;
        if(this.addToJson) {
            this.addToJson(model,json);
        }
        
        if(this.getUpdateData) {
            json.updateData = this.getUpdateData();
        }
        return json;
    }

    ///** This method creates a member from a json. IT should be implemented as a static
    // * function in extending objects. */ 
    //fromJson(parent,json,childrenJsonOutputList) {
    //}

    //=======================================
    // Data/State getting functions
    //=======================================

    /** This returns the state struct for the member. */
    getState() {
        let stateStruct = this.getField("state");
        if(stateStruct) { 
            return stateStruct.state;
        }
        else {
            //If this happens, we will just make it state normal 
            throw new Error("INVALID STATE: member " + this.getName());
        }
    }

    /** this method gets the data map. */
    getData() {
        return this.getField("data");
    }

    /** This returns true if this member accepts setting the data. */
    getSetDataOk() {
        return this.constructor.generator.setDataOk;
    }

    /** This returns the error object for this member. The entries can be javscript Error objects or other objects with a
     * toString() method. See documentation for some additional properties of these errors. */
    getError() {
        let stateStruct = this.getField("state");
        if(stateStruct) return stateStruct.error;
        else return null;
    }

    /** This method returns a simple error message for this member, if the member is in
     * the error state. Additional information can be obtained by getting the actual error object. */
    getErrorMsg() {
        let stateStruct = this.getField("state");
        if((stateStruct)&&(stateStruct.error)) {
            return stateStruct.error.toString();
        }
        else {
            //this shouldn't happen if the state is actually an error state
            return "";
        }
    }

    /** This method returns the list of error info objects for this member. It should be
     * called only when the state is error. */
    getErrorInfo() {
        let stateStruct = this.getField("state");
        if((stateStruct)&&(stateStruct.error)) return stateStruct.error.errorInfoList;
        else return [];
    }

    /** This returns the list of errors. The entries can be javscript Error objects, members (signifying a
     * dependency error), strings or other objects (which should be converted to strings). 
     * @deprecated*/
    getErrors() {
        let stateStruct = this.getField("state");
        if(stateStruct) {
            return [stateStruct.error];
        }
        else {
            //this shouldn't happen if the state is actually an error state
            return [];
        }
    }

    /** This returns the promise that is pending. */
    getPendingPromise() {
        return this.getField("pendingPromise");
    }

    /** This returns true if the pending token matches. */
    pendingPromiseMatches(promise) {
        return (this.getPendingPromise() === promise);
    }

    //=======================================
    // Update Data/State functions
    //=======================================

    /** This method sets the state to none, signifying an invalid state. */
    clearState() {
        this.setField("state",{"state":apogeeutil$1.STATE_NONE});
    }

    /** This method sets the data for this object. This is the object used by the 
     * code which is identified by this name, for example the JSON object associated
     * with a JSON table. */
    setData(model,data) {
        this.setStateAndData(model,apogeeutil$1.STATE_NORMAL,data);
    }

    /** This method adds the following error for this member. It will be valid for the current round of calculation of
     * this member. The error should be a javascript Error object, an apogee Member (signifying a dependnecy
     * error), a string, or another type, which will be interpretted as a string. */
    setError(model,error) {
        this.setStateAndData(model,apogeeutil$1.STATE_ERROR,apogeeutil$1.INVALID_VALUE,error);
    }

    /** This method adds the following errors for this member. See setError for more details.
     * @deprecated
    */
    setErrors(model,errorList) {
        //this is probably not used anywhere. If it is we will just keep the first error
        let error;
        if((errorList)&&(errorList.length >= 1)) error = errorList[0];
        this.setStateAndData(model,apogeeutil$1.STATE_ERROR,apogeeutil$1.INVALID_VALUE,error);
    }

    /** This sets the result pending flag. The promise triggering the pending state should also be passed if there
     * is one for this member. If the state is pending because it depends on a pending member, the promise should be
     * left as undefined.*/
    setResultPending(model,promise) {
        this.setStateAndData(model,apogeeutil$1.STATE_PENDING,apogeeutil$1.INVALID_VALUE);
        if(promise) {
            this.setField("pendingPromise",promise);
        }
    }

    /** This sets the result invalid flag. If the result is invalid, any
     * table depending on this will also have an invalid value. */
    setResultInvalid(model) {
        this.setStateAndData(model,apogeeutil$1.STATE_INVALID,apogeeutil$1.INVALID_VALUE);
    }

    /** This methos sets the data, where the data can be a generalized value
     *  include data, apogeeutil.INVALID_VALUE, a Promis or an Error.
     * This method does not however apply the asynchrnous data, it only flags the member as pending.
     * the asynchronous data is set separately (also) using applyAsynchFutureValue, whcih requires access
     * to the model object. */
    applyData(model,data) {

        //handle four types of data inputs
        if(data instanceof Promise) {
            //data is a promise - flag this a pending
            this.setResultPending(model,data);
        }
        else if(data instanceof Error) {
            //data is an error
            this.setError(model,data);
        }
        else if(data === apogeeutil$1.INVALID_VALUE) {
            //data is an invalid value
            this.setResultInvalid(model);
        }
        else {
            //normal data update (poosibly from an asynchronouse update)
            this.setData(model,data);
        }
    }

    /** This method implements setting asynchronous data on the member using a promise.
     * This does not however set the current pending state. */
    applyAsynchFutureValue(model,promise) {

        //kick off the asynch update
        var asynchCallback = memberValue => {
            //set the data for the table, along with triggering updates on dependent tables.
            let actionData = {};
            actionData.action = "updateData";
            actionData.memberId = this.getId();
            actionData.sourcePromise = promise;
            actionData.data = memberValue;
            model.doFutureAction(actionData);
        };
        var asynchErrorCallback = errorMsg => {
            let actionData = {};
            actionData.action = "updateData";
            actionData.memberId = this.getId();
            actionData.sourcePromise = promise;
            actionData.data = new Error(errorMsg);
            model.doFutureAction(actionData);
        };

        //call appropriate action when the promise completes
        promise.then(asynchCallback).catch(asynchErrorCallback);
    }

    
    /** This method updates the state and data. This should not typically be called directly instead the individual
     * data and state setters should be called.
     * The data value will be applied regardless of the state. The error list is applied only if the state is ERROR. */
    setStateAndData(model,state,data,error) {

        //set the state if it is error or if it changes
        let oldStateStruct = this.getField("state");
        if((state == apogeeutil$1.STATE_ERROR)||(!oldStateStruct)||(state != oldStateStruct.state)) {
            //update the state
            let newStateStruct = {};

            newStateStruct.state = state;
            if(state == apogeeutil$1.STATE_ERROR) {
                newStateStruct.error = error;
            }
            this.setField("state",newStateStruct);
        }

        //set data as specified
        if(data === undefined) {
            this.clearField("data");
        }
        else {
            this.setField("data",data);
        }

        //clear the pending promise
        //note that the pending promise must be set elsewhere if we are in pending
        if(this.getField("pendingPromise")) {
            this.clearField("pendingPromise");
        }

        //notify parent of update
        let parentId = this.getField("parentId");
        if(parentId) {
            let parent = model.getMutableMember(parentId);
            parent.childDataUpdate(model,this);
        }
    }

    //========================================
    // Move Functions
    //=========================================

    /** This method should be used to rename and/or change 
     * the parent of this member. */
    move(newName,newParent) {
        //update the name if needed
        if(newName != this.getField("name")) {
            this.setField("name",newName);
        }
        
        //update the parent if needed
        let currentParentId = this.getField("parentId");
        if(currentParentId != newParent.getId()) {
            this.setField("parentId",newParent.getId());
        }
    }

    /** This should only be used for intially setting the parent id. */
    setParentId(parentId) {
        this.setField("parentId",parentId);
    }

    //========================================
    // "Protected" Methods
    //========================================

    /** This method is called when the member is deleted. If necessary the implementation
     * can extend this function, but it should call this base version of the function
     * if it does.  
     * @protected */
    onDeleteMember(model) {
    }

    ///** This method is called when the model is closed and also when an object
    // * is deleted. It should do any needed cleanup for the object.  
    // * @protected */
    //onClose();

    //Implement this method if there is data to add to this member. Otherwise it may
    //be omitted
    ///** This method adds any additional data to the json saved for this member. 
    // * @protected */
    //addToJson(model,json) {
    //}

    //Implement this method if there is update data for this json. otherwise it may
    //be omitted
    ///** This gets an update structure to upsate a newly instantiated member
    //* to match the current object. It may return "undefined" if there is no update
    //* data needed. 
    //* @protected */
    //getUpdateData() {
    //}

    //----------------------------------
    // Error methods
    //----------------------------------

    /** This methos created a depends on error, with a dependency on all members in the passed list. */
    static createDependsOnError(model,errorImpactorList) {
        let dependsOnErrorList = errorImpactorList.map(impactor => {
            return {
                id: impactor.getId(),
                name: impactor.getFullName(model)
            }
        });
        let msgPrefix = (dependsOnErrorList.length === 1) ? "Error in dependency: " : "Error in dependencies: ";
        let errorMsg = msgPrefix + dependsOnErrorList.map(dependsOnEntry => dependsOnEntry.name).join(", ");
        let dependsOnErrorInfo = {
            type: "dependency",
            dependsOnErrorList: dependsOnErrorList
        };
        let dependsOnError = new Error(errorMsg);
        dependsOnError.isDependsOnError = true;
        Member.appendErrorInfo(dependsOnError,dependsOnErrorInfo);
        return dependsOnError;
    }

    /** This method adds the extended info to the error. It allows for multiple
     * error infos to be added. */
    static appendErrorInfo(error,errorInfo) {
        if(!error.errorInfoList) {
            error.errorInfoList = [];
        }
        error.errorInfoList.push(errorInfo);
    }
}

//add mixins to this class
apogeeutil$1.mixin(Member,FieldObject);

/** This mixin encapsulates an member whose value depends on on another
 * member. The dependent allows for a recalculation based on an update of the 
 * objects it depends on.
 * 
 * This is a mixin and not a class. It is used for the prototype of the objects that inherit from it.
 * 
 * COMPONENT DEPENDENCIES:
 * 
 */
class DependentMember extends Member {

    /** This initializes the component */
    constructor(name,instanceToCopy,keepUpdatedFixed,specialCaseIdValue) {
        super(name,instanceToCopy,keepUpdatedFixed,specialCaseIdValue);

        //==============
        //Fields
        //==============
        //Initailize these if this is a new instance
        if(!instanceToCopy) {
            //this is the list of dependencies
            this.setField("dependsOnMap",{});
        }

        //==============
        //Working variables
        //==============
        this.calcPending = false;
    }

    /** This property tells if this object is a dependent.
     * This property should not be implemented on non-dependents. */
    get isDependent() {
        return true;
    }

    /** This returns a list of the members that this member depends on. */
    getDependsOn() {
        return this.getField("dependsOnMap");
    }

    /** This returns the calc pending flag.  */
    getCalcPending() {
        return this.calcPending;
    }

    /** This sets the calc pending flag to false. It should be called when the 
     * calcultion is no longer needed.  */
    clearCalcPending() {
        this.calcPending = false;
    }

    //Must be implemented in extending object
    ///** This method udpates the dependencies if needed because
    // *a variable was added or removed from the model. Any member that has its dependencies udpated
    // * should be added to the additionalUpdatedObjects list. */
    //updateDependeciesForModelChange(model,additionalUpdatedMembers);

    ///** This is a check to see if the object should be checked for dependencies 
    // * for recalculation. It is safe for this method to always return false and
    // allow the calculation to happen. 
    // * @private */
    //memberUsesRecalculation();

    /** This does any init needed for calculation.  */
    prepareForCalculate() {
        this.calcPending = true;

        //clear any errors, and other state info
        this.clearState();
    }

    ///** This updates the member based on a change in a dependency.  */
    //calculate(model);

    /** This method calculates the contribution to the state of the member based on it dependencies. */
    calculateDependentState(model,doSetState) {
        let errorImpactorList = [];
        let resultPending = false;
        let resultInvalid = false;

        let dependsOnMap = this.getField("dependsOnMap");
        for(var idString in dependsOnMap) {
            let impactor = model.lookupMemberById(idString);
            
            let impactorState = impactor.getState();
            if(impactorState == apogeeutil$1.STATE_ERROR) {
                errorImpactorList.push(impactor);
            } 
            else if(impactorState == apogeeutil$1.STATE_PENDING) {
                resultPending = true;
            }
            else if(impactorState == apogeeutil$1.STATE_INVALID) {
                resultInvalid = true;
            }
        }

        let state;
        let error;
        if(errorImpactorList.length > 0) {
            state = apogeeutil$1.STATE_ERROR;
            error = Member.createDependsOnError(model,errorImpactorList);
            if(doSetState) this.setError(model,error);
        }
        else if(resultPending) {
            state = apogeeutil$1.STATE_PENDING;
            if(doSetState) this.setResultPending(model);
        }
        else if(resultInvalid) {
            state = apogeeutil$1.STATE_INVALID;
            if(doSetState) this.setResultInvalid(model);
        }
        else {
            state = apogeeutil$1.STATE_NORMAL;
            //state not set in normal case - will be set when data is set
        }

        return {state, error};
    }

    /** This method makes sure any impactors are set. It sets a dependency 
     * error if one or more of the dependencies has a error. */
    initializeImpactors(model) {
        //make sure dependencies are up to date
        let dependsOnMap = this.getField("dependsOnMap");
        for(var idString in dependsOnMap) {
            let impactor = model.lookupMemberById(idString);
            if((impactor.isDependent)&&(impactor.getCalcPending())) {
                impactor.calculate(model);
            }
        }
    }

    /** This method removes this dependent from the model impacts map. */
    onDeleteMember(model) {
        super.onDeleteMember(model);

        //remove this dependent from the impactor
        let dependsOnMap = this.getField("dependsOnMap");
        for(var remoteMemberIdString in dependsOnMap) {
            //remove from imacts list
            model.removeFromImpactsList(this.getId(),remoteMemberIdString);
        }
    }
    //===================================
    // Private Functions
    //===================================

    /** This sets the dependencies based on the code for the member. */
    updateDependencies(model,newDependsOnMap) {
        let dependenciesUpdated = false;

        let oldDependsOnMap = this.getField("dependsOnMap");
        for(var idString in newDependsOnMap) {
            if(newDependsOnMap[idString] != oldDependsOnMap[idString]) {
                dependenciesUpdated = true;
                if(!oldDependsOnMap[idString]) model.addToImpactsList(this.getId(),idString);
            }
        }
        for(var idString in oldDependsOnMap) {
            if(newDependsOnMap[idString] != oldDependsOnMap[idString]) {
                dependenciesUpdated = true;
                if(!newDependsOnMap[idString]) model.removeFromImpactsList(this.getId(),idString);
            }
        }

        if(dependenciesUpdated) {
            this.setField("dependsOnMap",newDependsOnMap);
        }

        return dependenciesUpdated;
    }
}

/** This mixin encapsulates an object in that can be coded. It contains a function
 * and supplemental code. Object that are codeable should also be a member and
 * dependent.
 * 
 * This is a mixin and not a class. It is used in the prototype of the objects that inherit from it.
 * 
 * COMPONENT DEPENDENCIES: 
 * - A Codeable must be ContextHolder
 * 
 * FIELD NAMES (from update event):
 * - argList
 * - functionBody
 * - private
 */
class CodeableMember extends DependentMember {

    /** This initializes the component. argList is the arguments for the object function. */
    constructor(name,instanceToCopy,keepUpdatedFixed,specialCaseIdValue) {
        super(name,instanceToCopy,keepUpdatedFixed,specialCaseIdValue);

        //mixin init where needed. This is not a scoep root. Parent scope is inherited in this object
        this.contextHolderMixinInit(false);
        
        //this should be set to true by any extending class that supresses the messenger
        //see the supressMessenger function for details.
        this.doSupressMessenger = false;
        
        //==============
        //Fields
        //==============
        //Initailize these if this is a new instance
        if(!instanceToCopy) {
            //arguments of the member function
            this.setField("argList",[]);
            //"functionBody";
            //"supplementalCode";
            //"compiledInfo"
        }
        else {
            //this is treated as a fixed variable rather than a field
            //it can be set only on creation
            if(instanceToCopy.contextParentGeneration) {
                this.contextParentGeneration = instanceToCopy.contextParentGeneration;
            }
        }
        
        //==============
        //Working variables
        //==============
        this.dependencyInitInProgress = false;
    }

    /** This property tells if this object is a codeable.
     * This property should not be implemented on non-codeables. */
    get isCodeable() {
        return true;
    } 

    getSetCodeOk() {
        return this.constructor.generator.setCodeOk;
    }

    /** This method returns the argument list.  */
    getArgList() {
        return this.getField("argList");
    }

    /** This method returns the fucntion body for this member.  */
    getFunctionBody() {
        return this.getField("functionBody");
    }

    /** This method returns the supplemental code for this member.  */
    getSupplementalCode() {
        return this.getField("supplementalCode");
    }

    /** This method returns the actual code that is executed. It will only return a valid result when there
     * is code that has been compiled for the member. */
    getCodeText() {
        let compiledInfo = this.getField("compiledInfo");
        if((compiledInfo)&&(compiledInfo.generatorFunction)) return compiledInfo.generatorFunction.toString();
        else return null;
    }

    /** This is a helper method that compiles the code as needed for setCodeInfo.*/
    applyCode(argList,functionBody,supplementalCode) {

        //save the code
        if(this.getField("argList").toString() != argList.toString()) {
            this.setField("argList",argList);
        }
        
        if(this.getField("functionBody") != functionBody) {
            this.setField("functionBody",functionBody);
        }
        
        if(this.getField("supplementalCode") != supplementalCode) {
            this.setField("supplementalCode",supplementalCode);
        }
        
        //process the code text into javascript code
        var compiledInfo = processCode(argList,functionBody,supplementalCode,this.getName());
        this.setField("compiledInfo",compiledInfo);
    }

    /** This method clears the function body and supplemental code, and
     * updates any associated variables, including the dependencies.  */
    clearCode(model) {
        if(this.getField("functionBody") != "") {
            this.setField("functionBody","");
        }
        if(this.getField("supplementalCode") != "") {
            this.setField("supplementalCode","");
        }
        this.clearField("compiledInfo");
        
        this.clearCalcPending();

        this.updateDependencies(model,[]);
    }

    /** This method returns the formula for this member.  */
    initializeDependencies(model) {

        let compiledInfo = this.getField("compiledInfo");
        
        if((this.hasCode())&&(compiledInfo.valid)) {
            //set the dependencies
            var dependsOnMap = getDependencyInfo(compiledInfo.varInfo,model,this.getCodeContextManager(model));
            this.updateDependencies(model,dependsOnMap);
            
        }
        else {
            //will not be calculated - has no dependencies
            this.updateDependencies(model,{});
        }
    }

    /** This method udpates the dependencies if needed because
     *the passed variable was added.  */
    updateDependeciesForModelChange(model,additionalUpdatedMembers) {
        let compiledInfo = this.getField("compiledInfo");
        if((compiledInfo)&&(compiledInfo.valid)) {
                    
            //calculate new dependencies
            let oldDependsOnMap = this.getDependsOn();
            let newDependsOnMap = getDependencyInfo(compiledInfo.varInfo,model,this.getCodeContextManager(model));

            if(!apogeeutil$1.jsonEquals(oldDependsOnMap,newDependsOnMap)) {
                //if dependencies changes, make a new mutable copy and add this to 
                //the updated values list
                let mutableMemberCopy = model.getMutableMember(this.getId());
                mutableMemberCopy.updateDependencies(model,newDependsOnMap);
                additionalUpdatedMembers.push(mutableMemberCopy);
            }
        }
    }

    /** This method returns the formula for this member.  */
    hasCode() {
        return this.getField("compiledInfo") ? true : false;
    }

    /** If this is true the member is ready to be executed. */
    memberUsesRecalculation() {
        return this.hasCode();
    }

    /** This method sets the data object for the member.  */
    calculate(model) {
        let compiledInfo = this.getField("compiledInfo");
        if(!compiledInfo) {
            this.setError(model,"Code not found for member: " + this.getName());
            this.clearCalcPending();
            return;
        }
        else if(!compiledInfo.valid) {
            let error = new Error(compiledInfo.errorMsg ? compiledInfo.errorMsg : "Unknown error parsing user code");
            if(compiledInfo.errorInfo) CodeableMember.appendErrorInfo(error,compiledInfo.errorInfo);
            this.setError(model,error);
            this.clearCalcPending();
            return;
        }
      
        try {
            this.processMemberFunction(model,compiledInfo.memberFunctionGenerator);
        }
        catch(error) {
            
            if(error == apogeeutil$1.MEMBER_FUNCTION_INVALID_THROWABLE) {
                //This is not an error. I don't like to throw an error
                //for an expected condition, but I didn't know how else
                //to do this. See notes where this is thrown.
                this.setResultInvalid(model);
            }
            else if(error == apogeeutil$1.MEMBER_FUNCTION_PENDING_THROWABLE) {
                //This is not an error. I don't like to throw an error
                //for an expected condition, but I didn't know how else
                //to do this. See notes where this is thrown.
                this.setResultPending(model);
            }
            else if(error.isDependsOnError) {
                //this is a depends on error from a member (presumably a fucntion table) we are calling
                this.setError(model,error);
            }
            //--------------------------------------
            else {            
                //this is an error in the code
                if(error.stack) {
                    console.error("Error calculating member " + this.getFullName(model));
                    console.error(error.stack);
                }

                //create the extended error info
                CodeableMember.storeMemberTraceInfo(model,error,this);

                let errorInfo = {};
                errorInfo.type = "runtimeError";
                errorInfo.description = "Error in code evaluating member: " + this.getFullName(model);
                if(error.stack) errorInfo.stack = error.stack;
                errorInfo.memberTrace = CodeableMember.recallMemberTraceInfo(error);

                CodeableMember.appendErrorInfo(error,errorInfo);

                this.setError(model,error);
            }
        }
        
        this.clearCalcPending();
    }

    //------------------------------
    // Member Methods
    //------------------------------

    /** This gets an update structure to update a newly instantiated member
    /* to match the current object. */
    getUpdateData() {
        var updateData = {};
        if(this.hasCode()) {
            updateData.argList = this.getArgList();
            updateData.functionBody = this.getFunctionBody();
            updateData.supplementalCode = this.getSupplementalCode();
        }
        else {
            let state = this.getState();

            //handle the possible data value cases
            if(state == apogeeutil$1.STATE_INVALID) {
                //invalid valude
                updateData.invalidValue = true;
            }
            else if(state == apogeeutil$1.STATE_PENDING) {
                //pending value - we can't do anything with this
                apogeeUserAlert("There is a pending result in a field being saved. This may not be saved properly.");
                updateData.data = "<unknown pending value>";
            }
            else if(state == apogeeutil$1.STATE_ERROR) {
                //save the error - this is a non-code/explicitly set error
                let error = this.getError();
                if(error) {
                    updateData.error = error.toString();
                    updateData.errorInfoList = error.errorInfoList;
                }
                else {
                    updateData.error = "Unknown Error"; //unknonwn error
                }
            }
            else {
                //save the data value
                updateData.data = this.getData();
            }
        }

        if(this.contextParentGeneration) {
            updateData.contextParentGeneration = this.contextParentGeneration;
        }

        return updateData;
    }

    /** This member initialized the codeable fields for a member. */
    setUpdateData(model,initialData) {
        //apply the initial data
        if(initialData.functionBody !== undefined) {
            //apply initial code
            this.applyCode(initialData.argList,
                initialData.functionBody,
                initialData.supplementalCode);
        }
        else {
            //set initial data
            if(initialData.error) {
                //reconstruct the error
                let error = new Error(initialData.error);
                if(initialData.errorInfoList) {
                    initialData.errorInfoList.forEach(errorInfo => CodeableMember.appendErrorInfo(errorInfo));
                }
                this.setError(model,error);
            }
            else if(initialData.errorList) {
                //depracated!!! replaced with initialData.error and initialData.errorInfoList
                //this feature was seldom if ever used, so we will just take the first if there is more than one
                let error = (errorList.length >= 1) ? errorList[0] : new Error("Error!");
                this.setError(model,error);
            }
            else if(initialData.invalidValue) {
                this.setResultInvalid(model);
            }
            else {
                let data = (initialData.data !== undefined) ? initialData.data : "";
                this.setData(model,data);
            }

            //set the code fields to empty strings
            this.setField("functionBody","");
            this.setField("supplementalCode","");
        }

        if(initialData.contextParentGeneration) {
            this.contextParentGeneration = initialData.contextParentGeneration;
        }
    }

    //------------------------------
    //ContextHolder methods
    //------------------------------

    /** This method creates the context manager for this member. */
    createContextManager() {
        return new ContextManager(this);
    }

    //===================================
    // Protected Functions
    //===================================

    /** This method is used to remove access to the messenger from the formula for
     * this member. This should be done if the data from the member includes user runnable
     * code. The messenger should only be called in creating a data result for the member.
     * (Specifically, calling the messenger is only valid while the member is being calculated.
     * If it is called after that it will throw an error.) One place this supression is done is
     * in a FunctionMember.
     */
    supressMessenger(doSupressMessenger) {
        this.doSupressMessenger = doSupressMessenger;
    }

    /** This function just returns the context manager for the code for this object. 
     * This is nominally the context manager for this object. However, There is an allowance
     * to use a replacement for the context manager as used in the code.
     * This is specifically intended for compound members where the end user is providing code,
     * such as through a form with expressions for input. In this case we want to code to be executed as
     * if it were on a different member. In the above menetioned case, the code should be from the parent page 
     * where the user is entering the form data. To do this, the contextParentGeneration should be set to 
     * the number of parent generations that should be used for the context member.
     */
    getCodeContextManager(model) {
        let contextMember;
        if(this.contextParentGeneration) {
            contextMember = this.getRemoteContextMember(model);
        }
        else {
            contextMember = this;
        }

        return contextMember.getContextManager();
    }

    /** This function is used to get a remote context member */
    getRemoteContextMember(model) {
        let contextMember = this;
        let parentCount = this.contextParentGeneration;
        while((parentCount)&&(contextMember)) {
            contextMember = contextMember.getParent(model);
            parentCount--;
        }
        //if we have not context member, revert to the local object
        if(!contextMember) contextMember = this;
        return contextMember;
    }



    //===================================
    // Private Functions
    //===================================

    //implementations must implement this function
    //This method takes the object function generated from code and processes it
    //to set the data for the object. (protected)
    //processMemberFunction 
    
    /** This makes sure user code of object function is ready to execute.  */
    initializeMemberFunction(model) {
        //we want to hold these as closure variables
        let functionInitialized = false;
        let functionInitializedSuccess = false;

        let memberFunctionInitializer = () => {
            
            if(functionInitialized) return functionInitializedSuccess;
            
            //make sure this in only called once
            if(this.dependencyInitInProgress) {
                this.setError(model,"Circular reference error");
                //clear calc in progress flag
                this.dependencyInitInProgress = false;
                functionInitialized = true;
                functionInitializedSuccess = false;
                return functionInitializedSuccess;
            }
            this.dependencyInitInProgress = true;
            
            try {
                //make sure the data is set in each impactor
                this.initializeImpactors(model);
                this.calculateDependentState(model,true);
                let state = this.getState();
                if((state == apogeeutil$1.STATE_ERROR)||(state == apogeeutil$1.STATE_PENDING)||(state == apogeeutil$1.STATE_INVALID)) {
                    //stop initialization if there is an issue in a dependent
                    this.dependencyInitInProgress = false;
                    functionInitialized = true;
                    functionInitializedSuccess = false;
                    return functionInitializedSuccess;
                }
                
                //set the context
                let compiledInfo = this.getField("compiledInfo");
                let messenger = this.doSupressMessenger ? undefined : new Messenger(model,this);
                compiledInfo.memberFunctionContextInitializer(model,this.getCodeContextManager(model),messenger);
                
                functionInitializedSuccess = true;
            }
            catch(error) {
                //LATER NOTE - I think this is an internal error if we get an error here
                //initializeImpactor will catch errors in user code of other members.
                //the other function calls above should not throw errors, in theory
                //investigate this more...
                if(error.stack) {
                    console.error(error.stack);
                }

                this.setError(model,error);
                functionInitializedSuccess = false;
            }
            
            this.dependencyInitInProgress = false;
            functionInitialized = true;
            return functionInitializedSuccess;
        };

        return memberFunctionInitializer();

    }

    //============================
    // Static
    //============================

    /** This method is used to add trace of members whose code was called */
    static storeMemberTraceInfo(model,error,member) {
        if(!error.memberTrace) {
            error.memberTrace = [];
        }
        let memberInfo = {};
        memberInfo.id = member.getId();
        memberInfo.name = member.getFullName(model);
        if(member.getCodeText) memberInfo.code = member.getCodeText();
        error.memberTrace.push(memberInfo);
    }

    static recallMemberTraceInfo(error) {
        return error.memberTrace;
    }

}

//add components to this class
apogeeutil$1.mixin(CodeableMember,ContextHolder);

/** This class encapsulatees a data table for a JSON object. 
 * (This object does also support function objects as elements of the json, though
 * objects using this, such as the JsonTableComponent, may not.)
*/
class JsonTable extends CodeableMember {

    constructor(name,instanceToCopy,keepUpdatedFixed,specialCaseIdValue) {
        super(name,instanceToCopy,keepUpdatedFixed,specialCaseIdValue);
    }

    //------------------------------
    // Codeable Methods
    //------------------------------

    /** This method returns the argument list. We override it because
     * for JsonTable it gets cleared when data is set. However, whenever code
     * is used we want the argument list to be this value. */
    getArgList() {
        return [];
    }
        
    /** This is he process member function from codeable. */
    processMemberFunction(model,memberGenerator) {
        let initialized = this.initializeMemberFunction(model);
        if(initialized) {
            //the data is the output of the function
            let memberFunction = memberGenerator();
            let data = memberFunction();
            this.applyData(model,data);

            //we must separately apply the asynch data set promise if there is one
            if((data)&&(data instanceof Promise)) {
                this.applyAsynchFutureValue(model,data);
            }
        } 
    }

    /** This is an optional method that, when present will allow the member data to be set if the 
     * member function is cleared. */
    getDefaultDataValue() {
        return "";
    }

    //------------------------------
    // Member Methods
    //------------------------------

    /** This method extends set data from member. It also
     * freezes the object so it is immutable. (in the future we may
     * consider copying instead, or allowing a choice)*/
    setData(model,data) {
        
        //make this object immutable
        apogeeutil$1.deepFreeze(data);

        //store the new object
        return super.setData(model,data);
    }

    /** This method creates a member from a json. It should be implemented as a static
     * method in a non-abstract class. */ 
    static fromJson(model,json) {
        let member = new JsonTable(json.name,null,null,json.specialIdValue);

        //get a copy of the initial data and set defaults if needed
        let initialData = {};
        Object.assign(initialData,json.updateData);

        //if no value is set, set to an empty string
        if(
            (!initialData.functionBody) && //no function body (anything falsy is an invalid function)
            (initialData.data === undefined) && //no data value set
            (!initialData.error) && //no error (any error will set the error state)
            (!initialData.errorList) && //DEPRECATED! no error list (any error list will set the error state)
            (initialData.invalidValue !== true) //not invalid value
        ) initialData.data = "";

        member.setUpdateData(model,initialData);

        return member;
    }
}

//============================
// Static methods
//============================

JsonTable.generator = {};
JsonTable.generator.displayName = "JSON Member";
JsonTable.generator.type = "apogee.JsonMember";
JsonTable.generator.createMember = JsonTable.fromJson;
JsonTable.generator.setDataOk = true;
JsonTable.generator.setCodeOk = true;

//register this member
Model.addMemberGenerator(JsonTable.generator);

/** This is a function. */
class FunctionTable extends CodeableMember {

    constructor(name,instanceToCopy,keepUpdatedFixed,specialCaseIdValue) {
        super(name,instanceToCopy,keepUpdatedFixed,specialCaseIdValue);
        
        //The messenger should not be available from the formula for this member
        //see details in the CodeableMember function below.
        this.supressMessenger(true);
    }

    //------------------------------
    // Codeable Methods
    //------------------------------

    processMemberFunction(model,memberGenerator) {
        var memberFunction = this.getLazyInitializedMemberFunction(model,memberGenerator);
        this.setData(model,memberFunction);
    }

    getLazyInitializedMemberFunction(model,memberGenerator) {

        //create init member function for lazy initialization
        //we need to do this for recursive functions, or else we will get a circular reference
        //here we have logic to notify of an error or other problem in the function
        var initMember = () => {
            var impactorSuccess = this.initializeMemberFunction(model);
            if(impactorSuccess) {
                //this returns the member function
                return memberGenerator();
            }
            else {
                //error handling
                let issue;
                let state = this.getState();

                //in the case of "result invalid" or "result pending" this is 
                //NOT an error. But I don't know
                //how else to stop the calculation other than throwing an error, so 
                //we do that here. It should be handled by anyone calling a function.
                if(state == apogeeutil$1.STATE_ERROR) {
                    //throw a depends on error
                    //it will be recieved by the member that triggered this init, if applicable
                    issue = FunctionTable.createDependsOnError(model,[this]);
                }
                else if(state == apogeeutil$1.STATE_PENDING) {
                    issue = apogeeutil$1.MEMBER_FUNCTION_PENDING_THROWABLE;
                }
                else if(state == apogeeutil$1.STATE_INVALID) {
                    issue = apogeeutil$1.MEMBER_FUNCTION_INVALID_THROWABLE;
                }
                else {
                    issue = new Error("Unknown problem in initializing: " + this.getName());
                }
                
                throw issue;
            } 
        };

        //create the lazy initialize function
        let memberInitialized = false;
        let source = {};

        source.initIfNeeded = () => {
            if(!memberInitialized) {
                memberInitialized = true;
                source.memberFunction = initMember();
            }
        };

        source.handleError = error => {
            console.error("Error in function call to " + this.getName());
            CodeableMember.storeMemberTraceInfo(model,error,this);
            throw error;
        };

        //create the wrapped function - we call this from the debug file to make this cleaner for the
        //user, since they will run through it from the debugger.
        let wrappedMemberFunction = __functionTableWrapper(this.getName(),source);

        //add an function on this function to allow external initialization if needed (if the function is not called before the model is locked)
        wrappedMemberFunction.initIfNeeded = source.initIfNeeded;

        return wrappedMemberFunction;
    }

    /** The function is lazy initialized so it can call itself without a 
     * ciruclar reference. The initialization happens on the first actual call. This is OK if we are doing the
     * model calculation. but if it is first called _AFTER_ the model has completed being calculated, such as
     * externally, then we will get a locked error when the lazy initialization happens. Instead, we will
     * complete the lazy initialization before the lock is done. At this point we don't need to worry about
     * circular refernce anyway, since the model has already completed its calculation. */
    lazyInitializeIfNeeded() {
        //check if the function is initialized
        let memberFunction = this.getData();
        if((memberFunction)&&(memberFunction.initIfNeeded)) {
            try {
                memberFunction.initIfNeeded();
            }
            catch(error) {
                //this error is already handled in the function table initializer
                //it is rethrown so a calling member can also get the error, since it was not present at regular intialization
                //if we initialize here in lock, that means there is nobody who called this.
            }
        }
    }

    //------------------------------
    // Member Methods
    //------------------------------

    /** This method creates a member from a json. It should be implemented as a static
     * method in a non-abstract class. */ 
    static fromJson(model,json) {
        let member = new FunctionTable(json.name,null,null,json.specialIdValue);

        //get a copy of the initial data and set defaults if needed
        let initialData = {};
        Object.assign(initialData,json.updateData);

        if(!initialData.argList) initialData.argList = [];
        if(!initialData.functionBody) initialData.functionBody = "";
        if(!initialData.supplementalCode) initialData.supplementalCode = "";

        member.setUpdateData(model,initialData);

        return member;
    }

    /** This method extends the base method to get the property values
     * for the property editting. */
    static readProperties(member,values) {
        var argList = member.getArgList();
        var argListString = argList.toString();
        values.argListString = argListString;
        return values;
    }

    /** This method executes a property update. */
    static getPropertyUpdateAction(member,newValues) {
        if((newValues.updateData)&&(newValues.updateData.argList !== undefined)) {
            var actionData = {};
            actionData.action = "updateCode";
            actionData.memberId = member.getId();
            actionData.argList = newValues.updateData.argList;
            actionData.functionBody = member.getFunctionBody();
            actionData.supplementalCode = member.getSupplementalCode();
            return actionData;
        }
        else {
            return null;
        }
    }

}

//============================
// Static methods
//============================

FunctionTable.generator = {};
FunctionTable.generator.displayName = "Function";
FunctionTable.generator.type = "apogee.FunctionMember";
FunctionTable.generator.createMember = FunctionTable.fromJson;
FunctionTable.generator.readProperties = FunctionTable.readProperties;
FunctionTable.generator.getPropertyUpdateAction = FunctionTable.getPropertyUpdateAction;
FunctionTable.generator.setDataOk = false;
FunctionTable.generator.setCodeOk = true;

//register this member
Model.addMemberGenerator(FunctionTable.generator);

/** This function defines a JsonTable that is hard coded. It is automatically added to
 * the workspace under the name typeName. */
function defineHardcodedJsonTable(displayName,typeName,functionBody,optionalPrivateCode) {

    class HardcodedJsonTable extends JsonTable {

        constructor(name,instanceToCopy,keepUpdatedFixed,specialCaseIdValue) {
            super(name,instanceToCopy,keepUpdatedFixed,specialCaseIdValue);
        }

        /** This overrides the get update data method so there is not saved data. */
        getUpdateData() {
            return undefined;
        }
        
        /** This method makes the instance using the hardocded data rather than saved data. */
        static fromJson(model,json) {
            let member = new HardcodedJsonTable(json.name,null,null,json.specialIdValue);

            //set the initial data to the hardcoded code value
            let initialData = {
                argList: [],
                functionBody: functionBody,
                aupplementalCode: optionalPrivateCode ? optionalPrivateCode : ""
            };

            member.setUpdateData(model,initialData);

            return member;
        }
    }

    HardcodedJsonTable.generator = {};
    HardcodedJsonTable.generator.displayName = displayName;
    HardcodedJsonTable.generator.type = typeName;
    HardcodedJsonTable.generator.createMember = HardcodedJsonTable.fromJson;
    HardcodedJsonTable.generator.setDataOk = false;
    HardcodedJsonTable.generator.setCodeOk = false;

    //register this member
    Model.addMemberGenerator(HardcodedJsonTable.generator);
}

/** This function defines a FunctionTable thatis hard coded. It is automatically added to
 * the workspace under the name typeName. */
function defineHardcodedFunctionTable(displayName,typeName,argListArray,functionBody,optionalPrivateCode) {

    class HardcodedFunctionTable extends FunctionTable {

        constructor(name,instanceToCopy,keepUpdatedFixed,specialCaseIdValue) {
            super(name,instanceToCopy,keepUpdatedFixed,specialCaseIdValue);
        }

        /** This overrides the get update data method so there is not saved data. */
        getUpdateData() {
            return undefined;
        }
        
        /** This method makes the instance using the hardocded data rather than saved data. */
        static fromJson(model,json) {
            let member = new HardcodedJsonTable(json.name,null,null,json.specialIdValue);

            //set the initial data to the hardcoded code value
            let initialData = {
                argList: argListArray,
                functionBody: functionBody,
                aupplementalCode: optionalPrivateCode ? optionalPrivateCode : ""
            };

            member.setUpdateData(model,initialData);

            return member;
        }
    }

    HardcodedFunctionTable.generator = {};
    HardcodedFunctionTable.generator.displayName = displayName;
    HardcodedFunctionTable.generator.type = typeName;
    HardcodedFunctionTable.generator.createMember = HardcodedFunctionTable.fromJson;
    HardcodedFunctionTable.generator.setDataOk = false;
    HardcodedFunctionTable.generator.setCodeOk = false;

    //register this member
    Model.addMemberGenerator(HardcodedFunctionTable.generator);
}

function getSerializedHardcodedTable(instanceName,typeName) {
    return {
        "name": instanceName,
        "type": typeName
    }
}

/** This is a folder. */
class Folder extends DependentMember {

    constructor(name,instanceToCopy,keepUpdatedFixed,specialCaseIdValue) {
        super(name,instanceToCopy,keepUpdatedFixed,specialCaseIdValue);

        //mixin init where needed
        //This is not a root. Scope is inherited from the parent.
        this.contextHolderMixinInit(false);
        this.parentMixinInit(instanceToCopy);
    }

    //------------------------------
    // Parent Methods
    //------------------------------

    /** In this implementation updates the dependencies and updates the data value for the folder. See notes on why the update is
     * done here rather than in 'calculate' */
    onAddChild(model,child) {
        //set all children as dependents
        let dependsOnMap = this.calculateDependents(model);
        this.updateDependencies(model,dependsOnMap);

        //recalculate data and state
        let name = child.getName();
        let data = child.getData();
        let newDataMap = this._getSplicedDataMap(model,name,data);
        let {state, error} = this.calculateDependentState(model,false);

        //set the new state and data
        this.setStateAndData(model,state,newDataMap,error,true);
    }

    /** In this implementation updates the dependencies and updates the data value for the folder. See notes on why the update is
     * done here rather than in 'calculate' */
    onRemoveChild(model,child) {
        //set all children as dependents
        let dependsOnMap = this.calculateDependents(model);
        this.updateDependencies(model,dependsOnMap);

        //recalculate data and state
        let name = child.getName();
        let newDataMap = this._getSplicedDataMap(model,name);
        let {state, error} = this.calculateDependentState(model,false);

        //set the new state and data
        this.setStateAndData(model,state,newDataMap,error,true);
    }

    /** In this implementation we update the data value for the folder. See notes on why this is
     * done here rather than in 'calculate' */
    onChildDataUpdate(model,child) {
        let childId = child.getId();
        let childIdMap = this.getChildIdMap();
        let name = child.getName();
        if(childIdMap[name] != childId) {
            apogeeUserAlert("Error - the table " + childId + " is not registered in the parent under the name "  + name);
            return;
        }

        //get new data
        let data = child.getData();
        let newDataMap = this._getSplicedDataMap(model,name,data);
        //calculate dependent state but do not set it yet
        let {state, error} = this.calculateDependentState(model,false);

        //here we will always set the data whether or not there are any issues in dependents
        this.setStateAndData(model,state,newDataMap,error,true);
    }

    /** this method gets the hame the children inherit for the full name. */
    getPossesionNameBase(model) {
        return this.getFullName(model) + ".";
    }

    //------------------------------
    // Dependent Methods
    //------------------------------

    /** There is no calculation for the folder base on dependents. */
    memberUsesRecalculation() {
        return true;
    }

    /** This usually calculates the value of the member. However, in the case of a folder the value is already updated
     * once we initialize the impactors. We update the value incrementally so that we do not need to calculate all children
     * before any data is read from the folder. If we waited, we would get a circular dependecy if we trie to specify the 
     * name of a member including the path to it. We need to allow this to avoid name colisions at times.  */
    calculate(model) {
        //make sure the data is set in each impactor
        this.initializeImpactors(model);
        
        //see note in method description - no calculation is done here. It is done incrementally as children are calculated.
        //BUT if there was no update of children since prepare for calculate,
        //we will recalculate state and reset current value.
        if(this.getState() == apogeeutil$1.STATE_NONE) {
            //get new data
            let data = this.getData();
            let {state, error} = this.calculateDependentState(model,false);
            if(state == apogeeutil$1.STATE_NONE) state = apogeeutil$1.STATE_NORMAL;

            //here we will always set the data whether or not there are any issues in dependents
            this.setStateAndData(model,state,data,error,true);
        }

        //clear calc pending flag
        this.clearCalcPending();
    }

    /** This method updates the dependencies of any children
     * based on an object being added. */
    updateDependeciesForModelChange(model,additionalUpdatedMembers) {
        //update dependencies of this folder
        let oldDependsOnMap = this.getDependsOn();
        let newDependsOnMap = this.calculateDependents(model);
        if(!apogeeutil$1.jsonEquals(oldDependsOnMap,newDependsOnMap)) {
            //if dependencies changes, make a new mutable copy and add this to 
            //the updated values list
            let mutableMemberCopy = model.getMutableMember(this.getId());
            mutableMemberCopy.updateDependencies(model,newDependsOnMap);
            additionalUpdatedMembers.push(mutableMemberCopy);
        }

        //call update in children
        let childIdMap = this.getChildIdMap();
        for(var name in childIdMap) {
            let childId = childIdMap[name];
            var child = model.lookupMemberById(childId);
            if((child)&&(child.isDependent)) {
                child.updateDependeciesForModelChange(model,additionalUpdatedMembers);
            }
        }
    }

    //------------------------------
    // Member Methods
    //------------------------------

    /** This method creates a member from a json. It should be implemented as a static
     * method in a non-abstract class. */ 
    static fromJson(model,json) {
        var folder = new Folder(json.name,null,null,json.specialIdValue);

        let dataMap = {};
        Object.freeze(dataMap);
        folder.setData(model,dataMap);

        if(json.childrenNotWriteable) {
            folder.setChildrenWriteable(false);
        }

        return folder;
    }

    /** This method adds any additional data to the json to save for this member. 
     * @protected */
    addToJson(model,json) {
        json.children = {};
        
        if(!this.getChildrenWriteable()) {
            json.childrenNotWriteable = true;
        }
        
        let childIdMap = this.getChildIdMap();
        for(var name in childIdMap) {
            let childId = childIdMap[name];
            let child = model.lookupMemberById(childId);
            json.children[name] = child.toJson(model);
        }
    }

    //------------------------------
    // context holder Methods
    //------------------------------

    /** This method retrieve creates the loaded context manager. */
    createContextManager() {
        //set the context manager
        var contextManager = new ContextManager(this);
        
        //add an entry for this folder
        var myEntry = {};
        myEntry.contextHolderAsParent = true;
        contextManager.addToContextList(myEntry);
        
        return contextManager;
    }

    //============================
    // Private methods
    //============================

    /** This method calculates the dependencies for this folder. 
     * @private */
    calculateDependents(model) {
        let dependsOnMap = [];
        let childIdMap = this.getChildIdMap();
        for(var name in childIdMap) {
            var childId = childIdMap[name];
            dependsOnMap[childId] = apogeeutil$1.NORMAL_DEPENDENCY;
        }
        return dependsOnMap;
    }

    /** This does a partial update of the folder value, for a single child */
    _getSplicedDataMap(model,addOrRemoveName,addData) {
        //shallow copy old data
        let oldDataMap = this.getData();
        let newDataMap = {};
        Object.assign(newDataMap,oldDataMap);

        //add or update this child data
        if(addData !== undefined) {
            newDataMap[addOrRemoveName] = addData;
        }
        else {
            delete newDataMap[addOrRemoveName];
        }
        
        //make this immutable and set it as data for this folder - note we want to set the data whether or not we have an error!
        Object.freeze(newDataMap);
        return newDataMap;
    }

}

//add components to this class                     
apogeeutil$1.mixin(Folder,ContextHolder);
apogeeutil$1.mixin(Folder,Parent);

//============================
// Static methods
//============================


Folder.generator = {};
Folder.generator.displayName = "Folder";
Folder.generator.type = "apogee.Folder";
Folder.generator.createMember = Folder.fromJson;
Folder.generator.setDataOk = false;
Folder.generator.setCodeOk = false;

//register this member
Model.addMemberGenerator(Folder.generator);

/** This is a folderFunction, which is basically a function
 * that is expanded into data objects. */
class FolderFunction extends DependentMember {

    constructor(name,instanceToCopy,keepUpdatedFixed,specialCaseIdValue) {
        super(name,instanceToCopy,keepUpdatedFixed,specialCaseIdValue);

        //mixin init where needed
        this.contextHolderMixinInit();
        this.parentMixinInit(instanceToCopy);

        //==============
        //Fields
        //==============
        //Initailize these if this is a new instance
        if(!instanceToCopy) {
            //this field is used to disable the calculation of the value of this function
            //It is used in the "virtual model" to prevent any unnecessary downstream calculations
            this.setField("sterilized",false);
        }
    }

    /** This gets the internal forlder for the folderFunction. */
    getInternalFolder(model) {
        return this.lookupChild(model,"body");
    }

    /** This gets the name of the return object for the folderFunction function. */
    getReturnValueString() {
        return this.getField("returnValue");
    }

    /** This gets the arg list of the folderFunction function. */
    getArgList() {
        return this.getField("argList");
    }

    //------------------------------
    // Member Methods
    //------------------------------

    /** This method creates a member from a json. It should be implemented as a static
     * method in a non-abstract class. */ 
    static fromJson(model,json) {
        let member = new FolderFunction(json.name,null,null,json.specialIdValue);

        //set initial data

        //set to an empty function
        member.setData(model,function(){});

        let initialData = json.updateData;
        let argList = ((initialData)&&(initialData.argList !== undefined)) ? initialData.argList : [];
        member.setField("argList",argList);
        let returnValueString = ((initialData)&&(initialData.returnValue !== undefined)) ? initialData.returnValue : [];
        member.setField("returnValue",returnValueString);
        
        return member;
    }

    /** This method adds any additional data to the json saved for this member. 
     * @protected */
    addToJson(model,json) {
        json.updateData = {};
        json.updateData.argList = this.getField("argList");
        json.updateData.returnValue = this.getField("returnValue");
        json.children = {};
        let childIdMap = this.getChildIdMap();
        for(var name in childIdMap) {
            var childId = childIdMap[name];
            let child = model.lookupMemberById(childId);
            if(child) {
                json.children[name] = child.toJson(model);
            }
        }
    }

    /** This method extends the base method to get the property values
     * for the property editting. */
    static readProperties(member,values) {
        var argList = member.getArgList();
        var argListString = argList.toString();
        values.argListString = argListString;
        values.returnValueString = member.getReturnValueString();
        return values;
    }

    /** This method executes a property update. */
    static getPropertyUpdateAction(folderFunction,newValues) {
        let updateData = newValues.updateData;
        if((updateData)&&((updateData.argList !== undefined)||(updateData.returnValue !== undefined))) {

            var argList = updateData.argList ? updateData.argList : folderFunction.getArgList();
            var returnValueString = updateData.returnValue ? updateData.returnValue : folderFunction.getReturnValueString();
    
            var actionData = {};
            actionData.action = "updateFolderFunction";
            actionData.memberId = folderFunction.getId();
            actionData.argList = argList;
            actionData.returnValueString = returnValueString;
            return actionData;
        }    
        else {
            return null;
        }
    }

    //-------------------------------
    // Dependent Methods
    //-------------------------------
        

    /** If this is true the member must be executed. */
    memberUsesRecalculation() {
        return true;
    }

    /** This updates the member data based on the function. It returns
     * true for success and false if there is an error.  */
    calculate(model) {  

        //if this function is sterilized, we will just set the value to invalid value.
        //This prevents any object which calls this function from updating. It is inended to be 
        //used in the virtual workspace assoicated with this folder function
        if(this.getField("sterilized")) {
            this.setResultInvalid(model);
            this.clearCalcPending();
            return;
        }

        //make sure the data is set in each impactor
        this.initializeImpactors(model);
        this.calculateDependentState(model,true);

        let state = this.getState();
        if((state != apogeeutil$1.STATE_ERROR)&&(state != apogeeutil$1.STATE_PENDING)&&(state != apogeeutil$1.STATE_INVALID)) {
            //calculate folder function if no issue in dependent
            try {
                var folderFunctionFunction = this.getFolderFunctionFunction(model);
                this.setData(model,folderFunctionFunction);
            }
            catch(error) {
                if(error.stack) console.error(error.stack);
                
                //error in calculation
                this.setError(model,error);
            }
        }
        
        this.clearCalcPending();
    }

    /** This method updates the dependencies of any children
     * based on an object being added. */
    updateDependeciesForModelChange(model,additionalUpdatedMembers) {

        //update dependencies of this folder
        let oldDependsOnMap = this.getDependsOn();
        let newDependsOnMap = this.calculateDependents(model);
        if(!apogeeutil$1.jsonEquals(oldDependsOnMap,newDependsOnMap)) {
            //if dependencies changes, make a new mutable copy and add this to 
            //the updated values list
            let mutableMemberCopy = model.getMutableMember(this.getId());
            mutableMemberCopy.updateDependencies(model,newDependsOnMap);
            additionalUpdatedMembers.push(mutableMemberCopy);
        }

        //call update in children
        let childIdMap = this.getChildIdMap();
        for(var name in childIdMap) {
            var childId = childIdMap[name];
            let child = model.lookupMemberById(childId);
            if((child)&&(child.isDependent)) {
                child.updateDependeciesForModelChange(model,additionalUpdatedMembers);
            }
        }
    }

    //------------------------------
    //ContextHolder methods
    //------------------------------

    /** This method retrieve creates the loaded context manager. */
    createContextManager() {
        //set the context manager
        var contextManager = new ContextManager(this);
        
        //add an entry for this folder
        var myEntry = {};
        myEntry.contextHolderAsParent = true;
        contextManager.addToContextList(myEntry);
        
        return contextManager;
    }

    //------------------------------
    //Parent methods
    //------------------------------

    onAddChild(model,child) {
        //set all children as dependents
        let dependsOnMap = this.calculateDependents(model);
        this.updateDependencies(model,dependsOnMap);
    }

    onRemoveChild(model,child) {
        //set all children as dependents
        let dependsOnMap = this.calculateDependents(model);
        this.updateDependencies(model,dependsOnMap);
    }

    /** this method gets the hame the children inherit for the full name. */
    getPossesionNameBase(model) {
        return this.getFullName(model) + ".";
    }

    //============================
    // Private methods
    //============================

    /** This method updates the table data object in the folder data map. 
     * @private */
    calculateDependents(model) {
        let dependsOnMap = [];
        let childIdMap = this.getChildIdMap();
        for(var name in childIdMap) {
            var childId = childIdMap[name];
            dependsOnMap[childId] = apogeeutil$1.NORMAL_DEPENDENCY;
        }
        return dependsOnMap;
    }

    /** This is called from the update action. It should not be called externally. */
    setReturnValueString(returnValueString) {
        let existingRVS = this.getField("returnValue");
        if(existingRVS != returnValueString) {
            this.setField("returnValue",returnValueString);
        }
    }

    /** This is called from the update action. It should not be called externally. */
    setArgList(argList) {
        let existingArgList = this.getField("argList");
        if(existingArgList != argList) {
            this.setField("argList",argList);
        }
    }

    /** This method creates the folderFunction function. It is called from the update action 
     * and should not be called externally. 
     * @private */
    getFolderFunctionFunction(model) {

        //create a copy of the model to do the function calculation - we don't update the UI display version
        var baseVirtualModel;
        var inputMemberIdArray;
        var returnValueMemberId; 
        
        var initialized = false;
        
        var folderFunctionFunction = (...argumentArray) => {
            
            if(!initialized) {
                //get the ids of the inputs and outputs. We can use the real instance to look these up since they don't change.
                let internalFolder = this.getInternalFolder(model);
                inputMemberIdArray = this.loadInputElementIds(model,internalFolder);
                returnValueMemberId = this.loadOutputElementId(model,internalFolder); 

                //prepare the virtual function
                //this is a copy of the original model, but with any member that is unlocked replaced.
                //to prevent us from modifying an object in use by our current real model calculation.
                baseVirtualModel = model.getCleanCopy(DUMMY_RUN_CONTEXT);

                //we want to set the folder function as "sterilized" - this prevents any downstream work from the folder function updating
                //(this is an synchronous command)
                let commandData = {};
                commandData.action = "setField";
                commandData.memberId = this.getId();
                commandData.fieldName = "sterilized";
                commandData.fieldValue = "true";
                let actionResult = doAction(baseVirtualModel,commandData);

                //we should do something with the action result
                if(!actionResult.actionDone) {
                    throw new Error("Error calculating folder function");
                }
                
                initialized = true;
            }
            
            //create an update array to set the table values for the input elements  
            var updateActionList = [];
            for(var i = 0; i < inputMemberIdArray.length; i++) {
                var entry = {};
                entry.action = "updateData";
                entry.memberId = inputMemberIdArray[i];
                entry.data = argumentArray[i];
                updateActionList.push(entry);
            }
            
            var actionData = {};
            actionData.action = "compoundAction";
            actionData.actions = updateActionList;

            //apply the update
            let instanceVirtualModel = baseVirtualModel.getMutableModel();
            var actionResult = doAction(instanceVirtualModel,actionData);        
            if(actionResult.actionDone) {
                //retrieve the result
                if(returnValueMemberId) {
                    let returnValueMember = instanceVirtualModel.lookupMemberById(returnValueMemberId);
                    let returnState = returnValueMember.getState();
                    switch(returnState) {
                        case apogeeutil$1.STATE_NORMAL:
                            return returnValueMember.getData();

                        case apogeeutil$1.STATE_ERROR:
                            //we should do better than this...
                            let error = returnValueMember.getError();
                            if(error) throw error;
                            else throw new Error("Error in function " + this.getName());

                        case apogeeutil$1.STATE_PENDING:
                            throw new Error("Error; asynchrnous functions not supporred!");

                        case apogeeutil$1.STATE_INVALID:
                            throw apogeeutil$1.MEMBER_FUNCTION_INVALID_THROWABLE;

                        default:
                            //this shouldn't happen
                            throw new Error("Unknown internal state in function!");
                    }
                }
                else {
                    //no return value found
                    return undefined;
                }
            }
            else {
                let errorMsg = actionResult.errorMsg ? actionResult.errorMsg : "Unknown error evaluating Folder Function " + this.getName();
                throw new Error(errorMsg);
            }
        };
        
        return folderFunctionFunction;    
    }

    /** This method loads the input argument members from the virtual model. 
     * @private */
    loadInputElementIds(model,internalFolder) {
        let argMembers = [];
        let argList = this.getField("argList");
        for(var i = 0; i < argList.length; i++) {
            var argName = argList[i];
            var argMember = internalFolder.lookupChild(model,argName);
            if(argMember) {
                argMembers.push(argMember.getId());
            }     
        }
        return argMembers;
    }

    /** This method loads the output member from the virtual model. 
     * @private  */
    loadOutputElementId(model,internalFolder) {
        let returnValueString = this.getField("returnValue");
        var returnValueMember = internalFolder.lookupChild(model,returnValueString);
        if(returnValueMember) return returnValueMember.getId();
        else return null;
    }
}

//add components to this class
apogeeutil$1.mixin(FolderFunction,ContextHolder);
apogeeutil$1.mixin(FolderFunction,Parent);

FolderFunction.INTERNAL_FOLDER_NAME = "body";

        
//============================
// Static methods
//============================

FolderFunction.generator = {};
FolderFunction.generator.displayName = "Folder Function";
FolderFunction.generator.type = "apogee.FolderFunction";
FolderFunction.generator.createMember = FolderFunction.fromJson;
FolderFunction.generator.readProperties = FolderFunction.readProperties;
FolderFunction.generator.getPropertyUpdateAction = FolderFunction.getPropertyUpdateAction;
FolderFunction.generator.setDataOk = false;
FolderFunction.generator.setCodeOk = false;

//register this member
Model.addMemberGenerator(FolderFunction.generator);



//////////////////////////////////////////////////////////////////

/** This is a dummy trun context. It does not allow asynch functions.
 * The usual function of the run context is to provide the proper instance 
 * of the model when an asynch command is run.
 */
const DUMMY_RUN_CONTEXT = {
    doAsynchActionCommand: function(modelId,actionData) {
        throw new Error("There should be no asych functions in this context!");
    }
};


//we will need to rethink this
// /** This is used when the return value is pending. */
// getReturnPromise(activeModelWrapper,returnValueMemberId) {
//     let promiseCompleteFunction;
//     let promise = new Promise( (resolve,reject) => {
//         promiseCompleteFunction = member => {
//             if(member.getId() == returnValueMemberId) {
//                 let memberState = member.getState();
//                 if(memberState == apogeeutil.STATE_ERROR) {
//                     //error
//                     reject(member.getErrorMsg());
//                 }
//                 else if(memberState == apogeeutil.STATE_PENDING) {
//                     //just wait for resolution
//                 }
//                 else if(memberstate == apogeeutil.STATE_INVALID) {
//                     //maybe not really what we want
//                     return INVALID_VALUE;
//                 }
//                 else {
//                     //good data
//                     return member.getData();
//                 }
//             }
//         }
//     });
//     //add listener fro promise
//     activeModelWrapper.addUpdateListener(promiseCompleteFunction);
//     return promise;
// }


    //===============================
    // Virtual Context
    //===============================

//we will need to rethink this
// function getNewInstanceContext(model) {
//     //this is needed to execute an action asynchronously
//     // let virtualRunContext = {};
//     // virtualRunContext.doAsynchActionCommand = (modelId,action) => {
//     //     setTimeout( () => {
//     //         activeVirtualModel = activeVirtualModel.getMutableModel();
//     //         activeVirtualModel.addListener("member_updated", updateListener);
//     //         doAction(activeVirtualModel,actionData); 
//     //     })
//     // }

//     let activeVirtualModel = model.getCleanModelCopy(virtualRunContext);
//     let updateListener;

//     //this manages the active copy of the model
//     let instanceContext = {
//         getMutableModel: () => {
//             activeVirtualModel = activeVirtualModel.getMutableModel();
//             return activeVirtualModel;
//         }
//     }

//     return instanceContext;
// }

/** This class encapsulatees a table with no specific functionality. It
 * is intended to be used as a placeholder when a table generator is not found. */
class ErrorTable extends Member {

    constructor(name,instanceToCopy,keepUpdatedFixed,specialCaseIdValue) {
        super(name,instanceToCopy,keepUpdatedFixed,specialCaseIdValue);    
    }

    //------------------------------
    // Member Methods
    //------------------------------

    /** This method extends set data from member. It also
     * freezes the object so it is immutable. (in the future we may
     * consider copying instead, or allowing a choice)*/
    setData(model,data) {
        
        //make this object immutable
        apogeeutil$1.deepFreeze(data);

        //store the new object
        return super.setData(model,data);
    }

    /** This overrides the commplete json to just pass back the entire json sent in. */
    toJson(model) {
        return this.getField("completeJson");
    }

    /** This method creates a member from a json. It should be implemented as a static
     * method in a non-abstract class. */ 
    static fromJson(model,json) {
        //note - we send in the complete JSON so we can return is on saving
        let member = new ErrorTable(json.name,null,null,json.specialIdValue);

        //this is a bit clumsy, but we don't want to save the "specialIdValue",
        //so we delete it if it is present
        //in other tables, it is just not added when we save the object
        let cleanedJson = apogeeutil$1.jsonCopy(json);
        if(cleanedJson.specialIdValue) delete cleanedJson.specialIdValue;

        //set the initial data
        member.setData(model,"");
        member.setField("completeJson",cleanedJson);

        return member;
    }

    //------------------------------
    // Dependent Methods
    //------------------------------

    /** This method udpates the dependencies if needed because
     *a variable was added or removed from the model.  */
    updateDependeciesForModelChange(model,additionalUpdatedMembers) {
        //no action
    }

    /** This is a check to see if the object should be checked for dependencies 
     * for recalculation. It is safe for this method to always return false and
     allow the calculation to happen.  */
   memberUsesRecalculation() {
        return false;
    }

}
//============================
// Static methods
//============================

ErrorTable.generator = {};
ErrorTable.generator.displayName = "Error Member";
ErrorTable.generator.type = "apogee.ErrorMember";
ErrorTable.generator.createMember = ErrorTable.fromJson;
ErrorTable.generator.setDataOk = false;

//register this member
Model.addMemberGenerator(ErrorTable.generator);

/** This is self installing command module. This must be imported to install the command.
 * Note that this module also contains an export, unlike most command modules. 
 * The export us used so other actions can load child members. 
 *
 * Action Data format:
 * {
 *  "action": "createMember",
 *  "parentId": (parent for new member),
 *  "name": (name of the new member),
 *  "createData": 
 *      - name
 *      - unique table type name
 *      - additional table specific data
 *      - specialIdValue (this is only to be used in special cases, to set the ID of the created object)
 *  
 * }
 *
 * MEMBER CREATED EVENT: "created"
 * Event member format:
 * {
 *  "member": (member)
 * }
 */


/** This is the action function to create a member. 
 * @private */
function createMemberAction(model,actionData) {
    
    let parent;
    if(actionData.modelIsParent) {
        //the parent is the model (It should already be mutable)
        parent = model;
    }
    else {
        //get the parent, as a new mutable instance
        parent = model.getMutableMember(actionData.parentId);

        if(!parent) {
            let actionResult = {};
            actionResult.actionDone = false;
            actionResult.errorMsg = "Parent not found for created member";
            return actionResult;
        }
    }

    let memberJson = actionData.createData;
    let actionResult = createMember(model,parent,memberJson);
    return actionResult;
}

/** This function creates a member and any children for that member, returning an action result for
 * the member. This is exported so create member can be used by other actions, such as load model. */
function createMember(model,parent,memberJson) {

    let member;
    let errorMemberCreated = false;
    let actionResult = {};
    actionResult.event = ACTION_EVENT;
    
    //create member
    let generator;
    if(memberJson) {
        generator = Model.getMemberGenerator(memberJson.type);
    }

    if(generator) {
        member = generator.createMember(model,memberJson); 
    }
    else {
        //type not found! - create a dummy object and add an error to it
        let errorTableGenerator = Model.getMemberGenerator("apogee.ErrorMember");
        member = errorTableGenerator.createMember(parent,memberJson);
        member.setError(model,"Member type not found: " + memberJson.type);
        errorMemberCreated = true;
    }

    //this codde attempts to write  the member ID into the command that created the member.
    //We want this in our stored commands so we can use it for "redo" and have a member created
    //with the same ID. That way subsequent redo commands will correctly access the replacement member.
    //This doesn't seem like an optimal way to add this info to the input command. 
    //However, for now this is the earliest peice of code that actually touches each create action.
    //An alternative is to place a predetermined ID in the command before it is executed, in the 
    //command code. However, I didn't do that for now because there is not a one-to-one map from 
    //commands to actions. A single command often creates a hierarchy of members, all of which we 
    //would want to "modify". 
    try {
        if(!memberJson.specialIdValue) {
            memberJson.specialIdValue = member.getId();
        }
    }
    catch(error) {
        //we couldn't write into the command. It may be immutable
        //downstream redo commands won't work, but we'll cleanly handle that case then
        //with a failed redo.
    }

    //register member with model
    model.registerMember(member);

    //pass this child to the parent
    member.setParentId(parent.getId());
    parent.addChild(model,member);

    //set action flags for successfull new member
    actionResult.updateModelDependencies = true;
    if((member.hasCode)&&(member.hasCode())) {
        actionResult.recalculateMember = true;
    }
    else {
        actionResult.recalculateDependsOnMembers = true;
    }

    //instantiate children if there are any
    if((memberJson.children)&&(!errorMemberCreated)) {
        actionResult.childActionResults = [];
        for(let childName in memberJson.children) {
            let childJson = memberJson.children[childName];
            let childActionResult = createMember(model,member,childJson);
            actionResult.childActionResults.push(childActionResult);
        }
    }
    

    actionResult.member = member;
    actionResult.actionDone = true;

    return actionResult;
}

let ACTION_EVENT = "created";

//This line of code registers the action 
addActionInfo("createMember",createMemberAction);

/** This is self installing command module. It has no exports
 * but it must be imported to install the command. 
 *
 * Action Data format:
 * {
 *  "action": "updateData",
 *  "memberId": (member to update),
 *  "data": (new value for the table)
 *  "sourcePromise": (OPTIONAL - If this is the completion of an asynchronous action, the
 *      source promise shoudl be included to make sure it has not been overwritten with a
 *      more recent operation.)
 *  "promiseRefresh": (OPTIONAL - If this action reinstates a previously set promise,
 *      this flag will prevent setting additional then/catch statements on the promise)
 * }
 * 
 * Action Data format:
 * {
 *  "action": "updateCode",
 *  "memberId": (member to update),
 *  "argList": (arg list for the table)
 *  "functionBody": (function body for the table)
 *  "supplementalCode": (supplemental code for the table)
 * }
 */


/** member UPDATED EVENT: "updated"
 * Event member format:
 * {
 *  "member": (member)
 * }
 */


/** Update code action function. */
function updateCode(model,actionData) {

    let actionResult = {};
    actionResult.event = ACTION_EVENT$1;
    
    var member = model.getMutableMember(actionData.memberId);
    if(!member) {
        actionResult.actionDone = false;
        actionResult.errorMsg = "Member not found for update member code";
        return actionResult;
    }
    actionResult.member = member;

    if((!member.isCodeable)||(!member.getSetCodeOk())) {
        actionResult.actionDone = false;
        actionResult.errorMsg = "can not set code on member: " + member.getFullName(model);
        return actionResult;
    }
          
    member.applyCode(actionData.argList,
        actionData.functionBody,
        actionData.supplementalCode);
        
    actionResult.actionDone = true;
    actionResult.updateMemberDependencies = true;
    actionResult.recalculateMember = true;

    return actionResult;
}

/** Update data action function. */
function updateData(model,actionData) {

    let actionResult = {};
    actionResult.event = ACTION_EVENT$1;
    
    var member = model.getMutableMember(actionData.memberId);
    if(!member) {
        actionResult.actionDone = false;
        actionResult.errorMsg = "Member not found for update member data";
        return actionResult;
    }
    actionResult.member = member;

    //if this is the resolution (or rejection) of a previously set promise
    //make sure the source promise matches the pending promise. Otherwise
    //we just ignore it (it is out of date)
    let resolvedPromise = false;
    if(actionData.sourcePromise) {
        if(!member.pendingPromiseMatches(actionData.sourcePromise)) {
            //no action - this is from an asynch action that has been overwritten. Ignore this command.
            actionResult.actionDone = true;
            return actionResult;
        }
        else {
            resolvedPromise = true;
        }
    }
    
    //check if we can set data (setting on a resolved promise is ok)
    if((!resolvedPromise)&&(!member.getSetDataOk())) {
        actionResult.actionDone = false;
        actionResult.errorMsg = "Can not set data on member: " + member.getFullName(model);
        return actionResult;
    }
        
    var data = actionData.data;

    //see if there were any dependents, to know if we need to update them
    //on setting data there will be none.
    let hadDependents = ((member.getDependsOn)&&(apogeeutil$1.jsonObjectLength(member.getDependsOn()) > 0));
    
    //if we set data, clear code (unless this is data from a resolved promise)
    if((member.isCodeable)&&(!resolvedPromise)) {
        //clear the code - so the data is used
        //UNLESS this is a delayed set date from a promise, in what case we want to keep the code.
        member.clearCode(model);
    }

    //apply the data
    member.applyData(model,data);

    //if the data is a promise, we must also initiate the asynchronous setting of the data
    if((data)&&(data instanceof Promise)) {
        member.applyAsynchFutureValue(model,data);
    }
    
    actionResult.actionDone = true;
    if(hadDependents) {
        actionResult.updateMemberDependencies = true;
    }
    actionResult.recalculateDependsOnMembers = true;

    return actionResult;
}

let ACTION_EVENT$1 = "updated";

//The following code registers the actions
addActionInfo("updateCode",updateCode);
addActionInfo("updateData",updateData);

/** This is self installing command module. It has no exports
 * but it must be imported to install the command. 
 *
 * Action Data format:
 * {
 *  "action": "moveMember",
 *  "member": (member to move),
 *  "targetName": (optional new name for the member - defaults to no new name)
 *  "targetParentId": (optiona new parent id - defaults to old parent id)
 *  
 *  \
 * }
 */

/** Move member action function */
function moveMember(model,actionData) {

    let actionResult = {};
    actionResult.event = ACTION_EVENT$2;
        
    var member = model.getMutableMember(actionData.memberId);
    if(!member) {
        actionResult.actionDone = false;
        actionResult.errorMsg = "Member not found for move member";
        return;
    }
    actionResult.member = member;

    //get the name
    let targetName;
    if(actionData.targetName) {
        targetName = actionData.targetName;
    }
    else {
        targetName = member.getName();
    }

    //get the parent
    let targetParentId;
    if(actionData.targetParentId) {
        targetParentId = actionData.targetParentId;
    }
    else {
        targetParentId = member.getParentId();
    }
    var targetParent = model.getMutableMember(targetParentId);
    if(!targetParent) {
        actionResult.actionDone = false;
        actionResult.errorMsg = "Parent not found for move member";
        return actionResult;
    }

    //if the parent changes, remove this child from the parent
    //remove from old named object from the new or old parent - if it stays, we still have the new name
    let currentParentId = member.getParentId();
    let currentParent = model.getMutableMember(currentParentId);
    if(currentParent.isParent) {
        currentParent.removeChild(model,member);
    }
        
    //appl the move to the member
    member.move(targetName,targetParent);

    //set the member in the new/old parent (rest in old parent to handle a name change)
    if(targetParent.isParent) {
        targetParent.addChild(model,member);
    }

    //create the action result
    actionResult.actionDone = true;
    actionResult.updateModelDependencies = true;
    actionResult.recalculateDependsOnMembers = true;
    
    //add the child action results
    let childActionResults = addChildResults(model,member);
    if(childActionResults) {
        actionResult.childActionResults = childActionResults;
    }
    
    return actionResult;
}

function addChildResults(model,member) {
    let childActionResults = [];
    
    if((member.isParent)||(member.isRootHolder)) {  
        var childIdMap = member.getChildIdMap();
        for(var childName in childIdMap) {
            var childId = childIdMap[childName];
            let child = model.lookupMemberById(childId);
            if(child) {
                let childActionResult = {};
                childActionResult.actionDone = true;
                childActionResult.member = child;
                childActionResult.event = ACTION_EVENT$2;
                childActionResult.updateModelDependencies = true;
                
                childActionResults.push(childActionResult);
                
                //add results for children to this member
                let grandchildActionResults = addChildResults(model,child);
                if(grandchildActionResults) {
                    childActionResult.childActionResults = grandchildActionResults;
                }
            }
        }
    }

    if(childActionResults.length > 0) {
        return childActionResults;
    }
    else {
        return null;
    }
}

let ACTION_EVENT$2 = "updated";


//This line of code registers the action 
addActionInfo("moveMember",moveMember);

/** This is self installing command module. It has no exports
 * but it must be imported to install the command. 
 *
 * Action Data format:
 * {
 *  "action": "deleteMember",
 *  "member": (member to delete),
 *  
 *  "eventInfo": (OUTPUT - event info for the associated delete event)
 * }
 *
 * MEMBER DELETED EVENT: "deleted"
 * Event object Format:
 * {
 *  "member": (member),
 *  }
 */


/** Delete member action function */
function deleteMember(model,actionData) {
    
    //get a new instance in case any changes are made during delete
    let member = model.lookupMemberById(actionData.memberId);
    if(!member) {
        let actionResult = {};
        actionResult.actionDone = false;
        actionResult.errorMsg = "Member not found for delete member";
        return actionResult;
    }
    
    let actionResult = doDelete$1(model, member);

    //remove the top-most deleted member from its parent
    let parentId = member.getParentId();
    let parent = model.getMutableMember(parentId);
    if(parent) {
        parent.removeChild(model,member);
    }

    return actionResult;
    
}


/** Here we take any actions for deleting the member and its children,
 * except "remove from parent", which we will do only for the top deleted member. 
 * @private */
function doDelete$1(model, member) {

    let actionResult = {};
    actionResult.member = member;
    actionResult.event = ACTION_EVENT$3;
    
    //delete children first
    if((member.isParent)||(member.isRootHolder)) {
        actionResult.childActionResults = [];
        
        //standard children for parent
        var childIdMap = member.getChildIdMap();
        for(var childName in childIdMap) {
            let childId = childIdMap[childName];
            let child = model.lookupMemberById(childId);
            if(child) {
                let childActionResult = doDelete$1(model, child);
                actionResult.childActionResults.push(childActionResult);
            }
        }
    }

    //delete member actions
    member.onDeleteMember(model);
    model.unregisterMember(member);
    
    actionResult.actionDone = true;
    actionResult.updateModelDependencies = true;

    return actionResult;
}

let ACTION_EVENT$3 = "deleted";


//This line of code registers the action 
addActionInfo("deleteMember",deleteMember);

/** This is self installing command module. It has no exports
 * but it must be imported to install the command. 
 *
 * Action Data format:
 * {
 *  "action": "updateFolderFunction",
 *  "member": (member to move),
 *  "argList": (argument list, as an array of strings)
 *  "returnValueString": (name of the return value table)
 *  
 *  "eventInfo": (OUTPUT - event info for the associated delete event)
 * }
 */

/** Update folder function action function */
function updateProperties(model,actionData) { 

    let actionResult = {};
    actionResult.event = ACTION_EVENT$4;
    
    var folderFunction = model.getMutableMember(actionData.memberId);
    if(!folderFunction) {
        actionResult.actionDone = false;
        actionResult.errorMsg = "Member not found for update member code";
        return;
    }
    actionResult.member = folderFunction;
    
    folderFunction.setArgList(actionData.argList);
    folderFunction.setReturnValueString(actionData.returnValueString);
    
    actionResult.actionDone = true;
    actionResult.recalculateMember = true;

    return actionResult;
}

let ACTION_EVENT$4 = "updated";

//This line of code registers the action 
addActionInfo("updateFolderFunction",updateProperties);

/** This is self installing command module. It has no exports
 * but it must be imported to install the command. 
 *
 * Action Data format:
 * {
 *  "action": "loadModel",
 *  
 *  "modelJson": model json
 *  
 * }
 *
 * MEMBER CREATED EVENT: "modelUpdated"
 * Event member format:
 * {
 *  "member": (member)
 * }
 */


/** This method instantiates a member, without setting the update data. 
 *@private */
function loadModel(model,actionData) {

    let actionResult = {};
    actionResult.event = ACTION_EVENT$5;

    let modelJson = actionData.modelJson;
    
    //check the file format
    var fileType = modelJson.fileType;
    if(fileType !== Model.SAVE_FILE_TYPE) {
        throw new Error("Bad file format.");
    }
    if(modelJson.version !== Model.SAVE_FILE_VERSION) {
        throw new Error("Incorrect file version. CHECK APOGEEJS.COM FOR VERSION CONVERTER.");
    }

    //set the model name
    if(modelJson.name !== undefined) {
        model.setName(modelJson.name);
    }

    //load the model members (root folder and its children)
    actionResult.childActionResults = [];
    for(let childName in modelJson.children) {
        let childJson = modelJson.children[childName];
        let memberActionResult = createMember(model,model,childJson);
        actionResult.childActionResults.push(memberActionResult);
    }

    actionResult.actionDone = true;
    
    return actionResult;
}

let ACTION_EVENT$5 = "updated";

//This line of code registers the action 
addActionInfo("loadModel",loadModel);

/** This is self installing command module. It has no exports
 * but it must be imported to install the command. 
 *
 * Action Data format:
 * {
 *  "action": "updated",
 *  "model": (model to update),
 *  "properties": (properties to set) //currently only "name"
 * }
 *
 * member UPDATED EVENT: "modelUpdated"
 * Event member format:
 * {
 *  "member": (member)
 * }
 */

/** Update code action function. */
function updateModel(model,actionData) { 

    let actionResult = {};
    actionResult.event = ACTION_EVENT$6;
    
    var properties = actionData.properties;
    if(properties) {
        if(properties.name) model.setName(properties.name);
    }
    
    actionResult.actionDone = true;

    return actionResult;
}

let ACTION_EVENT$6 = "updated";

//The following code registers the actions
addActionInfo("updateModel",updateModel);

/** This is self installing command module. It has no exports
 * but it must be imported to install the command. 
 * 
 * This sets a field value on a member.
 *
 * Action Data format:
 * {
 *  "action": "setField",
 *  "memberId": (member to update),
 *  "fieldName": (the name of the field to update)
 *  "fieldValue": (the new field value)
 * }
 */


/** member UPDATED EVENT: "updated"
 * Event member format:
 * {
 *  "member": (member)
 * }
 */


/** Update code action function. */
function setField(model,actionData) {

    let actionResult = {};
    actionResult.event = ACTION_EVENT$7;
    
    var member = model.getMutableMember(actionData.memberId);
    if(!member) {
        actionResult.actionDone = false;
        actionResult.errorMsg = "Member not found for update member code";
        return;
    }
    actionResult.member = member;
          
    member.setField(actionData.fieldName,actionData.fieldValue);
        
    actionResult.actionDone = true;
    actionResult.recalculateMember = true;

    return actionResult;
}

let ACTION_EVENT$7 = "updated";

//The following code registers the actions
addActionInfo("setField",setField);

//This module exports the public interface to the Apogee Core Library

var apogee = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Model: Model,
    doAction: doAction,
    validateTableName: validateTableName,
    Messenger: Messenger,
    defineHardcodedJsonTable: defineHardcodedJsonTable,
    defineHardcodedFunctionTable: defineHardcodedFunctionTable,
    getSerializedHardcodedTable: getSerializedHardcodedTable
});

/* 
 * This class manages the command history for undo/redo.
 * 
 * Commands that can be undone are stored in a circular queue with a length that is optionally 
 * settable at startup. (Otherwise a default len this used.)
 * 
 * Some rules for the undo/redo queue:
 * - only a max number of commands are stored
 * - when a command is undone or redone, the next undo and redo position is updated
 * - new commands are inserted replacing the next redo command (if there is one, otherwise they areput at the end)
 * - once the max number of commands are reached, additional added commands replace he oldeest command in the queue
 * 
 * The command manager fires an event each time the command history is updated.
 */
class CommandHistory {
    constructor(commandManager, eventManager, optionalUndoCommandCount) {
        this.commandManager = commandManager;
        this.eventManager = eventManager;
        this.undoCommandCount = (optionalUndoCommandCount !== undefined) ? optionalUndoCommandCount : CommandHistory.DEFAULT_UNDO_COMMAND_COUNT;
        this.clearHistory();
    }
    
    /** This method executes the given command and, if applicable, adds it to the queue. */
    addToHistory(undoCommand,redoCommand,description) {
        
        if((!undoCommand)||(!redoCommand)) {
            apogeeUserAlert("Both the undo command and redo command must be provided");
            return;
        }
        
        var command = {};
        command.redoCmd = redoCommand;
        command.undoCmd = undoCommand;
        command.desc = description;
        
        this._saveCommand(command);

        //set workspace dirty whenever a command is added to history (description as argument thrown in gratuitiously, for now)
        this.eventManager.dispatchEvent("workspaceDirty",command.desc);
    }
    
    /** This method clears the undo/redo history. */
    clearHistory() {
        //set a fixed size array for our circular queue
        this.undoQueue = new Array(this.undoCommandCount);
        
        //we will keep cmd index values that DO NOT wrap.
        //we will assume we do not overflow the integers for now
        //to get an array index, we convert from cmd index to array index with a function using modulo
        
        //this where we will put the next added command
        this.nextInsertCmdIndex = 0;
        //this is last index that has a valid command, but only if it is greater than or equal to our first cmd index
        this.lastUsedCmdIndex = -1;
        //this is the first command index that has a valid command, but only if it is less than or equal to the last command index.
        this.firstUsedCmdIndex = 0;
        
        if(this.eventManager) {
            this.eventManager.dispatchEvent("historyUpdate",this);
        }
        
    }
    
    /** If there is an undo command, this method will return the description if there
     * is one or an empty string. If there is no undo command, this method will return
     * the value null. */
    getNextUndoDesc() {
        let command = this._getNextUndoCommand(false);
        if(command) {
            if(command.desc) {
                return command.desc
            }
            else {
                return "";
            }
        }
        else {
            return null;
        }
    }
    
    /** If there is an redo command, this method will return the description if there
     * is one or an empty string. If there is no undo command, this method will return
     * the value null.*/
    getNextRedoDesc() {
        let command = this._getNextRedoCommand(false);
        if(command) {
            if(command.desc) {
                return command.desc
            }
            else {
                return "";
            }
        }
        else {
            return null;
        }
    }
    
    /** This method undoes the next command to be undone. */
    undo() {
        let command = this._getNextUndoCommand(true);
        if((command)&&(command.undoCmd)) {
            //in command history 
            let commandSuccess = this.commandManager.executeCommand(command.undoCmd,true);
            if(!commandSuccess) {
                this._commandUndoneFailed();
            }
            else {
                //flag workspace as dirty
                this.eventManager.dispatchEvent("workspaceDirty",command.desc);
            }
        }
        else {
            //the ui should not let us get here
            apogeeUserAlert("There is no command to undo");
        }  
    }
    
    /** This method redones the next command to be redone. */
    redo() {
        let command = this._getNextRedoCommand(true);
        if((command)&&(command.redoCmd)) {
            let commandSuccess = this.commandManager.executeCommand(command.redoCmd,true);
            if(!commandSuccess) {
                this._commandRedoneFailed();
            }
            else {
                //flag workspace as dirty
                this.eventManager.dispatchEvent("workspaceDirty",command.desc);
            }
        }
        else {
            //the ui should not let us get here
            apogeeUserAlert("There is not command to redo");
        }  
    }
    
    //=================================
    // Private Methods
    //=================================

    //-------------------------
    // These functions manage the undo queue
    //-------------------------
    
    _saveCommand(command) {
        let oldNextCmdIndex = this.nextInsertCmdIndex;
        let oldLastCmdIndex = this.lastUsedCmdIndex;
        let oldFirstCmdIndex = this.firstUsedCmdIndex;
        
        let insertArrayIndex = this._getArrayIndex(oldNextCmdIndex);
        this.undoQueue[insertArrayIndex] = command;
        
        //update cmd index vlues
        // -last used index is the one just added
        this.lastUsedCmdIndex = oldNextCmdIndex;
        // -next insert index is one more than the previous (wrapping is NOT done in the cmd index values, only in the array index values)
        this.nextInsertCmdIndex = oldNextCmdIndex + 1;
        
        // -set the first used index
        if(oldFirstCmdIndex > oldLastCmdIndex) {
            //we need to set a valid value
            this.firstUsedCmdIndex == oldNextCmdIndex;
        }
        else {
            //check for wrapping commands
            let oldFirstArrayIndex = this._getArrayIndex(oldFirstCmdIndex);
            if((insertArrayIndex == oldFirstArrayIndex)&&(oldFirstCmdIndex != oldNextCmdIndex)) {
                this.firstUsedCmdIndex++;
            }
        }
        
        //clear out any now unreachable redo commands
        if(this.nextInsertCmdIndex <= oldLastCmdIndex) {
            this._clearCommands(this.nextInsertCmdIndex,oldLastCmdIndex);
        }    
    }
    
    _getNextUndoCommand(doQueuePositionUpdate) {
        if((this.nextInsertCmdIndex - 1 >= this.firstUsedCmdIndex)&&(this.nextInsertCmdIndex - 1 <= this.lastUsedCmdIndex)) {
            let undoArrayIndex = this._getArrayIndex(this.nextInsertCmdIndex - 1);
            
            //update the queue positions, if requested
            if(doQueuePositionUpdate) {
                this.nextInsertCmdIndex--;
                
                //notify of change to command history
                if(this.eventManager) {
                    this.eventManager.dispatchEvent("historyUpdate",this);
                }
                
            }
            
            return this.undoQueue[undoArrayIndex];
        }
        else {
            //no available command
            return null;
        }
    }
    
    _getNextRedoCommand(doQueuePositionUpdate) {
        if((this.nextInsertCmdIndex >= this.firstUsedCmdIndex)&&(this.nextInsertCmdIndex <= this.lastUsedCmdIndex)) {
            let redoArrayIndex = this._getArrayIndex(this.nextInsertCmdIndex);
            
            //update the queue positions, if requested
            if(doQueuePositionUpdate) {
                this.nextInsertCmdIndex++;
                
                //notify of change to command history
                if(this.eventManager) {
                    this.eventManager.dispatchEvent("historyUpdate",this);
                }
            }
            
            return this.undoQueue[redoArrayIndex];
        }
        else {
            return null;
        }
    }
    
    _commandUndoneFailed() {
        //clear the undone command so it can not be redone (at the current position this.nextInsertCmdIndex)
        //and clear all commands previous to this one
        this._clearCommands(this.firstUsedCmdIndex,this.nextInsertCmdIndex);
        this.firstUsedCmdIndex = this.nextInsertCmdIndex;
        //we also need to update the last used index if it was the cmd we just failed to undo
        if(this.lastUsedCmdIndex === this.nextInsertCmdIndex) {
            this.lastUsedCmdIndex--;
        }
        
        //notify of change to command history
        if(this.eventManager) {
            this.eventManager.dispatchEvent("historyUpdate",this);
        }
    }
    
    _commandRedoneFailed() {
        //clear the redone command so it can not be undone (at the current position this.nextInsertCmdIndex-1)
        //and clear all commands after to this one
        this._clearCommands(this.nextInsertCmdIndex-1,this.lastUsedCmdIndex);
        this.lastUsedCmdIndex = this.nextInsertCmdIndex-1;
        //we also need to update the first used index if it was the cmd we just failed to redo
        if(this.firstUsedCmdIndex === this.nextInsertCmdIndex-1) {
            this.firstUsedCmdIndex++;
        }
        
        //notify of change to command history
        if(this.eventManager) {
            this.eventManager.dispatchEvent("historyUpdate",this);
        }
    }
    
    _getArrayIndex(cmdIndex) {
        return cmdIndex % this.undoCommandCount;
    }
    
    _clearCommands(startCmdIndex,endCmdIndex) {
        for(var cmdIndex = startCmdIndex; cmdIndex <= endCmdIndex; cmdIndex++) {
            let arrayIndex = this._getArrayIndex(cmdIndex);
            this.undoQueue[arrayIndex] = undefined;
        }
    }
}

/** This is the default number of stored undo/redo commands */
CommandHistory.DEFAULT_UNDO_COMMAND_COUNT = 50;

/* 
 * This class manages executing commands and storign and operating the command history for undo/redo.
 * It provides standarde error handling for the commands in addition to managing undo/redo or commands.
 * 
 * Command Structure:
 * {
 *      type - This is a string giving the command type. This will be used to dispatch
 *      the command to the proper execution function. The string should correspond to 
 *      a command that was registered with the regiter command function.  
 *     
 *     ?: setsDirty?
 *     
 *     ?: noUndo?
 *     
 *     (everything else depends on the specific command)
 * }
 * 
 * Command Object - Should be registered with "registerFunction". It should contain the following things:
 * - function executeCommand(workspaceManager,commandData,optionalAsynchOnComplete) = This exectues the command and return a commandResult object.
 * - function createUnfoCommand(workspceUI,commandData) - This creates an undo command json from the given command json.
 * - object commandInfo - This is metadata for the command:
 *      - type - A string giving the name of the command type
 *      - targetType - This identifies the type of the command target (what the command acts on) This may be missing if there is no event.
 *      - event - This is the name of the event the command will fire. (It should be "created", "updated", "deleted" or missing if there is no event) 
 *
 * Command functions should throw an error if they fail to execute. If there is no error thrown it is assumed the command completed 
 * successfully.
 */
class CommandManager {
    constructor(app) {
        this.app = app;

        this.commandHistory = new CommandHistory(this,app);

        this.commandInProgress = false;
        this.commandQueue = [];
    }

    /** This returns the command history. */
    getCommandHistory() {
        return this.commandHistory;
    }
    
    /** This method executes the given command. Only one command will run at a time, so if one is in progress,
     * the new command will fail. Run the command asynchronously, with setTimeout, if it is called from 
     * an in process command. If it is not known if a command is running, the method isCommandInProgress can be called to 
     * check, though this is not intended as a standard procedure.
     * The flag supressFromHistory is intended for use in undo and redo from the command history and not normal use of this function.
     * Some commands will have no undo, such as maybe open workspace. This is normally what will normally indaicate a command should not 
     * be added to the history. */
    executeCommand(command,suppressFromHistory) {

        //make sure we only exectue one command at a time. Issue with delay if one is in progress
        if(this.commandInProgress) {
            //do not allow a command while another is in progress.
            apogeeUserAlert("Command ettempted while another in progress. Ignored");
            return false;
        }
        this.commandInProgress = true;

        //get a mutable workspace manager instance
        let oldWorkspaceManager = this.app.getWorkspaceManager();
        let newWorkspaceManager;
        if(oldWorkspaceManager) {
            newWorkspaceManager = oldWorkspaceManager.getMutableWorkspaceManager();
        }
        else if(command.type == "openWorkspace") {
            //only command to run with no active workspace
            //instantiate a new empty workspace manager
            newWorkspaceManager = this.app.createWorkspaceManager();
        }
        else {
            //no workspace to run command on
            this.commandInProgress = false;
            console.log("No workspace for command: " + command.type);
            return;
        }

        var commandObject = CommandManager.getCommandObject(command.type);
        let undoCommand;
        let description;

        let undoError = false;
        let undoErrorMsg;
        let commandError = false;
        let commandErrrorMsg;

        if(commandObject) {
            //create the undo command - handle this error separately from command error
            try {
                //create undo command before doing command (since it may depend on current state)
                if((!suppressFromHistory)&&(commandObject.createUndoCommand)) {   
                    undoCommand = commandObject.createUndoCommand(newWorkspaceManager,command);  
                }

            }
            catch(error) {
                if(error.stack) console.error(error.stack);

                undoError = true;
                undoErrorMsg = error.toString();
            }

            //execute the command
            try {
                //read the desrition (this needs to be improved)
                description = commandObject.commandInfo.type;

                //execute the command
                commandObject.executeCommand(newWorkspaceManager,command);
            }
            catch(error) {
                if(error.stack) console.error(error.stack);

                commandError = true;
                commandErrrorMsg = error.toString();
            }
        }
        else {
            commandError = true;
            commandErrrorMsg = "Command type not found: " + command.type;
        }

        //--------------------------
        // Accept or reject update
        //--------------------------

        //if the command succceeded, update the workspace manager instance
        let commandDone;
        if(!commandError) {
            //success - commit accept change - set (or clear) the workspace
            if(newWorkspaceManager.getIsClosed()) {
                this.app.clearWorkspaceManager();
            }
            else {
                this.app.setWorkspaceManager(newWorkspaceManager);
            }

            //add to history if the command was done and there is an undo command
            if(undoCommand) {   
                this.commandHistory.addToHistory(undoCommand,command,description);
            }

            //fire events!!
            let changeMap = newWorkspaceManager.getChangeMap();
            let changeList = this._changeMapToChangeList(changeMap);

            newWorkspaceManager.lockAll();

            this._publishEvents(changeList);

            if(undoError) {
                //process an error on creating the history - clear the current history
                this.commandHistory.clearHistory();
                apogeeUserAlert("The command was succesful but there was an error in the history. Undo is not available. Error: " + undoErrorMsg);
            }

            commandDone = true;
        }
        else {
            //We want to update the state of any event listeners back to the state
            //before the failed calculation. For example, any failed code updates shoul
            //be cleared.
            try {
                if(oldWorkspaceManager) {
                    let changeMapAll = oldWorkspaceManager.getChangeMapAll();
                    let changeListAll = this._changeMapToChangeList(changeMapAll);

                    this._publishEvents(changeListAll);
                }

                //failure - keep the old workspace 
                apogeeUserAlert("Command failed: " + commandErrrorMsg);
            }
            catch(error) {
                //failure - and we couldn't clean up the UI! 
                //hopefully this won't happen
                let FAILED_COMMAND_AND_UI_ECOVERY_MSG = "Command failed and internal changes were undone. " +
                    "HOWEVER, the display improper values becuase of a failed UI update! " +
                    "(1) If the error is limited to pages, you can close all pages and it should be cleared when they reopen. " +
                    "(2) You can try saving. The problems shoudl be cleared when the workspae is reopened.";
                    apogeeUserAlert(FAILED_COMMAND_AND_UI_ECOVERY_MSG);
            }

            commandDone = false;
        }

        this.commandInProgress = false;
        return commandDone;
    }

    /** This method returns true if a command is in process.  */
    isCommandInProgress() {
        return this.commandInProgress;
    }

    //=================================
    // Private Methods
    //=================================

    _changeMapToChangeList(changeMap) {
        let changeList = [];
        for(let id in changeMap) {
            let changeMapEntry = changeMap[id];
            if(changeMapEntry.action != "transient") {
                let changeListEntry = {};
                changeListEntry.target = changeMapEntry.instance;
                changeListEntry.eventName = changeMapEntry.action;
                changeList.push(changeListEntry);
            }
        }
        return changeList;
    }

    /** This fires all the necessary events for the given command result */
    _publishEvents(changeList) {
        changeList.forEach( changeEntry => {
            //fire event
            if(changeEntry.eventName) {
                this.app.dispatchEvent(changeEntry.eventName,changeEntry.target);
            } 
        });
    }

    //=========================================
    // Static Methods
    //=========================================
    
    /** This registers a command. The command object should hold two functions,
     * executeCommand(workspaceManager,commandData,optionalAsynchOnComplete) and, if applicable, createUndoCommand(workspaceManager,commandData)
     * and it should have the metadata commandInfo.
     */
    static registerCommand(commandObject) {
        
        //repeat warning
        let existingCommandObject = CommandManager.commandMap[commandObject.commandInfo.type];
        if(existingCommandObject) {
            apogeeUserAlert("The given command already exists in the command manager: " + commandObject.commandInfo.type + ". It will be replaced with the new command");
        }
        
        CommandManager.commandMap[commandObject.commandInfo.type] = commandObject;
    }
    
    static getCommandObject(commandType) {
        return CommandManager.commandMap[commandType];
    }
    
}

/** This is a map of commands accessibly to the command manager. */
CommandManager.commandMap = {};

/** This class manages links and other reference entries, loading the references and
 * creating the UI tree elements for display of the references.
 * 
 * Any links needed for the page are managed externally by the Link Loader, which
 * allows multiple users to request the same link.
 */
class ReferenceManager extends FieldObject {

    constructor(app,instanceToCopy,keepUpdatedFixed) {
        super("referenceManager",instanceToCopy,keepUpdatedFixed);

        this.app = app;
        
        let referenceClassArray = ReferenceManager.getReferenceClassArray();
        this.referenceClassMap = {};
        referenceClassArray.forEach(referenceClass => {
            this.referenceClassMap[referenceClass.REFERENCE_TYPE] = referenceClass;
        });

        //==============
        //Fields
        //==============
        //Initailize these if this is a new instance
        if(!instanceToCopy) {
            //create empty reference map
            this.setField("referenceEntryMap",{});
        }

        //==============
        //Working variables
        //==============
        this.viewStateCallback = null;
        this.cachedViewState = null;

        this.workingChangeMap = {};

        //add a change map entry for this object
        this.workingChangeMap[this.getId()] = {action: instanceToCopy ? "referenceManager_updated" : "referenceManager_created", instance: this};
    }

    //====================================
    // Methods
    //====================================

    getApp() {
        return this.app;
    }

    //====================================
    // Reference Lifecycle Methods
    //====================================

    
    /** This method creates a reference entry. This does nto however load it, to 
     * do that ReferenceEntry.loadEntry() method must be called.  */
    createEntry(entryCommandData) {
        let oldEntryMap = this.getField("referenceEntryMap");
        //check if we already have this reference entry. Do not re-load it if we do.
        let entryKey = this._getEntryKey(entryCommandData.entryType,entryCommandData.url);
        let referenceEntry = oldEntryMap[entryKey];
        if(!referenceEntry) {
            //load the entry
            let referenceEntryClass = this.referenceClassMap[entryCommandData.entryType];
            if(!referenceEntryClass) throw new Error("Entry type nopt found: " + entryCommandData.entryType);
            referenceEntry = new referenceEntryClass(entryCommandData);
            this.registerRefEntry(referenceEntry);
        }
        return referenceEntry;
    }

    // updateEntry(entryType,url,entryData) {
    //     let refEntryId = this.lookupRefEntryId(entryType,url);
    //     if(!refEntryId) throw new Error("Reference entry not found. " + entryType + ":" + url);

    //     let referenceEntry = this.getMutableRefEntryById(refEntryId);
    //     if(!referenceEntry) throw new Error("Reference entry not found. refEntryId: " + refEntryId);

    //     //update entry
    //     let targetUrl = (entryData.newUrl !== undefined) ? entryData.newUrl : referenceEntry.getUrl();
    //     let targetNickname = (entryData.newNickname !== undefined) ? entryData.newNickname : referenceEntry.getNickname();
    //     referenceEntry.updateData(this.workspaceManager,targetUrl,targetNickname);

    //     this.registerRefEntry(referenceEntry);

    // }

    // removeEntry(entryType,url) {
    //     let refEntryId = this.lookupRefEntryId(entryType,url);
    //     if(!refEntryId) throw new Error("Reference entry not found. " + entryType + ":" + url);

    //     let referenceEntry = getMutableRefEntryById(refEntryId);
    //     if(!referenceEntry) throw new Error("Reference entry not found. refEntryId: " + refEntryId);

    //     referenceEntry.remove();

    //     this.unregisterRefEntry(referenceEntry);

    // }

    /** This method should be called when the parent is closed. It removes all links. */
    close() {
        let entryMap = this.getField("referenceEntryMap");
        for(let key in entryMap) {
            let referenceEntry = entryMap[key];
            referenceEntry.removeEntry();
        }
    }

    //====================================
    // Reference Owner Functionality
    //====================================

    /** The change map lists the changes to the referenceEntrys and model. This will only be
     * valid when the ReferenceManager is unlocked */
    getChangeMap() {
        return this.workingChangeMap;
    }

    getChangeMapAll() {
        let changeMapAll = {};
        let referenceEntryMap = this.getField("referenceEntryMap");
        for(let id in referenceEntryMap) {
            changeMapAll[id] = {action: "referenceEntry_updated", instance: referenceEntryMap[id]};
        }
        return changeMapAll;
    }

    /** This method locks the reference manager and all reference entries. */
    lockAll() {
        this.workingChangeMap = null;

        let referenceEntryMap = this.getField("referenceEntryMap");
        for(let id in referenceEntryMap) {
            referenceEntryMap[id].lock();
        }
        this.lock();
    }

    getRefEntryById(refEntryId) {
        return this.getField("referenceEntryMap")[refEntryId];
    }

    /** This method gets a mutable ref entry. If the current ref entry is mutable it returns
     * that. If not, it creates a mutable copy and registers the new mutable copy. It returns
     * null if the reference entry ID is not found. */
    getMutableRefEntryById(refEntryId) {
        let oldRefEntryMap = this.getField("referenceEntryMap");
        var oldRefEntry = oldRefEntryMap[refEntryId];
        if(oldRefEntry) {
            if(oldRefEntry.getIsLocked()) {
                //create an unlocked instance of the ref entry
                let newRefEntry = new oldRefEntry.constructor(null,oldRefEntry);

                //register this instance
                this.registerRefEntry(newRefEntry);

                return newRefEntry;
            }
            else {
                return oldRefEntry;
            }
        }
        else {
            return null;
        }
    }

    /** This method returns the ref entry ID for a given entry type and url. */
    lookupRefEntryId(entryType,url) {
        let urlMap = this.getField("urlMap");
        let entryKey = this._getEntryKey(entryType,url);
        return urlMap[entryKey];
    }

    /** This method returns the ref entry for a given entry type and url. */
    lookupEntry(entryType,url) {
        let refEntryId = this.lookupRefEntryId(entryType,url);
        if(refEntryId) {
            return this.getRefEntryById(refEntryId);
        }
        else {
            return null;
        }
    }

    /** This method stores the reference entry instance. It must be called when a
     * new reference entry is created and when a reference entry instance is replaced. */
    registerRefEntry(referenceEntry) {
        let refEntryId = referenceEntry.getId();
        let oldRefEntryMap = this.getField("referenceEntryMap");
        let oldRefEntry = oldRefEntryMap[refEntryId];

        //create the udpated map
        let newRefEntryMap = {};
        Object.assign(newRefEntryMap,oldRefEntryMap);
        newRefEntryMap[refEntryId] = referenceEntry;
        this.setField("referenceEntryMap",newRefEntryMap);

        //update the url map for this entry
        let oldUrlMap = this.getField("urlMap");
        let newUrlMap = {};
        Object.assign(newUrlMap,oldUrlMap);
        let newUrlKey = this._getEntryKey(referenceEntry.getEntryType(),referenceEntry.getUrl());
        if(oldRefEntry) {
            let oldUrlKey = this._getEntryKey(referenceEntry.getEntryType(),referenceEntry.getUrl());
            //delete the old entry id the key changed
            if(oldUrlKey != newUrlKey) {
                delete newUrlMap[oldUrlKey];
            }
        }
        newUrlMap[newUrlKey] = refEntryId;
        this.setField("urlMap",newUrlMap);

        //update the change map
        let oldChangeEntry = this.workingChangeMap[refEntryId];  
        let newAction; 
        if(oldChangeEntry) {
            //we will assume the events come in order
            //the only scenarios assuming order are:
            //created then updated => keep action as created
            //updated then updated => no change
            //we will just update the referenceEntry
            newAction = oldChangeEntry.action;
        }
        else {
            //new action will depend on if we have the ref entry in our old ref entry map
            newAction = oldRefEntryMap[refEntryId] ? "referenceEntry_updated" : "referenceEntry_created"; 
        }
        this.workingChangeMap[refEntryId] = {action: newAction, instance: referenceEntry};
    }

    /** This method takes the local actions needed when a referenceEntry is deleted. It is called internally. */
    unregisterRefEntry(referenceEntry) {
        let refEntryId = referenceEntry.getId();

        //update the referenceEntry map
        let oldRefEntryMap = this.getField("referenceEntryMap");
        let newRefEntryMap = {};
        Object.assign(newRefEntryMap,oldRefEntryMap);
        //remove the given referenceEntry
        delete newRefEntryMap[refEntryId];
        //save the updated map
        this.setField("referenceEntryMap",newRefEntryMap);

        //update the url map
        let oldUrlMap = this.getField("urlMap");
        let newUrlMap = {};
        Object.assign(newUrlMap,oldUrlMap);
        for(let urlKey in newUrlMap) {
            let urlRefEntryId = newUrlMap[urlKey];
            if(urlRefEntryId == refEntryId) {
                delete newUrlMap[urlKey];
            }
        }
        this.setField("urlMap",newUrlMap);

        //update the change map
        let oldChangeEntry = this.workingChangeMap[refEntryId];
        let newChangeEntry;
        if(oldChangeEntry) {
            //handle the case of an existing change entry
            if(oldChangeEntry.action == "referenceEntry_created") {
                //referenceEntry created and deleted during this action - flag it as transient
                newChangeEntry = {action: "transient", instance: referenceEntry};
            }
            else if(oldChangeEntry.action == "referenceEntry_updated") {
                newChangeEntry = {action: "referenceEntry_deleted", instance: referenceEntry};
            }
            else {
                //this shouldn't happen. If it does there is no change to the action
                //we will just update the referenceEntry
                newChangeEntry = {action: oldChangeEntry.action, instance: referenceEntry};
            }
        }
        else {
            //add a new change entry
            newChangeEntry = {action: "referenceEntry_deleted", instance: referenceEntry};
        }
        this.workingChangeMap[refEntryId] = newChangeEntry;  
    }


    //====================================
    // open and save methods
    //====================================

    setViewStateCallback(viewStateCallback) {
        this.viewStateCallback = viewStateCallback;
    }

    getCachedViewState() {
        return this.cachedViewState;
    }

    /** This method opens the reference entries. An on references load callback 
     * can be passed and it will be a called when all references are loaded, with the
     * load completion command result for each. The return value for this function is the
     * initial command result for starting the refernce loading.
     */
    load(workspaceManager,json) {

        let entryLoadedPromises = [];
        
        //load the reference entries
        if(json.refEntries) {

            //construct the load function
            let loadRefEntry = refEntryJson => {
                //create the entry (this does not actually load it)
                let referenceEntry = this.createEntry(refEntryJson);

                //load the entry - this will be asynchronous
                let loadEntryPromise = referenceEntry.loadEntry(workspaceManager);
                entryLoadedPromises.push(loadEntryPromise);
            };

            //load each entry
            json.refEntries.forEach(loadRefEntry);
        }

        //set the view state
        if(json.viewState !== undefined) {
            this.cachedViewState = json.viewState;
        }

        //create the return promise
        let referencesLoadedPromise;
        if(entryLoadedPromises.length > 0) {
            referencesLoadedPromise = Promise.all(entryLoadedPromises);
        }
        else {
            referencesLoadedPromise = Promise.resolve();
        }
        return referencesLoadedPromise;
    }

    /** This method opens the reference entries, from the structure returned from
     * the save call. It returns a promise that
     * resolves when all entries are loaded. 
     */
    toJson() {
        let json = {};
        let entryMap = this.getField("referenceEntryMap");
        let entriesJson = [];
        for(let key in entryMap) {
            let refEntry = entryMap[key];
            entriesJson.push(refEntry.toJson());
        }
        if(entriesJson.length > 0) {
            json.refEntries = entriesJson;
        }
    
        //set the view state
        if(this.viewStateCallback) {
            this.cachedViewState = this.viewStateCallback();
            if(this.cachedViewState) json.viewState = this.cachedViewState;
        }

        return json;
    }

    //=================================
    // Private
    //=================================

    _getEntryKey(entryType,url) {
        return entryType + "|"  + url;
    }

    /** This method returns the reference entry type classes which will be used in the app. */
    static getReferenceClassArray() {
        return ReferenceManager.referenceClassArray;
    }

    /** This method sets the reference entry type classes. */
    static setReferenceClassArray(referenceClassArray) {
        ReferenceManager.referenceClassArray = referenceClassArray;
    }
    
}

/** This is the base functionality for a component. */
class Component extends FieldObject {

    constructor(member,modelManager,instanceToCopy,keepUpdatedFixed) {
        super("component",instanceToCopy,keepUpdatedFixed);

        //inheriting objects can pass functions here to be called on cleanup, save, etc
        this.cleanupActions = [];
        
        //==============
        //Fields
        //==============
        //Initailize these if this is a new instance
        if(!instanceToCopy) {
            this.setField("memberFieldMap",{});

            modelManager.registerComponent(this);

            this.registerMember(modelManager,member,"member",true);
        }

        //==============
        //Working variables
        //==============
        this.viewStateCallback = null;
        this.cachedViewState = null;
    }

    /** If an extending object has any cleanup actions, a callback should be passed here.
     * The callback will be executed in the context of the current object. */
    addCleanupAction(cleanupFunction) {
        this.cleanupActions.push(cleanupFunction);
    }

    //==============================
    // Public Instance Methods
    //==============================

    /** This method returns the base member for this component. To see if this
     * field has been updated, check the "member" field of the component.  
     * To access other child members for compound components, use the access those fields using
     * the getField method. The field name is the "member." + the variable name of the field. */
    getMember() {
        return this.getField("member");
    }

    /** This method returns true if the data from a given named member field has changed. */
    isMemberDataUpdated(memberFieldName) {
        return this.isMemberFieldUpdated(memberFieldName,"data");
    }

    /** This method returns true if the given member field has been updated. */
    isMemberFieldUpdated(memberFieldName,memberFieldFieldName) {
        if(this.isFieldUpdated(memberFieldName)) {
            let member = this.getField(memberFieldName);
            return member.isFieldUpdated(memberFieldFieldName);
        }
        else {
            return false;
        }
    }

    /** This method returns true if the given member field has been updated. */
    areAnyMemberFieldsUpdated(memberFieldName,memberFieldFieldNameList) {
        if(this.isFieldUpdated(memberFieldName)) {
            let member = this.getField(memberFieldName);
            return member.areAnyFieldsUpdated(memberFieldFieldNameList);
        }
        else {
            return false;
        }
    }
    
    /** This method returns the ID for the field. It is fixed for the duration of the application.
     * it is not persistent between running the application different time. */
    getMemberId() {
        return this.getField("member").getId();
    }

    /** This method returns the name of the component. To see if the value has been updated, check 
     * the component field name "member" and the member field name "name".
     */
    getName() {
        return this.getField("member").getName();
    }

    /** This method returns the name of the member including the full path.
     * To check if the full name has changed, use the isFullNameChanged method of the member. */
    getFullName(modelManager) {
        return this.getField("member").getFullName(modelManager.getModel());
    }

    /** This method returns a display name for the member object. */
    getDisplayName(useFullPath,modelManagerForFullPathOnly) {
        if(useFullPath) {
            return this.getFullName(modelManagerForFullPathOnly);
        }
        else {
            return this.getName();
        }
    }

    /** This method returns true if the display name field is updated. This method exists because
     * display name is potentially a compound field and this is a systematic way to see if it has changed.
     * Components modifying the getDisplayName method should also update this method.
     * Note this method only applies when useFullPath = false. If you are using useFullPath = true, also
     * check if the fullName has changed. */
    isDisplayNameUpdated() {
        return this.isMemberFieldUpdated("member","name");
    }

    /** This can be used to see if the component state has been updated. */
    isStateUpdated() {
        return this.isMemberFieldUpdated("member","state");
    }

    /** This gets the map of members in this component. The key is the member ID and
     * the value is the stored name for the component. */
    getMemberFieldMap() {
        return this.getField("memberFieldMap");
    }

    getParentComponent(modelManager) {
        let model = modelManager.getModel();
        let parent = this.getField("member").getParentMember(model);
        if(parent) {
            let componentId = modelManager.getComponentIdByMemberId(parent.getId());
            return modelManager.getComponentByComponentId(componentId);
        }
        else {
            return null;
        }
    }

    setViewStateCallback(viewStateCallback) {
        this.viewStateCallback = viewStateCallback;
    }

    getCachedViewState() {
        return this.cachedViewState;
    }

    //------------------
    // serialization
    //------------------

    /** This serializes the component. */
    toJson(modelManager) {
        var json = {};
        json.type = this.constructor.uniqueName;

        //TO DO 

        if(this.displayState) {
            json.displayState = this.displayState;
        }
        
        //allow the specific component implementation to write to the json
        if(this.writeToJson) {
            this.writeToJson(json,modelManager);
        }

        if(this.viewStateCallback) {
            this.cachedViewState = this.viewStateCallback();
            if(this.cachedViewState) json.viewState = this.cachedViewState;
        }
        
        return json;
    }

    /** This is used to deserialize the component. */
    loadStoredData(json) {
        if(!json) json = {};
        
        //take any immediate needed actions
        
        //set the tree state
        if(json.viewState !== undefined) {
            this.cachedViewState = json.viewState;
        }
        
        //allow the component implemnetation ro read from the json
        if(this.readDataFromJson) {
            this.readDataFromJson(json);
        }

        //allow the component implemnetation ro read from the json
        if(this.readPropsFromJson) {
            this.readPropsFromJson(json);
        }
    }

    /** This is used to update properties, such as from the set properties form. */
    loadPropertyValues(json) {     
        if(this.readPropsFromJson) {
            this.readPropsFromJson(json);
        }
    }
    //==============================
    // Protected Instance Methods
    //==============================

    //This method should optionally be populated by an extending object.
    //** This method reads any necessary component implementation-specific stored data
    // * from the json. This should be used for stored data that is NOT updated when properties are updated. OPTIONAL */
    //readDataFromJson(json);

    //This method should optionally be populated by an extending object.
    //** This method reads any necessary component implementation-specific properties data
    // * from the json. This is also use when updating properties. OPTIONAL */
    //readPropsFromJson(json);

    //This method should optionally be populated by an extending object.
    //** This method writes any necessary component implementation-specific data
    // * to the json. OPTIONAL */
    //writeToJson(json,modelManager);

    /** This method cleans up after a delete. Any extending object that has delete
     * actions should pass a callback function to the method "addClenaupAction" */
    onDelete() {
        
        //execute cleanup actions
        for(var i = 0; i < this.cleanupActions.length; i++) {
            this.cleanupActions[i].call(this);
        }
    }

    /** This method extends the member udpated function from the base.
     * @protected */    
    memberUpdated(updatedMember) {
        let memberFieldMap = this.getField("memberFieldMap");
        let fieldName = memberFieldMap[updatedMember.getId()];

        //legacy case of old member registartion
        if(!fieldName) {
            fieldName = "member." + updatedMember.getName();
        }

        this.setField(fieldName,updatedMember);
    }

    /** This method is used for setting initial values in the property dialog. 
     * If there are additional property lines, in the generator, this method should
     * be extended to give the values of those properties too. */
    getPropertyValues() {
        
        var member = this.getField("member");
        
        var values = {};
        values.name = member.getName();
        values.parentId = member.getParentId();

        if(member.constructor.generator.readProperties) {
            member.constructor.generator.readProperties(member,values);
        }
        if(this.readExtendedProperties) {
            this.readExtendedProperties(values);
        }
        return values;
    }


    /** This function should be used to register child members in the case of compound components. This
     * will register the member with the modelManager and ensure update flags are properly handled. */
    registerMember(modelManager,childMember,fieldName,isMainMember) {
        this.setField(fieldName,childMember);
        modelManager.registerMember(childMember.getId(),this,isMainMember);

        //update childFieldMap
        let oldMemberFieldMap = this.getField("memberFieldMap");
        let memberFieldMap = {};
        Object.assign(memberFieldMap,oldMemberFieldMap);
        memberFieldMap[childMember.getId()] = fieldName;
        this.setField("memberFieldMap",memberFieldMap);
    }

    //======================================
    // Static methods
    //======================================

    /** This function creates a json to create the member for a new component instance. 
     * It uses default values and then overwrites in with optionalBaseValues (these are intended to be base values outside of user input values)
     * and then optionalOverrideValues (these are intended to be user input values) */
    static createMemberJson(componentClass,optionalInputProperties,optionalBaseValues) {
        var json = apogeeutil$1.jsonCopy(componentClass.DEFAULT_MEMBER_JSON);
        if(optionalBaseValues) {
            for(var key in optionalBaseValues) {
                json[key]= optionalBaseValues[key];
            }
        }
        if(optionalInputProperties) {
            //add the base component values
            if(optionalInputProperties.name !== undefined) json.name = optionalInputProperties.name;
            
            //add the specific member properties for this component type
            if(componentClass.transferMemberProperties) {
                componentClass.transferMemberProperties(optionalInputProperties,json);
            }
        }
        
        return json;
    }

    /** This function merges values from two objects containing component property values. */
    static createComponentJson(componentClass,optionalInputProperties,optionalBaseValues) {
        //copy the base properties
        var newPropertyValues = optionalBaseValues ? apogeeutil$1.jsonCopy(optionalBaseValues) : {};
        
        //set the type
        newPropertyValues.type = componentClass.uniqueName;
        
        //add in the input property Value
        if((optionalInputProperties)&&(componentClass.transferComponentProperties)) {
            componentClass.transferComponentProperties(optionalInputProperties,newPropertyValues);
        }
        
        return newPropertyValues;
    }
}

//======================================
// All components should have a generator to create the component
// from a json. See existing components for examples.
//======================================

/** This component represents a json table object. */
class JsonTableComponent extends Component {
    
        
    constructor(member,modelManager,instanceToCopy,keepUpdatedFixed) {
        //extend edit component
        super(member,modelManager,instanceToCopy,keepUpdatedFixed);

        //==============
        //Fields
        //==============
        //Initailize these if this is a new instance
        if(!instanceToCopy) {
            //default view
            this.setField("dataView",JsonTableComponent.DEFAULT_DATA_VIEW);
        }
    };

    getDataView() {
        let dataView = this.getField("dataView");
        if(!dataView) dataView = JsonTableComponent.DEFAULT_DATA_VIEW;
        return dataView;
    }

    setDataView(dataView) {
        let oldDataView = this.getField("dataView");
        if(oldDataView != dataView) {
            this.setField("dataView",dataView);
        }
    }

    //==============================
    // serialization
    //==============================

    writeToJson(json,modelManager) {
        json.dataView = this.getDataView();
    }

    readPropsFromJson(json) {
        if(json.dataView !== undefined) {
            this.setDataView(json.dataView);
        }
    }

    //======================================
    // properties
    //======================================

    /** This returns the current values for the member and component properties in the  
     * proeprties dialog. */
    readExtendedProperties(values) {
        values.dataView = this.getDataView();
    }

    //======================================
    // Static methods
    //======================================

    /** This optional static function reads property input from the property 
     * dialog and copies it into a member property json. It is not needed for
     * this componnet. */
    //transferMemberProperties(inputValues,propertyJson) {
    //}

    /** This optional static function reads property input from the property 
     * dialog and copies it into a component property json. */
    static transferComponentProperties(inputValues,propertyJson) {
        if(inputValues.dataView !== undefined) {
            propertyJson.dataView = inputValues.dataView;
        }
    }
}

//======================================
// This is the component generator, to register the component
//======================================


/** This is the display name for the type of component */
JsonTableComponent.displayName = "Data Cell";
/** This is the univeral uniaue name for the component, used to deserialize the component. */
JsonTableComponent.uniqueName = "apogeeapp.JsonCell";

JsonTableComponent.DEFAULT_MEMBER_JSON = {
    "type": "apogee.JsonMember"
};

/** This component represents a table object. */
class FunctionComponent extends Component {

    constructor(member,modelManager,instanceToCopy,keepUpdatedFixed) {
        //extend edit component
        super(member,modelManager,instanceToCopy,keepUpdatedFixed);
    };

    /** This overrides the get title method of member to return the function declaration. */
    getDisplayName(useFullPath,modelManagerForFullPathOnly) {
        var name = useFullPath ? this.getFullName(modelManagerForFullPathOnly) : this.getName();
        let member = this.getMember();
        var argList = member.getArgList();
        var argListString = argList.join(",");
        return name + "(" + argListString + ")";
    }

    /** This method returns true if the display name field is updated. This method exists because
     * display name is potentially a compound field and this is a systematic way to see if it has changed.
     * Components modifying the getDisplayName method should also update this method.
     * Note this method only applies when useFullPath = false. We currently don't implement a method to see
     * if the full name was updated. */
    isDisplayNameUpdated() {
        return this.getMember().areAnyFieldsUpdated(["name","argList"]);
    }

    static transferMemberProperties(inputValues,propertyJson) {
        if(inputValues.argListString != undefined) { 
            if(!propertyJson.updateData) propertyJson.updateData = {};
            propertyJson.updateData.argList = apogeeutil$1.parseStringArray(inputValues.argListString);
        }
    }
   
}

//======================================
// This is the component generator, to register the component
//======================================

FunctionComponent.displayName = "Function Cell";
FunctionComponent.uniqueName = "apogeeapp.FunctionCell";

FunctionComponent.DEFAULT_MEMBER_JSON = {
    "type": "apogee.FunctionMember"
};

// ::- Gap cursor selections are represented using this class. Its
// `$anchor` and `$head` properties both point at the cursor position.
class GapCursor extends prosemirrorState_es_js.Selection {
  // : (ResolvedPos)
  constructor($pos) {
    super($pos, $pos);
  }

  map(doc, mapping) {
    let $pos = doc.resolve(mapping.map(this.head));
    return GapCursor.valid($pos) ? new GapCursor($pos) : prosemirrorState_es_js.Selection.near($pos)
  }

  content() { return prosemirrorModel_es_js.Slice.empty }

  eq(other) {
    return other instanceof GapCursor && other.head == this.head
  }

  toJSON() {
    return {type: "gapcursor", pos: this.head}
  }

  static fromJSON(doc, json) {
    if (typeof json.pos != "number") throw new RangeError("Invalid input for GapCursor.fromJSON")
    return new GapCursor(doc.resolve(json.pos))
  }

  getBookmark() { return new GapBookmark(this.anchor) }

  static valid($pos) {
    let parent = $pos.parent;
    if (parent.isTextblock || !closedBefore($pos) || !closedAfter($pos)) return false
    let override = parent.type.spec.allowGapCursor;
    if (override != null) return override
    let deflt = parent.contentMatchAt($pos.index()).defaultType;
    return deflt && deflt.isTextblock
  }

  static findFrom($pos, dir, mustMove) {
    search: for (;;) {
      if (!mustMove && GapCursor.valid($pos)) return $pos
      let pos = $pos.pos, next = null;
      // Scan up from this position
      for (let d = $pos.depth;; d--) {
        let parent = $pos.node(d);
        if (dir > 0 ? $pos.indexAfter(d) < parent.childCount : $pos.index(d) > 0) {
          next = parent.child(dir > 0 ? $pos.indexAfter(d) : $pos.index(d) - 1);
          break
        } else if (d == 0) {
          return null
        }
        pos += dir;
        let $cur = $pos.doc.resolve(pos);
        if (GapCursor.valid($cur)) return $cur
      }

      // And then down into the next node
      for (;;) {
        let inside = dir > 0 ? next.firstChild : next.lastChild;
        if (!inside) {
          if (next.isAtom && !next.isText && !prosemirrorState_es_js.NodeSelection.isSelectable(next)) {
            $pos = $pos.doc.resolve(pos + next.nodeSize * dir);
            mustMove = false;
            continue search
          }
          break
        }
        next = inside;
        pos += dir;
        let $cur = $pos.doc.resolve(pos);
        if (GapCursor.valid($cur)) return $cur
      }

      return null
    }
  }
}

GapCursor.prototype.visible = false;

prosemirrorState_es_js.Selection.jsonID("gapcursor", GapCursor);

class GapBookmark {
  constructor(pos) {
    this.pos = pos;
  }
  map(mapping) {
    return new GapBookmark(mapping.map(this.pos))
  }
  resolve(doc) {
    let $pos = doc.resolve(this.pos);
    return GapCursor.valid($pos) ? new GapCursor($pos) : prosemirrorState_es_js.Selection.near($pos)
  }
}

function closedBefore($pos) {
  for (let d = $pos.depth; d >= 0; d--) {
    let index = $pos.index(d);
    // At the start of this parent, look at next one
    if (index == 0) continue
    // See if the node before (or its first ancestor) is closed
    for (let before = $pos.node(d).child(index - 1);; before = before.lastChild) {
      if ((before.childCount == 0 && !before.inlineContent) || before.isAtom || before.type.spec.isolating) return true
      if (before.inlineContent) return false
    }
  }
  // Hit start of document
  return true
}

function closedAfter($pos) {
  for (let d = $pos.depth; d >= 0; d--) {
    let index = $pos.indexAfter(d), parent = $pos.node(d);
    if (index == parent.childCount) continue
    for (let after = parent.child(index);; after = after.firstChild) {
      if ((after.childCount == 0 && !after.inlineContent) || after.isAtom || after.type.spec.isolating) return true
      if (after.inlineContent) return false
    }
  }
  return true
}

const handleKeyDown = prosemirrorKeymap_es_js.keydownHandler({
  "ArrowLeft": arrow("horiz", -1),
  "ArrowRight": arrow("horiz", 1),
  "ArrowUp": arrow("vert", -1),
  "ArrowDown": arrow("vert", 1)
});

function arrow(axis, dir) {
  let dirStr = axis == "vert" ? (dir > 0 ? "down" : "up") : (dir > 0 ? "right" : "left");
  return function(state, dispatch, view) {
    let sel = state.selection;
    let $start = dir > 0 ? sel.$to : sel.$from, mustMove = sel.empty;
    if (sel instanceof prosemirrorState_es_js.TextSelection) {
      if (!view.endOfTextblock(dirStr) || $start.depth == 0) return false
      mustMove = false;
      $start = state.doc.resolve(dir > 0 ? $start.after() : $start.before());
    }
    let $found = GapCursor.findFrom($start, dir, mustMove);
    if (!$found) return false
    if (dispatch) dispatch(state.tr.setSelection(new GapCursor($found)));
    return true
  }
}

/** Update Component Command
 *
 * Command JSON format:
 * {
 *   "type":"literatePageTransaction",
 *   "componentId":(component id),
 * 
 *   ============================
 *   == with initial commands 
 *   =============================
 *   "transaction":(the transaction - this is only passed on initial commands. Redo and undo commands do not have it and
 *          must reconstruct the transaction from the steps json),
  *  "initialSelection":(selection before command - only needed for commands that have undo/redo),
 *   "initialMarks":(marks before command - only needed for commands that have undo/redo),
 * 
 *   ============================
 *   == with redo/undo commands NOTE: we modify the command object to remove transaction and other initial data.
 *   == This is because of an impedence mismatch between apogee and prosemirror command structures.
 *   ============================
 *   "steps":(steps json - needed if transaction not present),
 *   "selection": (selection json - needed if transaction no present)
 *   "marks": (marks json - needed if transaction not present)
 * }
 */ 
let literatepagetransaction = {};

//=====================================
// Command Object
//=====================================

literatepagetransaction.createUndoCommand = function(workspaceManager,commandData) {

    let transaction = commandData.transaction;
    if(!transaction) return null;

    //no undo/redo if the document is not changed. This is just an editor state change
    if(!transaction.docChanged) return null;

    //if we do want to add to history we want to store the transaction as data, not objects
    //we will _modify_ the command passed in below, partially due to a slight mismatch between
    //prosemirror and apogee
    let stepsJson = [];
    let inverseStepsJson = [];
    for(let i = 0; i < transaction.steps.length; i++) {
        let step = transaction.steps[i];
        stepsJson.push(step.toJSON());
        let stepDoc = transaction.docs[i];
        let inverseStep = step.invert(stepDoc);
        //this is in the wrong order - we will reverse it below
        inverseStepsJson.push(inverseStep.toJSON()); 
    }

    //fix the order of inverse commands
    inverseStepsJson.reverse();

    //modify the command to save the raw data for he transaction
    commandData.steps = stepsJson;
    if(transaction.selection) commandData.selection = transaction.selection.toJSON();
    if(transaction.marks) commandData.marks = transaction.marks.map(mark => mark.toJSON());

    //create the undo commans
    let undoCommandData = {};
    undoCommandData.type = literatepagetransaction.commandInfo.type;
    undoCommandData.componentId = commandData.componentId;
    undoCommandData.steps = inverseStepsJson;
    if(commandData.initialSelection) undoCommandData.selection = commandData.initialSelection;
    if(commandData.initialMarks) undoCommandData.marks = commandData.initialMarks;

    return undoCommandData;

};


literatepagetransaction.executeCommand = function(workspaceManager,commandData) {
    let modelManager = workspaceManager.getMutableModelManager();
    let component = modelManager.getMutableComponentByComponentId(commandData.componentId);

    let oldEditorState = component.getEditorState();

    let transaction = commandData.transaction;
    //we do not want to store the transaction in history. See note above in create undo command.
    delete commandData.transaction;

    //if the transaction is not serialized, serilized it
    if(!transaction) {
        if(!commandData.steps) {
            console.log("Document transaction with no steps!");
            return;
        }
        let schema = oldEditorState.schema;

        transaction = oldEditorState.tr;
        commandData.steps.forEach( stepJSON => {
            transaction.step(prosemirrorTransform_es_js.Step.fromJSON(schema,stepJSON));
        });

        if(commandData.selection) {
            let selection = deserializeSelection(transaction.doc,commandData.selection);
            if(selection) transaction.setSelection(selection);
        }

        if(commandData.marks) {
            transaction.setStoredMarks(commandData.marks.map(markJson => Mark.fromJSON(schema,markJson)));
        }
    }

    let newEditorState = oldEditorState.apply(transaction);
    component.setEditorState(newEditorState);    
};

function deserializeSelection(doc,selectionJson) {
    if(selectionJson.type == "text") {
        return prosemirrorState_es_js.TextSelection.fromJSON(doc,selectionJson);
    }
    else if(selectionJson.type == "node") {
        return prosemirrorState_es_js.NodeSelection.fromJSON(doc,selectionJson);
    }
    else if(selectionJson.type == "gapcursor") {
        return GapCursor.fromJSON(doc,selectionJson);
    }
    else {
        return null;
    }
}

literatepagetransaction.commandInfo = {
    "type": "literatePageTransaction",
    "targetType": "component",
    "event": "updated"
};

CommandManager.registerCommand(literatepagetransaction);

// :: Schema
// This the schema for the apogee page editor
function createFolderSchema(app,pageMemberId) {

    // :: Object
    // [Specs](#model.NodeSpec) for the nodes defined in this schema.
    const nodes = {
        // :: NodeSpec The top level document node.
        doc: {
            content: "(block | list | workerParent | apogeeComponent)+"
        },

        // :: NodeSpec A plain paragraph textblock. Represented in the DOM
        // as a `<p>` element.
        paragraph: {
            content: "inline*",
            group: "block",
            parseDOM: [{ tag: "p" }],
            toDOM() { return ["p", 0] }
        },

        heading1: {
            content: "inline*",
            group: "block",
            defining: true,
            parseDOM: [{ tag: "h1" }],
            toDOM(node) { return ["h1", 0] }
        },

        heading2: {
            content: "inline*",
            group: "block",
            defining: true,
            parseDOM: [{ tag: "h2" }],
            toDOM(node) { return ["h2", 0] }
        },

        heading3: {
            content: "inline*",
            group: "block",
            defining: true,
            parseDOM: [{ tag: "h3" }],
            toDOM(node) { return ["h3", 0] }
        },

        heading4: {
            content: "inline*",
            group: "block",
            defining: true,
            parseDOM: [{ tag: "h4" }],
            toDOM(node) { return ["h4", 0] }
        },

        bulletList: {
            content: "listItem+",
            group: "list",
            defining: true,
            parseDOM: [{ tag: "ul" }],
            toDOM(node) { return ["ul", 0] }
        },

        numberedList: {
            content: "listItem+",
            group: "list",
            defining: true,
            parseDOM: [{ tag: "ol" }],
            toDOM(node) { return ["ol", 0] }
        },

        listItem: {
            content: "inline*",
            parseDOM: [{ tag: "li" }],
            toDOM() { return ["li", 0] }
        },

        //this is used only to legally transition between states.
        //there is probably a better way of doing this...
        workerParent: {
            content: "(block | listItem | list | apogeeComponent )+",
            parseDOM: [{ tag: "w-p" }],
            toDOM(node) { return ["w-p", 0] }
        },

        // :: NodeSpec The text node.
        text: {
            group: "inline"
        },
/*
        // :: NodeSpec An inline image (`<img>`) node. Supports `src`,
        // `alt`, and `href` attributes. The latter two default to the empty
        // string.
        image: {
            inline: true,
            attrs: {
                src: {},
                alt: { default: null },
                title: { default: null }
            },
            group: "inline",
            draggable: true,
            parseDOM: [{
                tag: "img[src]", getAttrs(dom) {
                    return {
                        src: dom.getAttribute("src"),
                        title: dom.getAttribute("title"),
                        alt: dom.getAttribute("alt")
                    }
                }
            }],
            toDOM(node) { let { src, alt, title } = node.attrs; return ["img", { src, alt, title }] }
        },
    */

        apogeeComponent: {
            marks: "",
            atom: true,
            selectable: true,

            //TEMP TEST////
            hasInteractiveSelection: true,
            ///////////////

            attrs: { 
                "name": { default: "" },
                "id": {default: 0}, //to be used later?
                "state": { default: "" } //this is only used for transient loading, then erased
            },
            toDOM: node => {
                let name = node.attrs.name;

                let modelManager = app.getWorkspaceManager().getModelManager();
                let model = modelManager.getModel();

                let pageMember = model.lookupMemberById(pageMemberId);
                let nodeMemberId = pageMember.lookupChildId(name);
                let nodeComponentId = modelManager.getComponentIdByMemberId(nodeMemberId);
                let nodeComponent = modelManager.getComponentByComponentId(nodeComponentId);
                let nodeMember = nodeComponent.getMember();

                let state = {};
                state.memberJson = nodeMember ? nodeMember.toJson(modelManager.getModel()) : undefined;
                state.componentJson = nodeComponent ? nodeComponent.toJson(modelManager) : undefined;

                return ["div", { "data-name":name, "data-state": JSON.stringify(state) }]
            },
            parseDOM: [{
                tag: "div[data-name]",
                getAttrs: (dom) => {
                    let name = dom.getAttribute("data-name");
                    let stateString = dom.getAttribute("data-state");
                    let state;
                    if(stateString) {
                        try {
                            state =    JSON.parse(stateString);
                        }
                        catch(error) {
                            //FIGURE OUT HOW TO HANDLE THIS ERROR!!!
                            console.log("Error parsing entered component: ") + name;
                            if(error.stack) console.error(error.stack);
                            state = undefined;
                        }
                    }
                    return { name, state };
                }
            }]
        }
    };

    // :: Object [Specs](#model.MarkSpec) for the marks in the schema.
    const marks = {
/*
        // :: MarkSpec A link. Has `href` and `title` attributes. `title`
        // defaults to the empty string. Rendered and parsed as an `<a>`
        // element.
        link: {
            attrs: {
                href: {},
                title: { default: null }
            },
            inclusive: false,
            parseDOM: [{
                tag: "a[href]", getAttrs(dom) {
                    return { href: dom.getAttribute("href"), title: dom.getAttribute("title") }
                }
            }],
            toDOM(node) { let { href, title } = node.attrs; return ["a", { href, title }, 0] }
        },
*/

        // :: MarkSpec An emphasis mark. Rendered as an `<em>` element.
        // Has parse rules that also match `<i>` and `font-style: italic`.
        italic: {
            parseDOM: [{ tag: "i" }, { tag: "em" }, { style: "font-style=italic" }],
            toDOM() { return ["em", 0] }
        },

        // :: MarkSpec A strong mark. Rendered as `<b>`, parse rules
        // also match `<strong>` and `font-weight: bold`.
        bold: {
            parseDOM: [{ tag: "strong" },
            // This works around a Google Docs misbehavior where
            // pasted content will be inexplicably wrapped in `<b>`
            // tags with a font-weight normal.
            { tag: "b", getAttrs: node => node.style.fontWeight != "normal" && null },
            { style: "font-weight", getAttrs: value => /^(bold(er)?|[5-9]\d{2,})$/.test(value) && null }],
            toDOM() { return ["b", 0] }
        },

        textcolor: {
            attrs: {
                color: { default: "black" }
            },
            parseDOM: [{
                tag: "clr-tag", style: "color", getAttrs(dom) {
                    return { color: dom.style.color };
                }
            }],
            toDOM(node) { return ["clr-tag", { "style": "color:" + node.attrs["color"] + ";" }, 0] }
        },

        fontsize: {
            attrs: {
                fontsize: { default: "" }
            },
            parseDOM: [{
                tag: "fntsz-tag", style: "font-size", getAttrs(dom) {
                    return { fontsize: dom.style["font-size"] };
                }
            }],
            toDOM(node) { return ["fntsz-tag", { "style": "font-size:" + node.attrs["fontsize"] + ";" }, 0] }
        },

        fontfamily: {
            attrs: {
                fontfamily: { default: "Sans-serif" }
            },
            parseDOM: [{
                tag: "fntfam-tag", style: "font-family", getAttrs(dom) {
                    return { fontsize: dom.style["font-family"] };
                }
            }],
            toDOM(node) { return ["fntfam-tag", { "style": "font-family:" + node.attrs.fontfamily + ";" }, 0] }
        },

        highlight: {
            attrs: {
                color: { default: "white" }
            },
            parseDOM: [{
                tag: "bgd-tag", style: "background-color", getAttrs(dom) {
                    return { "color": dom.style["background-color"] };
                }
            }],
            toDOM(node) { return ["bgd-tag", { "style": "background-color:" + node.attrs["color"] + ";" }, 0] }
        }

    };


    return new prosemirrorModel_es_js.Schema({ nodes, marks })
}

/** This method creates an editor state with no plugins and
 * default selection and marks.
 * If the editor view uses l=plugins, those must be added to the editor state.
 */
function createEditorState(schema, docJson) {
    let document = prosemirrorModel_es_js.Node.fromJSON(schema,docJson);
    let editorState = prosemirrorState_es_js.EditorState.create({
        doc: document
    });
    return editorState;
}

/** This method attaches plugins to the given editor state, returning
 * a new editor state. */
function attachPluginsToEditorState(editorState,plugins) {
    return editorState.reconfigure({plugins: plugins});
}

let EMPTY_DOC_JSON = {"type":"doc","content":[{"type":"paragraph"}]};

/** This is the base class for a parent component (an object that has children),
 * It extends the component class. */
class ParentComponent extends Component {

    constructor(member,modelManager,instanceToCopy,keepUpdatedFixed) {
        //base constructor
        super(member,modelManager,instanceToCopy,keepUpdatedFixed);

        //==============
        //Fields
        //==============
        //The following fields are added by the parent component. In order to add these, the method
        //"initializeSchema" must be called. See the notes on that method.
        //"schema"
        //"editorState"
    }

    getSchema() {
        return this.getField("schema");
    }

    /** This method sets the document. It also allows for temporarily storing some editor info 
     * to accompany a set document */
    setEditorState(editorState) {
        //for now set dummy data to show a change
        this.setField("editorState",editorState);
    }

    getEditorState() {
        return this.getField("editorState");
    }

    instantiateTabDisplay() {
        let member = this.getMember();
        let folder = this.getParentFolderForChildren();
        return new LiteratePageComponentDisplay(this,member,folder); 
    }

    /** This method should be called only when a new component is created, and not when it is copied. It creates the schema
     * and an initial empty document for the page. It should be called after the parent folder for the page children is initialized.
     * Preferebly it is called from the constructor, if there is not a reason to wait longer.. */
    initializeSchema(modelManager) {
        let pageFolderMember = this.getParentFolderForChildren();
        let schema = createFolderSchema(modelManager.getApp(),pageFolderMember.getId());
        this.setField("schema",schema);
        //initialize with an empty document
        let editorState = createEditorState(schema,EMPTY_DOC_JSON);
        this.setField("editorState",editorState);
    }

    //==============================
    // serialization
    //==============================

    /** This serializes the table component. */
    writeToJson(json,modelManager) {
        //save the editor state
        let editorState = this.getField("editorState");
        if(editorState) {
            let document = editorState.doc;
            json.data = {};
            json.data.doc = document.toJSON();
        }
        
        //save the children
        var folder = this.getParentFolderForChildren();
        var childrenPresent = false;
        var children = {};
        var childIdMap = folder.getChildIdMap();
        for(var key in childIdMap) {
            var childId = childIdMap[key];
            var childComponentId = modelManager.getComponentIdByMemberId(childId);
            var childComponent = modelManager.getComponentByComponentId(childComponentId);
            var name = childComponent.getName();
            children[name] = childComponent.toJson(modelManager);
            childrenPresent = true;
        }
        if(childrenPresent) {
            json.children = children;
        }

        return json;
    }

    readDataFromJson(json) {
        let editorState;
        let docJson;
        //read the editor state
        if((json.data)&&(json.data.doc)) {
            //parse the saved document
            docJson = json.data.doc;
        }
        else {
            //no document stored - create an empty document
            docJson = EMPTY_DOC_JSON;
        }
        editorState = createEditorState(this.getSchema(),docJson);
        this.setField("editorState",editorState);
    }

    /** This method loads the children for this component */
    loadChildrenFromJson(modelManager,componentJson) {
        if(componentJson.children) {
            let parentMember = this.getParentFolderForChildren();
            
            for(let childName in componentJson.children) {
                let childMember = parentMember.lookupChild(modelManager.getModel(),childName);
                if(childMember) {
                    let childComponentJson = componentJson.children[childName];
                    modelManager.createComponentFromMember(childMember,childComponentJson);
                }
            }
        }
    }

}

/** This is used to flag this as an edit component. */
ParentComponent.isParentComponent = true;

/** This component represents a table object. */
class FolderComponent extends ParentComponent {

    constructor(member,modelManager,instanceToCopy,keepUpdatedFixed) {
        //extend parent component
        super(member,modelManager,instanceToCopy,keepUpdatedFixed);

        if(!instanceToCopy) {
            //initialize the schema
            this.initializeSchema(modelManager);
        }
    };

    //cludge================================================
    //I need a real solution for this
    //this is a temp solution to return the parent member for children added to this componnet
    //it is used for now when we paste into the document to create a new component.
    getParentFolderForChildren() {
        return this.getMember();
    }
    //=======================================================

    //======================================
    // Static methods
    //======================================

    //if we want to allow importing a workspace as this object, we must add this method to the generator
    static appendMemberChildren(optionsJson,childrenJson) {
        optionsJson.children = childrenJson;
    }

}

//======================================
// This is the component generator, to register the component
//======================================

FolderComponent.displayName = "Page";
FolderComponent.uniqueName = "apogeeapp.PageComponent";
FolderComponent.DEFAULT_MEMBER_JSON = {
    "type": "apogee.Folder"
};

/** This component represents a folderFunction, which is a function that is programmed using
 *apogee tables rather than writing code. */
class FolderFunctionComponent extends ParentComponent {
        
    constructor(member,modelManager,instanceToCopy,keepUpdatedFixed) {
        //extend parent component
        super(member,modelManager,instanceToCopy,keepUpdatedFixed);
        
        //==============
        //Fields
        //==============
        //Initailize these if this is a new instance
        if(!instanceToCopy) {
            //register this object as a parent container
            var internalFolder = member.getInternalFolder(modelManager.getModel());
            this.registerMember(modelManager,internalFolder,"member.body",false);

            //initialize the schema
            this.initializeSchema(modelManager);
        }
    }

    /** This overrides the get display method of componnet to return the function declaration. */
    getDisplayName(useFullPath,modelManagerForFullPathOnly) {
        let member = this.getMember();
        var name = useFullPath ? this.getFullName(modelManagerForFullPathOnly) : this.getName();
        var argList = member.getArgList();
        var argListString = argList.join(",");
        var returnValueString = member.getReturnValueString();
        
        var displayName = name + "(" + argListString + ")";
        if((returnValueString != null)&&(returnValueString.length > 0)) {
            displayName += " = " + returnValueString;
        }
        
        return displayName;
    }

    /** This method returns true if the display name field is updated. This method exists because
     * display name is potentially a compound field and this is a systematic way to see if it has changed.
     * Components modifying the getDisplayName method should also update this method.
     * Note this method only applies when useFullPath = false. We currently don't implement a method to see
     * if the full name was updated. */
    isDisplayNameUpdated() {
        return this.getMember().areAnyFieldsUpdated(["name","argList","returnValue"]);
    }

    //cludge================================================
    //I need a real solution for this
    //this is a temp solution to return the parent member for children added to this componnet
    //it is used for now when we paste into the document to create a new component.
    getParentFolderForChildren() {
        //use the internal folder
        return this.getField("member.body");
    }
    //=======================================================


    static transferMemberProperties(inputValues,propertyJson) {
        if(!propertyJson.updateData) propertyJson.updateData = {};
        if(inputValues.argListString !== undefined) {
            propertyJson.updateData.argList = apogeeutil$1.parseStringArray(inputValues.argListString);
        }
        if(inputValues.returnValueString !== undefined) {
            propertyJson.updateData.returnValue = inputValues.returnValueString;
        }
    }

    //if we want to allow importing a workspace as this object, we must add this method to the generator
    static appendMemberChildren(optionsJson,childrenJson) {
        var internalFolderJson = {};
        internalFolderJson.name = optionsJson.name;
        internalFolderJson.type = "apogee.Folder";
        internalFolderJson.children = childrenJson;
        
        optionsJson = {};
        optionsJson.children["body"] = internalFolderJson;
    }

    static appendMemberChildren(optionsJson,childrenJson) {
        optionsJson.children = childrenJson;
    }

}

//======================================
// This is the component generator, to register the component
//======================================

FolderFunctionComponent.displayName = "Multi-Cell Function";
FolderFunctionComponent.uniqueName = "apogeeapp.PageFunctionComponent";
FolderFunctionComponent.DEFAULT_MEMBER_JSON = {
    "type": "apogee.FolderFunction",
    "children": {
        "body": {
            "name": "body",
            "type": "apogee.Folder",
        }
    }
};

/** This component represents a table object. */
class DynamicForm extends Component {
        
    constructor(member,modelManager,instanceToCopy,keepUpdatedFixed) {
        //extend edit component
        super(member,modelManager,instanceToCopy,keepUpdatedFixed);
    };

}

//======================================
// This is the component generator, to register the component
//======================================

DynamicForm.displayName = "Form Cell - Action";
DynamicForm.uniqueName = "apogeeapp.ActionFormCell";
DynamicForm.DEFAULT_MEMBER_JSON = {
    "type": "apogee.FunctionMember",
    "updateData": {
        "argList": ["admin"]
    }
};

/** This ccomponent represents a data value, with input being from a configurable form.
 * This is an example of componound component. The data associated with the form
 * can be accessed from the variables (componentName).data. There are also subtables
 * "layout" which contains the form layout and "isInputValid" which is a function
 * to validate form input.
 * If you want a form to take an action on submit rather than create and edit a 
 * data value, you can use the dynmaic form. */
class FormDataComponent extends Component {

    constructor(member,modelManager,instanceToCopy,keepUpdatedFixed) {
        //extend edit component
        super(member,modelManager,instanceToCopy,keepUpdatedFixed);
        
        //this should be present in the json that builds the folder, but in case it isn't (for one, because of a previous mistake)
        member.setChildrenWriteable(false);
        
        let model = modelManager.getModel();
        //==============
        //Fields
        //==============
        //Initailize these if this is a new instance
        if(!instanceToCopy) {
            //internal tables
            let dataMember = member.lookupChild(model,"data");
            this.registerMember(modelManager,dataMember,"member.data",false);

            let layoutFunctionMember = member.lookupChild(model,"layout");
            this.registerMember(modelManager,layoutFunctionMember,"member.layout",false);

            let isInputValidFunctionMember = member.lookupChild(model,"isInputValid");
            this.registerMember(modelManager,isInputValidFunctionMember,"member.isInputValid",false);
        }
    };

}

//======================================
// This is the component generator, to register the component
//======================================

FormDataComponent.displayName = "Form Cell - Data";
FormDataComponent.uniqueName = "apogeeapp.DataFormCell";
FormDataComponent.DEFAULT_MEMBER_JSON = {
        "type": "apogee.Folder",
        "childrenNotWriteable": true,
        "children": {
            "layout": {
                "name": "layout",
                "type": "apogee.FunctionMember",
                "updateData": {
                    "argList":[],
                }
            },
            "data": {
                "name": "data",
                "type": "apogee.JsonMember",
                "updateData": {
                    "data": "",
                }
            },
            "isInputValid": {
                "name": "isInputValid",
                "type": "apogee.FunctionMember",
                "updateData": {
                    "argList":["formValue"],
                    "functionBody": "//If data valid, return true. If data is invalid, return an error message.\nreturn true;"
                }
            }
        }
    };

/** This is a custom resource component. 
 * To implement it, the resource script must have the methods "run()" which will
 * be called when the component is updated. It also must have any methods that are
 * confugred with initialization data from the model. */
class CustomComponent extends Component {

    constructor(member,modelManager,instanceToCopy,keepUpdatedFixed) {
        super(member,modelManager,instanceToCopy,keepUpdatedFixed);
        
        //==============
        //Fields
        //==============
        //Initailize these if this is a new instance
        if(!instanceToCopy) {
            this.setField("destroyOnInactive",false); //default to keep alive
            this.setField("html","");
            this.setField("css","");
            this.setField("uiCode","");
        }
    };

    //==============================
    //Resource Accessors
    //==============================

    getDestroyOnInactive() {
        return this.getField("destroyOnInactive");
    }

    setDestroyOnInactive(destroyOnInactive) {
        if(destroyOnInactive != this.destroyOnInactive) {
            this.setField("destroyOnInactive",destroyOnInactive);
        }
    }

    /** This method deseriliazes data for the custom resource component. This will
     * work is no json is passed in. */
    loadResourceFromJson(json) { 
        if((json)&&(json.resource)) {  
            for(let fieldName in json.resource) {
                this.update(fieldName,json.resource[fieldName]);
            }
        }
    }


    /** This method creates the resource. */
    createResource() {
        var uiGeneratorBody = this.getField("uiCode");
        
        var resource;
        if((uiGeneratorBody)&&(uiGeneratorBody.length > 0)) {
            //compile the user code for the generator
            var generatorFunction;
            try {
                generatorFunction = new Function(uiGeneratorBody);
            }
            catch(error) {
                resource = {
                    displayInvalid: true,
                    message: "Error parsing uiGenerator code: " + error.toString()
                };
                if(error.stack) console.error(error.stack);
                generatorFunction = null;
            }

            //execute the generator function
            if(generatorFunction) {
                try {
                    resource = generatorFunction();
                }
                catch(error) {
                    resource = {
                        displayInvalid: true,
                        message: "Error executing uiGenerator code: " + error.toString()
                    };
                    if(error.stack) console.error(error.stack);
                }
            }
        }
        else {
            //generator not yet present
            resource = {};
        }

        return resource;
    }


    //=============================
    // Action
    //=============================

    doCodeFieldUpdate(app,codeFieldName,targetValue) { 
        let initialValue = this.getField(codeFieldName);

        var command = {};
        command.type = customComponentUpdateData.commandInfo.type;
        command.memberId = this.getMemberId();
        command.fieldName = codeFieldName;
        command.initialValue = initialValue;
        command.targetValue = targetValue;

        app.executeCommand(command);
        return true;  
    }

    update(fieldName,fieldValue) { 

        let oldFieldValue = this.getField(fieldName);
        if(fieldValue != oldFieldValue) {
            this.setField(fieldName,fieldValue);
        }

    }

    //==============================
    // serialization
    //==============================

    readPropsFromJson(json) {
        if(!json) return;
        
        //set destroy flag
        if(json.destroyOnInactive !== undefined) {
            var destroyOnInactive = json.destroyOnInactive;
            this.setDestroyOnInactive(destroyOnInactive);
        }
        
        //load the resource
        this.loadResourceFromJson(json);
    }

    /** This serializes the table component. */
    writeToJson(json,modelManager) {
        //store the resource info
        json.resource = {};
        json.resource["html"] = this.getField("html");
        json.resource["css"] = this.getField("css");
        json.resource["uiCode"] = this.getField("uiCode");
        json.destroyOnInactive = this.getField("destroyOnInactive");
    }

    //======================================
    // properties
    //======================================

    readExtendedProperties(values) {
        values.destroyOnInactive = this.getDestroyOnInactive();
    }

    //======================================
    // Static methods
    //======================================

    static transferComponentProperties(inputValues,propertyJson) {
        if(inputValues.destroyOnInactive !== undefined) {
            propertyJson.destroyOnInactive = inputValues.destroyOnInactive;
        }
    }
}

//======================================
// This is the control generator, to register the control
//======================================

CustomComponent.displayName = "Custom Cell";
CustomComponent.uniqueName = "apogeeapp.CustomCell";
CustomComponent.DEFAULT_MEMBER_JSON = {
    "type": "apogee.JsonMember"
};

//=====================================
// Update Data Command
//=====================================

/*
 *
 * Command JSON format:
 * {
 *   "type":"customComponentUpdateCommand",
 *   "memberId":(main member ID),
 *   "fieldName": (the name of the field being updated),
 *   "initialValue":(original fields value)
 *   "targetValue": (desired fields value)
 * }
 */ 
let customComponentUpdateData = {};

customComponentUpdateData.createUndoCommand = function(workspaceManager,commandData) {
    let undoCommandData = {};
    undoCommandData.memberId = commandData.memberId;
    undoCommandData.fieldName = commandData.fieldName;
    undoCommandData.initialValue = commandData.targetValue;
    undoCommandData.targetValue = commandData.initialValue;
    return undoCommandData;
};

customComponentUpdateData.executeCommand = function(workspaceManager,commandData) {
    let modelManager = workspaceManager.getMutableModelManager();
    let componentId = modelManager.getComponentIdByMemberId(commandData.memberId);
    let component = modelManager.getMutableComponentByComponentId(componentId);
    var commandResult = {};
    if(component) {
        try {
            component.update(commandData.fieldName,commandData.targetValue);

            commandResult.cmdDone = true;
            commandResult.target = component;
            commandResult.eventAction = "updated";
        }
        catch(error) {
            if(error.stack) console.error(error.stack);
            let msg = error.message ? error.message : error;
            commandResult.cmdDone = false;
            commandResult.alertMsg = "Exception on custom component update: " + msg;
        }
    }
    else {
        commandResult.cmdDone = false;
        commandResult.alertMsg = "Component not found: " + commandData.memberId;
    }
    
    return commandResult;
};

customComponentUpdateData.commandInfo = {
    "type": "customComponentUpdateCommand",
    "targetType": "component",
    "event": "updated"
};

CommandManager.registerCommand(customComponentUpdateData);

/** This attempt has a single form edit page which returns an object. */
// To add - I should make it so it does not call set data until after it is initialized. I will cache it rather 
//than making the user do that.

/** This is a custom resource component. 
 * To implement it, the resource script must have the methods "run()" which will
 * be called when the component is updated. It also must have any methods that are
 * confugred with initialization data from the model. */
class CustomDataComponent extends Component {

    constructor(member,modelManager,instanceToCopy,keepUpdatedFixed) {
        //extend edit component
        super(member,modelManager,instanceToCopy,keepUpdatedFixed);
        
        //this should be present in the json that builds the folder, but in case it isn't (for one, because of a previous mistake)
        member.setChildrenWriteable(false);

        let model = modelManager.getModel();
        //==============
        //Fields
        //==============
        //Initailize these if this is a new instance
        if(!instanceToCopy) {
            //internal tables
            let dataMember = member.lookupChild(model,"data");
            this.registerMember(modelManager,dataMember,"member.data",false);

            let inputMember = member.lookupChild(model,"input");
            this.registerMember(modelManager,inputMember,"member.input",false);

            this.setField("destroyOnInactive",false); //default to keep alive
            this.setField("html","");
            this.setField("css","");
            this.setField("uiCode","");
        }
    };

    //==============================
    //Resource Accessors
    //==============================

    getDestroyOnInactive() {
        return this.getField("destroyOnInactive");
    }

    setDestroyOnInactive(destroyOnInactive) {
        if(destroyOnInactive != this.getField("destroyOnInactive")) {
            this.setField("destroyOnInactive",destroyOnInactive);
        }
    }

    /** This method deseriliazes data for the custom resource component. This will
     * work is no json is passed in. */
    loadResourceFromJson(json) { 
        if((json)&&(json.resource)) {  
            for(let fieldName in json.resource) {
                this.update(fieldName,json.resource[fieldName]);
            }
        }
    }

    createResource() {
        var uiGeneratorBody = this.getField("uiCode");
        
        var resource;
        if((uiGeneratorBody)&&(uiGeneratorBody.length > 0)) {
            //compile the user code for the generator
            var generatorFunction;
            try {
                generatorFunction = new Function(uiGeneratorBody);
            }
            catch(error) {
                resource = {
                    displayInvalid: true,
                    message: "Error parsing uiGenerator code: " + error.toString()
                };
                if(error.stack) console.error(error.stack);
                generatorFunction = null;
            }

            //execute the generator function
            if(generatorFunction) {
                try {
                    resource = generatorFunction();
                }
                catch(error) {
                    resource = {
                        displayInvalid: true,
                        message: "Error executing uiGenerator code: " + error.toString()
                    };
                    if(error.stack) console.error(error.stack);
                }
            }
        }
        else {
            //generator not yet present
            resource = {};
        }

        return resource;
    }

    //=============================
    // Action
    //=============================

    doCodeFieldUpdate(app,fieldName,targetValue) { 
        var initialValue = this.getField(fieldName);
        var command = {};
        command.type = customDataComponentUpdateData.commandInfo.type;
        command.memberId = this.getMemberId();
        command.fieldName = fieldName;
        command.initialValue = initialValue;
        command.targetValue = targetValue;

        app.executeCommand(command);
        return true; 
    }

    update(fieldName,fieldValue) { 

        let oldFieldValue = this.getField(fieldName);
        if(fieldValue != oldFieldValue) {
            this.setField(fieldName,fieldValue);
        }
    }

    //==============================
    // serialization
    //==============================

    readPropsFromJson(json) {
        if(!json) return;
        
        //set destroy flag
        if(json.destroyOnInactive !== undefined) {
            var destroyOnInactive = json.destroyOnInactive;
            this.setDestroyOnInactive(destroyOnInactive);
        }
        
        //load the resource
        this.loadResourceFromJson(json);
    }

    /** This serializes the table component. */
    writeToJson(json,modelManager) {
        //store the resource info
        json.resource = {};
        json.resource["html"] = this.getField("html");
        json.resource["css"] = this.getField("css");
        json.resource["uiCode"] = this.getField("uiCode");
        json.destroyOnInactive = this.getField("destroyOnInactive");
    }

    //======================================
    // properties
    //======================================

    readExtendedProperties(values) {
        values.destroyOnInactive = this.getDestroyOnInactive();
    }



    //======================================
    // Static methods
    //======================================

    static transferComponentProperties(inputValues,propertyJson) {
        if(inputValues.destroyOnInactive !== undefined) {
            propertyJson.destroyOnInactive = inputValues.destroyOnInactive;
        }
    }
    
}

//======================================
// This is the control generator, to register the control
//======================================

CustomDataComponent.displayName = "Custom Data Cell";
CustomDataComponent.uniqueName = "apogeeapp.CustomDataCell";
CustomDataComponent.DEFAULT_MEMBER_JSON = {
        "type": "apogee.Folder",
        "childrenNotWriteable": true,
        "children": {
            "input": {
                "name": "input",
                "type": "apogee.JsonMember",
                "updateData": {
                    "data":"",
                }
            },
            "data": {
                "name": "data",
                "type": "apogee.JsonMember",
                "updateData": {
                    "data": "",
                }
            }
        }
    };



//=====================================
// Update Data Command
//=====================================

/*
 *
 * Command JSON format:
 * {
 *   "type":"customComponentUpdateCommand",
 *   "memberId":(main member ID),
 *   "fieldName": (the name of the field being updated),
 *   "initialValue":(original fields value)
 *   "targetValue": (desired fields value)
 * }
 */ 

let customDataComponentUpdateData = {};

customDataComponentUpdateData.createUndoCommand = function(workspaceManager,commandData) {
    let undoCommandData = {};
    undoCommandData.memberId = commandData.memberId;
    undoCommandData.fieldName = commandData.fieldName;
    undoCommandData.initialValue = commandData.targetValue;
    undoCommandData.targetValue = commandData.initialValue;
    return undoCommandData;
};

customDataComponentUpdateData.executeCommand = function(workspaceManager,commandData) {
    let modelManager = workspaceManager.getMutableModelManager();
    let componentId = modelManager.getComponentIdByMemberId(commandData.memberId);
    let component = modelManager.getMutableComponentByComponentId(componentId);
    var commandResult = {};
    if(component) {
        try {
            component.update(commandData.fieldName,commandData.targetValue);

            commandResult.cmdDone = true;
            commandResult.target = component;
            commandResult.eventAction = "updated";
        }
        catch(error) {
            if(error.stack) console.error(error.stack);
            let msg = error.message ? error.message : error;
            commandResult.cmdDone = false;
            commandResult.alertMsg = "Exception on custom component update: " + msg;
        }
    }
    else {
        commandResult.cmdDone = false;
        commandResult.alertMsg = "Component not found: " + commandData.memberId;
    }
    
    return commandResult;
};

customDataComponentUpdateData.commandInfo = {
    "type": "customDataComponentUpdateCommand",
    "targetType": "component",
    "event": "updated"
};

CommandManager.registerCommand(customDataComponentUpdateData);

/** This component represents a json table object. */
class ErrorComponent extends Component {

    constructor(member,modelManager,instanceToCopy,keepUpdatedFixed) {
        //extend edit component
        super(member,modelManager,instanceToCopy,keepUpdatedFixed);
    };

    //==============================
    // Protected and Private Instance Methods
    //==============================

    /** This overrides the save method to return the original input. */
    toJson(modelManager) {
        return this.getField("completeJson");
    }

    /** This overrides the open deserialize method to save the entire json. */
    loadStoredData(json) {
        this.setField("completeJson",json);
    }

    //======================================
    // Static methods
    //======================================

}

//======================================
// This is the component generator, to register the component
//======================================

ErrorComponent.displayName = "Error Cell";
ErrorComponent.uniqueName = "apogeeapp.ErrorCell";
ErrorComponent.DEFAULT_MEMBER_JSON = {
    "type": "apogee.ErrorMember"
};

/** This is a custom resource component. 
 * To implement it, the resource script must have the methods "run()" which will
 * be called when the component is updated. It also must have any methods that are
 * confugred with initialization data from the model. */
class ActionFormComponent extends Component {

    constructor(member,modelManager,instanceToCopy,keepUpdatedFixed) {
        super(member,modelManager,instanceToCopy,keepUpdatedFixed);
        
        //==============
        //Fields
        //==============
        //Initailize these if this is a new instance
        if(!instanceToCopy) {
            this.setField("layoutCode","return []");
        }
    };

    //==============================
    //Resource Accessors
    //==============================

    /** This method compiles the layout function entered by the user. It returns
     * the fields  {formLayoutFunction,errorMessage}. */
    createFormLayoutFunction() {
        var formCodeText = this.getField("layoutCode");
        
        var formLayoutFunction;
        var errorMessage;
        if((formCodeText !== undefined)&&(formCodeText !== null)) {
            try {
                //create the layout function
                formLayoutFunction = new Function("commandMessenger","inputData",formCodeText);
            }
            catch(error) {
                errorMessage = "Error parsing uiGenerator code: " + error.toString();
                if(error.stack) console.error(error.stack);
            }
        }
        else {
            formLayoutFunction = () => [];
        }
        
        return {formLayoutFunction,errorMessage}
    }


    //=============================
    // Action
    //=============================

    updateLayoutCode(layoutCodeText) { 
        let oldLayoutCodeText = this.getField("layoutCode");
        if(layoutCodeText != oldLayoutCodeText) {
            this.setField("layoutCode",layoutCodeText);
        }

    }

    //==============================
    // serialization
    //==============================

    readPropsFromJson(json) {
        if(!json) return;
        
        //load the resource
        if(json.layoutCode) { 
            this.updateLayoutCode(json.layoutCode); 
        }
    }

    /** This serializes the table component. */
    writeToJson(json,modelManager) {
        //store the for code text
        json.layoutCode = this.getField("layoutCode");
    }

}

//======================================
// This is the control generator, to register the control
//======================================

ActionFormComponent.displayName = "New Action Form Cell";
ActionFormComponent.uniqueName = "apogeeapp.NewActionFormCell";
ActionFormComponent.DEFAULT_MEMBER_JSON = {
    "type": "apogee.JsonMember"
};

//=====================================
// Update Data Command
//=====================================

/*
 *
 * Command JSON format:
 * {
 *   "type":"actionFormComponentUpdateCommand",
 *   "memberId":(main member ID),
 *   "initialValue":(original fields value)
 *   "targetValue": (desired fields value)
 * }
 */ 
let actionFormUpdateCommand = {};

actionFormUpdateCommand.createUndoCommand = function(workspaceManager,commandData) {
    let undoCommandData = {};
    undoCommandData.type = actionFormUpdateCommand.commandInfo.type;
    undoCommandData.memberId = commandData.memberId;
    undoCommandData.initialValue = commandData.targetValue;
    undoCommandData.targetValue = commandData.initialValue;
    return undoCommandData;
};

actionFormUpdateCommand.executeCommand = function(workspaceManager,commandData) {
    let modelManager = workspaceManager.getMutableModelManager();
    let componentId = modelManager.getComponentIdByMemberId(commandData.memberId);
    let component = modelManager.getMutableComponentByComponentId(componentId);
    var commandResult = {};
    if(component) {
        try {
            component.updateLayoutCode(commandData.targetValue);

            commandResult.cmdDone = true;
            commandResult.target = component;
            commandResult.eventAction = "updated";
        }
        catch(error) {
            if(error.stack) console.error(error.stack);
            let msg = error.message ? error.message : error;
            commandResult.cmdDone = false;
            commandResult.alertMsg = "Exception on custom component update: " + msg;
        }
    }
    else {
        commandResult.cmdDone = false;
        commandResult.alertMsg = "Component not found: " + commandData.memberId;
    }
    
    return commandResult;
};

actionFormUpdateCommand.commandInfo = {
    "type": "actionFormUpdateCommand",
    "targetType": "component",
    "event": "updated"
};

CommandManager.registerCommand(actionFormUpdateCommand);

/** This is a custom resource component. 
 * To implement it, the resource script must have the methods "run()" which will
 * be called when the component is updated. It also must have any methods that are
 * confugred with initialization data from the model. */
class DataFormComponent extends Component {

    constructor(member,modelManager,instanceToCopy,keepUpdatedFixed) {
        super(member,modelManager,instanceToCopy,keepUpdatedFixed);

        //this should be present in the json that builds the folder, but in case it isn't (for one, because of a previous mistake)
        member.setChildrenWriteable(false);
        
        let model = modelManager.getModel();
        //==============
        //Fields
        //==============
        //Initailize these if this is a new instance
        if(!instanceToCopy) {
            this.setField("layoutCode","return []");
            this.setField("validatorCode","return true");

            //internal tables
            let valueMember = member.lookupChild(model,"value");
            this.registerMember(modelManager,valueMember,"member.value",false);

            let inputMember = member.lookupChild(model,"input");
            this.registerMember(modelManager,inputMember,"member.input",false);
        }
    };

    //==============================
    //Resource Accessors
    //==============================

    /** This method compiles the layout function entered by the user. It returns
     * the fields  {formLayoutFunction,validatorFunction,errorMessage}. */
    createFormFunctions() {
        var layoutCodeText = this.getField("layoutCode");
        var validatorCodeText = this.getField("validatorCode");
        var layoutFunction, validatorFunction, errorMessage;

        if((layoutCodeText !== undefined)&&(layoutCodeText !== null)) {
            try {
                //create the layout function
                layoutFunction = new Function("commandMessenger","inputData",layoutCodeText);
            }
            catch(error) {
                errorMessage = "Error parsing layout function code: " + error.toString();
                if(error.stack) console.error(error.stack);
            }
        }
        else {
            layoutFunction = () => [];
        }

        if((validatorCodeText !== undefined)&&(validatorCodeText !== null))  {
            try {
                //create the validator function
                validatorFunction = new Function("formValue","inputData",validatorCodeText);
            }
            catch(error) {
                errorMessage = "Error parsing validator function code: " + error.toString();
                if(error.stack) console.error(error.stack);
            }
        }
        else {
            validatorFunction = () => true;
        }

        return { layoutFunction, validatorFunction, errorMessage};
    }

    //=============================
    // Action
    //=============================

    updateLayoutCode(layoutCodeText) { 
        let oldLayoutCodeText = this.getField("layoutCode");
        if(layoutCodeText != oldLayoutCodeText) {
            this.setField("layoutCode",layoutCodeText);
        }
    }

    updateValidatorCode(validatorCodeText) { 
        let oldValidatorCodeText = this.getField("validatorCode");
        if(validatorCodeText != oldValidatorCodeText) {
            this.setField("validatorCode",validatorCodeText);
        }
    }

    //==============================
    // serialization
    //==============================

    readPropsFromJson(json) {
        if(!json) return;
        
        //load the resource
        if(json.layoutCode) { 
            this.updateLayoutCode(json.layoutCode); 
        }

        if(json.validatorCode) {
            this.updateValidatorCode(json.validatorCode);
        }
    }

    /** This serializes the table component. */
    writeToJson(json,modelManager) {
        //store the for code text
        json.layoutCode = this.getField("layoutCode");
        json.validatorCode = this.getField("validatorCode");
    }

}

//======================================
// This is the control generator, to register the control
//======================================

DataFormComponent.displayName = "New Data Form Cell";
DataFormComponent.uniqueName = "apogeeapp.NewDataFormCell";
DataFormComponent.DEFAULT_MEMBER_JSON = {
    "type": "apogee.Folder",
    "childrenNotWriteable": true,
    "children": {
        "input": {
            "name": "input",
            "type": "apogee.JsonMember",
            "updateData": {
                "data": "",
            }
        },
        "value": {
            "name": "value",
            "type": "apogee.JsonMember",
            "updateData": {
                "data": "",
            }
        }
    }
};

//=====================================
// Update Data Command
//=====================================

/*
 *
 * Command JSON format:
 * {
 *   "type":"actionFormComponentUpdateCommand",
 *   "memberId":(main member ID),
 *   "field": (field to update, "layout" or "validator")
 *   "initialValue":(original fields value)
 *   "targetValue": (desired fields value)
 * }
 */ 
let dataFormUpdateCommand = {};

dataFormUpdateCommand.createUndoCommand = function(workspaceManager,commandData) {
    let undoCommandData = {};
    undoCommandData.type = dataFormUpdateCommand.commandInfo.type;
    undoCommandData.memberId = commandData.memberId;
    undoCommandData.field = commandData.field;
    undoCommandData.initialValue = commandData.targetValue;
    undoCommandData.targetValue = commandData.initialValue;
    return undoCommandData;
};

dataFormUpdateCommand.executeCommand = function(workspaceManager,commandData) {
    let modelManager = workspaceManager.getMutableModelManager();
    let componentId = modelManager.getComponentIdByMemberId(commandData.memberId);
    let component = modelManager.getMutableComponentByComponentId(componentId);
    var commandResult = {};
    if(component) {
        try {
            if(commandData.field == "layout") {
                component.updateLayoutCode(commandData.targetValue);
            }
            else if(commandData.field == "validator") {
                component.updateValidatorCode(commandData.targetValue);
            }
            else {
                throw new Error("Internal error: unknown update field: " + commandData.field);
            }

            commandResult.cmdDone = true;
            commandResult.target = component;
            commandResult.eventAction = "updated";
        }
        catch(error) {
            if(error.stack) console.error(error.stack);
            let msg = error.message ? error.message : error;
            commandResult.cmdDone = false;
            commandResult.alertMsg = "Exception on custom component update: " + msg;
        }
    }
    else {
        commandResult.cmdDone = false;
        commandResult.alertMsg = "Component not found: " + commandData.memberId;
    }
    
    return commandResult;
};

dataFormUpdateCommand.commandInfo = {
    "type": "dataFormUpdateCommand",
    "targetType": "component",
    "event": "updated"
};


CommandManager.registerCommand(dataFormUpdateCommand);

/** This component is similar to the JsonTableComponent except that it
 * also supports function elements. When displaying them it replaces the function
 * element with the string value for that function.
 * This component only allows the standard JSON view and it also does not support manually
 * editing the value. The value must be returned from the formula.
 * This implementation is also inefficient. It is not intended for large data objects.
 */
class JsonPlusTableComponent extends Component {
    
        
    constructor(member,modelManager,instanceToCopy,keepUpdatedFixed) {
        //extend edit component
        super(member,modelManager,instanceToCopy,keepUpdatedFixed);
    };
}

//======================================
// This is the component generator, to register the component
//======================================


/** This is the display name for the type of component */
JsonPlusTableComponent.displayName = "Extended Data Cell";
/** This is the univeral uniaue name for the component, used to deserialize the component. */
JsonPlusTableComponent.uniqueName = "apogeeapp.ExtendedJsonCell";

JsonPlusTableComponent.DEFAULT_MEMBER_JSON = {
    "type": "apogee.JsonMember"
};

/** This module initializes the default component classes. */

let componentInfo = {};

let componentClasses = {};
let standardComponents = [];
let additionalComponents = [];
let pageComponents = [];

//==========================
// Functions
//==========================

/** This method registers a new component. It will be exposed when the user
 * requests to create a new component */
componentInfo.registerComponent = function(componentClass) {
    var name = componentClass.uniqueName;

    //we should maybe warn if another component bundle is being overwritten
    componentClasses[name] = componentClass;
    if(additionalComponents.indexOf(name) < 0) {
        additionalComponents.push(name);
    }
};

/** This method registers a component. */
componentInfo.registerStandardComponent = function(componentClass) {
    var name = componentClass.uniqueName;

    //we should maybe warn if another component bundle is being overwritten 
    componentClasses[name] = componentClass;
    if(standardComponents.indexOf(name) < 0) {
        standardComponents.push(name);
    }
};

/** This method registers a new component. It will be exposed when the user
 * requests to create a new component */
componentInfo.registerPageComponent = function(componentClass) {
    var name = componentClass.uniqueName;

    //we should maybe warn if another component bundle is being overwritten
    componentClasses[name] = componentClass;
    if(pageComponents.indexOf(name) < 0) {
        pageComponents.push(name);
    }
};

/** This method registers a new component. It will be exposed when the user
 * requests to create a new component */
componentInfo.unregisterComponent = function(componentClass) {
    //implement this
};

/** This method returns a component generator of a given name. */
componentInfo.getComponentClass = function(name) {
    return componentClasses[name];
};

componentInfo.getStandardComponentNames = function() {
    return standardComponents;
};

componentInfo.getAdditionalComponentNames = function() {
    return additionalComponents;
};

componentInfo.getPageComponentNames = function() {
    return pageComponents;
};

//===============================
//initialization
//===============================

//register standard child components
componentInfo.registerStandardComponent(JsonTableComponent);
componentInfo.registerStandardComponent(FunctionComponent);
componentInfo.registerStandardComponent(FolderFunctionComponent);
componentInfo.registerStandardComponent(DynamicForm);
componentInfo.registerStandardComponent(FormDataComponent);

//additional child components
componentInfo.registerComponent(CustomComponent);
componentInfo.registerComponent(CustomDataComponent);

componentInfo.registerPageComponent(FolderComponent);
componentInfo.registerPageComponent(FolderFunctionComponent);

//other components
componentInfo.FOLDER_COMPONENT_CLASS = FolderComponent;
componentInfo.ERROR_COMPONENT_CLASS = ErrorComponent;

//test for new formS
componentInfo.registerComponent(ActionFormComponent);
componentInfo.registerComponent(DataFormComponent);

//JSON PLUS COMPONENT
componentInfo.registerComponent(JsonPlusTableComponent);

/** This class manages the user interface for a model object. */
class ModelManager extends FieldObject {

    constructor(app,instanceToCopy,keepUpdatedFixed) {
        super("modelManager",instanceToCopy,keepUpdatedFixed);

        this.app = app;

        //==============
        //Fields
        //==============
        //Initailize these if this is a new instance
        if(!instanceToCopy) {
            this.setField("model",null);
            this.setField("componentMap",{});
            this.setField("memberMap",{});
        }

        //==============
        //Working variables
        //==============
        this.viewStateCallback = null;
        this.cachedViewState = null;

        this.workingChangeMap = {};

        //add a change map entry for this object
        this.workingChangeMap[this.getId()] = {action: instanceToCopy ? "modelManager_updated" : "modelManager_created", instance: this};
      
    }

    //====================================
    // Methods
    //====================================

    /** This gets the application instance. */
    getApp() {
        return this.app;
    }

    /** This method gets the model object. */
    getModel() {
        return this.getField("model");
    }

    /** This method returns a mutable instance of the model. If the active model is already mutable
     * it returns that. If not, it returns a mutble copy that also becomes the current model instance. */
    getMutableModel() {
        let oldModel = this.getModel();
        if(oldModel.getIsLocked()) {
            let newModel = oldModel.getMutableModel();
            this.setField("model",newModel);
            
            //add listeners
            //newModel.addListener("member_created", member => this.memberCreated(member));
            newModel.addListener("member_updated", member => this.memberUpdated(member));
            newModel.addListener("member_deleted", member => this.memberDeleted(member));
            newModel.addListener("model_updated", model => this.modelUpdated(model));

            return newModel;
        }
        else {
            return oldModel;
        }
    }

    
    //============================
    // Component Creation
    //============================

    /** This returns the list of parents for newly created members. The argument includeRootFolder includes
     * the root folder in the list. This should only be done for other parent objects (The root should not 
     * hold any children.). */
    getParentList(includeRootFolder) {
        let componentMap = this.getField("componentMap");
        let model = this.getModel();
        let folders = [];
        //get the model parent entry
        if(includeRootFolder) {
            folders.push(["Root Folder",model.getId()]);
        }
        
        //get folder compontents
        for(var key in componentMap) {
            var component = componentMap[key];
            if(component.getParentFolderForChildren) {
                let folderMember = component.getParentFolderForChildren();
                if(folderMember.getChildrenWriteable()) { 
                    let folderEntry = [];
                    folderEntry.push(folderMember.getFullName(model));
                    folderEntry.push(folderMember.getId());
                    folders.push(folderEntry);
                }
            }
        }
        return folders;
    }
        
    createComponentFromMember(member,componentJson) {

        if(!member) {
            throw new Error("Unknown error: member missing!");
        }
        
        //response - get new member
        var component;
        var componentClass = componentInfo.getComponentClass(componentJson.type);
        if((componentClass)&&(member.constructor.generator.type != "apogee.ErrorMember")) {

            //create empty component
            component = new componentClass(member,this);

            //apply any serialized values
            if(componentJson) {
                component.loadStoredData(componentJson);
            }
        }

        //if we failed to create the component, or if we failed to make the member properly (and we used the error member)
        if(!component) {
            //table not found - create an empty error table
            componentClass = componentInfo.ERROR_COMPONENT_CLASS;
            component = new componentClass(member,this);
            if(componentJson) {
                component.loadStoredData(componentJson);
            }
        }

        if(!component) {
            throw new Error("Unknown error creating componet: " + member.getName());
        }

        //load the children, after the component load is completed
        if(component.loadChildrenFromJson) {
            component.loadChildrenFromJson(this,componentJson);
        }

    }

    
    //=============================
    // Model event handlers
    //=============================

    /** This method responds to a member updated. */
    memberCreated(member) {
    }


    /** This method responds to a member updated. */
    memberUpdated(member) {
        let componentId = this.getComponentIdByMemberId(member.getId());
        if(componentId) {
            let component = this.getMutableComponentByComponentId(componentId);
            component.memberUpdated(member);
        }
    }

    modelUpdated(model) {
    }

    /** This method responds to a delete menu event. */
    memberDeleted(member) {
        let memberId = member.getId();
        let componentId = this.getComponentIdByMemberId(memberId);
        if(componentId) {
            let oldComponentMap = this.getField("componentMap");
            let component = oldComponentMap[componentId];

            //take any delete actions (thes should not require a mutable member)
            component.onDelete();

            //unregister the component
            this._unregisterComponent(component);
        }
    }


    //====================================
    // Component Owner Functionality
    //====================================

    /** The change map lists the changes to the components and model. This will only be
     * valid when the ModelManager is unlocked */
    getChangeMap() {
        return this.workingChangeMap;
    }

    getChangeMapAll() {
        let changeMapAll = {};
        let componentMap = this.getField("componentMap");
        for(var id in componentMap) {
            changeMapAll[id] = {action: "component_updated", instance: componentMap[id]};
        }
        return changeMapAll;
    }

    /** This method locks the model manager and all components. */
    lockAll() {
        this.workingChangeMap = null;

        let componentMap = this.getField("componentMap");
        for(var id in componentMap) {
            componentMap[id].lock();
        }
        this.lock();
    }

    getComponentByComponentId(componentId) {
        return this.getField("componentMap")[componentId];
    }

    /** This method gets the component associated with a member object. */
    getMutableComponentByComponentId(componentId) {
        let oldComponentMap = this.getField("componentMap");
        var oldComponent = oldComponentMap[componentId];
        if(oldComponent) {
            if(oldComponent.getIsLocked()) {
                //create an unlocked instance of the component
                let newComponent = new oldComponent.constructor(oldComponent.getMember(),this,oldComponent);

                //register this instance
                this.registerComponent(newComponent);

                return newComponent;
            }
            else {
                return oldComponent;
            }
        }
        else {
            return null;
        }
    }

    /** This method gets the component associated with a member object. */
    getComponentIdByMemberId(memberId) {
        let memberMap = this.getField("memberMap");
        var memberInfo = memberMap[memberId];
        if(memberInfo) {
            return memberInfo.componentId;
        }
        else {
            return null;
        }
    }

    /** This method stores the component instance. It must be called when a
     * new component is created and when a component instance is replaced. */
    registerComponent(component) {
        let componentId = component.getId();
        let oldComponentMap = this.getField("componentMap");

        //create the udpated map
        let newComponentMap = {};
        Object.assign(newComponentMap,oldComponentMap);
        newComponentMap[componentId] = component;
        this.setField("componentMap",newComponentMap);

        //update the change map
        let oldChangeEntry = this.workingChangeMap[componentId];  
        let newAction; 
        //this.workingChangeMap[componentId] = {action: (oldInstance ? "component_updated" : "component_created"), instance: component};
        if(oldChangeEntry) {
            //we will assume the events come in order
            //the only scenarios assuming order are:
            //created then updated => keep action as created
            //updated then updated => no change
            //we will just update the component
            newAction = oldChangeEntry.action;
        }
        else {
            //new action will depend on if we have the component in our old component map
            newAction = oldComponentMap[componentId] ? "component_updated" : "component_created"; 
        }
        this.workingChangeMap[componentId] = {action: newAction, instance: component};
    }

    /** This method takes the local actions needed when a component is deleted. It is called internally. */
    _unregisterComponent(component) {
        let componentId = component.getId();

        //update the component map
        let oldComponentMap = this.getField("componentMap");
        let newComponentMap = {};
        Object.assign(newComponentMap,oldComponentMap);
        //remove the given component
        delete newComponentMap[componentId];
        //save the updated map
        this.setField("componentMap",newComponentMap);

        //update the member map
        //this is a little cumbersome
        let oldMemberMap = this.getField("memberMap");
        let newMemberMap = {};
        Object.assign(newMemberMap,oldMemberMap);
        for(let componentMemberId in newMemberMap) {
            let componentInfo = newMemberMap[componentMemberId];
            if(componentInfo.componentId == componentId) {
                delete newMemberMap[componentMemberId];
            }
        }
        this.setField("memberMap",newMemberMap);

        //update the change map
        let oldChangeEntry = this.workingChangeMap[componentId];
        let newChangeEntry;
        if(oldChangeEntry) {
            //handle the case of an existing change entry
            if(oldChangeEntry.action == "component_created") {
                //component created and deleted during this action - flag it as transient
                newChangeEntry = {action: "transient", instance: component};
            }
            else if(oldChangeEntry.action == "component_updated") {
                newChangeEntry = {action: "component_deleted", instance: component};
            }
            else {
                //this shouldn't happen. If it does there is no change to the action
                //we will just update the component
                newChangeEntry = {action: oldChangeEntry.action, instance: component};
            }
        }
        else {
            //add a new change entry
            newChangeEntry = {action: "component_deleted", instance: component};
        }
        this.workingChangeMap[componentId] = newChangeEntry;  
    }

    /** This method registers a member data object and its associated component object.
     * If the member is not the main member assoicated with component but instead an included
     * member, the main componentMember should be passed in also. Otherwise it should be left 
     * undefined. */
    registerMember(memberId,component,isMain) {

        let oldMemberMap = this.getField("memberMap");

        if(oldMemberMap[memberId]) {
            //already registered
            return;
        }

        //copy the old map
        let newMemberMap = {};
        Object.assign(newMemberMap,oldMemberMap);

        //add the new info
        let memberInfo = {};
        memberInfo.memberId = memberId;
        memberInfo.componentId = component.getId();
        memberInfo.isMain = isMain;

        newMemberMap[memberId] = memberInfo;

        this.setField("memberMap",newMemberMap);
    }
    
    testPrint(eventInfo) {
        if(eventInfo.updated) {
            console.log(JSON.stringify(eventInfo.updated));
        }
    }

    //====================================
    // open and save methods
    //====================================
    
    setViewStateCallback(viewStateCallback) {
        this.viewStateCallback = viewStateCallback;
    }

    getCachedViewState() {
        return this.cachedViewState;
    }

     /** This method loads the model data and model components from the json. */
    load(workspaceManager,json) {

        let modelJson; 
        let componentsJson;

        if(json) {
            modelJson = json.model;
            componentsJson = json.components;

            //set the view state
            if(json.viewState !== undefined) {
                this.cachedViewState = json.viewState;
            }
        }

        //load defaults if there is not saved model data
        if(!modelJson) modelJson = Model.EMPTY_MODEL_JSON;
        if(!componentsJson) componentsJson = ModelManager.EMPTY_MODEL_COMPONENT_JSON;

        //create model
        let model = new Model(workspaceManager.getModelRunContext());
        this.setField("model",model);
        
        //add listeners
        //model.addListener("member_created", member => this.memberCreated(member));
        model.addListener("member_updated", member => this.memberUpdated(member));
        model.addListener("member_deleted", member => this.memberDeleted(member));
        model.addListener("model_updated", model => this.modelUpdated(model));

        //load the model
        let loadAction = {};
        loadAction.action = "loadModel";
        loadAction.modelJson = modelJson;
        let actionResult = doAction(model,loadAction);

        //create the return result
        let commandResult = {};

        if(actionResult.actionDone) {
            commandResult.eventAction = "updated";
            commandResult.cmdDone = true;
            commandResult.target = this;

            //create the children
            let childCommandResults = [];
            let rootChildIdMap = model.getChildIdMap();
            for(let childName in rootChildIdMap) {
                let childMemberId = rootChildIdMap[childName];
                let childMember = model.lookupMemberById(childMemberId);
                if(childMember) {
                    let childJson = componentsJson[childName];
                    let childCommandResult = this.createComponentFromMember(childMember,childJson);
                    childCommandResults.push(childCommandResult);
                }
            }
            if(childCommandResults.length > 0) {
                commandResult.childCommandResults = childCommandResults;
            }

            commandResult.actionResult = actionResult;
        }
        else {
            commandResult.cmdDone = false;
            commandResult.errorMsg = "Error opening workspace model";
        }

        return commandResult;
    }

    /** This method closes the model object. */
    close() {
        //delete all the components - to make sure the are cleaned up
        let componentMap = this.getField("componentMap");
        for(let key in componentMap) {
            let component = componentMap[key];
            component.onDelete();
        }

        let model = this.getModel();
        model.onClose(model);
    }

    /** This saves the model. It the optionalSavedRootFolder is passed in,
     * it will save a model with that as the root folder. */
    toJson(optionalSavedRootFolder) {

        let model = this.getField("model");
        let json = {};

        //get the model json
        if(optionalSavedRootFolder) {
            throw new Error("Need to correctly save the model for the optional saved root folder!");
        }
        json.model = model.toJson();

        //get the components json
        let componentsJson = {};

        //get the "root folder" - either for the model or the optional folder to save.
        let childIdMap;
        if(optionalSavedRootFolder) {
            childIdMap = optionalSavedRootFolder.getChildMap();
        }
        else {
            childIdMap = model.getChildIdMap();
        } 

        //get all the components asoicated with the root members
        for(let childName in childIdMap) {
            //member
            let memberId = childIdMap[childName];
            let componentId = this.getComponentIdByMemberId(memberId);
            let component = this.getComponentByComponentId(componentId);
            componentsJson[childName] = component.toJson(this);
        }
        json.components = componentsJson;

        //model view state
        if(this.viewStateCallback) {
            this.cachedViewState = this.viewStateCallback();
            if(this.cachedViewState) componentsJson.viewState = this.cachedViewState;
        }

        return json;
    }

    //==================================
    // DEV FUNCTION
    //==================================

    showDependencies() {
        console.log(JSON.stringify(this.createDependencies()));
    }

    createDependencies() {
        throw new Error("This needs to be rewritten, probably in Model rather than here.")
        //for one thing I removed the model instance from componentInfo in the component map
        //instead I should just read all the members from the model.

        // let model = this.getField("model");
        // var memberInfo = {};

        // let componentMap = this.getField("componentMap");

        // for(var key in componentMap) {
        //     var componentInfo = componentMap[key];
        //     if((componentInfo)&&(componentInfo.member)) {


        //         var member = componentInfo.member;

        //         var memberStruct = {};
        //         memberStruct.type = member.constructor.generator.type;
        //         var parentMember = member.getParentMember(model);
        //         memberStruct.parent = parentMember ? parentMember.getFullName(model) : null;

        //         if(member.isDependent) {
        //             let depList = [];
        //             let dependsOnMap = member.getDependsOn();
        //             for(var idString in dependsOnMap) {
        //                 dependencyType = dependsOnMap[idString];
        //                 if(dependencyType == apogeeutil.NORMAL_DEPENDENCY) {
        //                     let dependency = model.lookupMemberById(idString);
        //                     depList.push(dependency.getFullName(model));
        //                 }
        //             }
        //             if(depList.length > 0) {
        //                 memberStruct.dep = depList;
        //             }
        //         }

        //         memberInfo[member.getFullName(model)] = memberStruct;
        //     }
        // }

        // return memberInfo;
    }

}

//this is the json for an empty model, with the page opened
ModelManager.EMPTY_MODEL_COMPONENT_JSON = {
    "main": {
        "type":"apogeeapp.PageComponent",
        "viewState": {
            "tabOpened": true,
            "tabShowing": true
          }
    }
};

/** This class manages the workspace. */
class WorkspaceManager extends FieldObject {

    constructor(app,instanceToCopy,keepUpdatedFixed) {
        super("workspaceManager",instanceToCopy,keepUpdatedFixed);

        this.app = app;
        
        //==============
        //Fields
        //==============
        //Initailize these if this is a new instance
        if(!instanceToCopy) {
            let modelManager = new ModelManager(this.app);
            this.setField("modelManager",modelManager);

            let referenceManager = new ReferenceManager(this.app);
            this.setField("referenceManager",referenceManager);

            //this is not a field like above because when we do not require a command to change it
            this.isDirty = false;

            //temporary
            this.created = true;
        }
        else {
            //this is not a field like above because when we do not require a command to change it
            this.fileMetadata = instanceToCopy.fileMetadata;
            this.isDirty = instanceToCopy.isDirty;

            //temporary
            this.created = false;
        }

        //==============
        //Working variables
        //==============
        this.viewStateCallback = null;
        this.cachedViewState = null;

        this.isClosed = false;
    }

    //====================================
    // Workspace Management
    //====================================

    /** This gets the application instance. */
    getApp() {
        return this.app;
    }

    /** This method returns a mutable copy of this instance. If the instance is already mutable
     * it will be returned rather than making a new one.  */
    getMutableWorkspaceManager() {
        if(this.getIsLocked()) {
            //create a new instance that is a copy of this one
            return new WorkspaceManager(this.app,this);
        }
        else {
            //return this instance since it si already unlocked
            return this;
        }
    }

    // temporary implementation
    getChangeMap() {
        let changeMap = {};
        //workspace always changes
        let workspaceManagerEvent;
        if(this.isClosed) workspaceManagerEvent = "workspaceManager_deleted";
        else if(this.created)  workspaceManagerEvent = "workspaceManager_created";
        else workspaceManagerEvent = "workspaceManager_updated";
        changeMap[this.getId()] = {action: workspaceManagerEvent, instance: this};

        let referenceManager = this.getReferenceManager();
        let referenceChangeMap = referenceManager.getChangeMap();
        if(referenceChangeMap) Object.assign(changeMap,referenceChangeMap);

        let modelManager = this.getModelManager();
        let modelChangeMap = modelManager.getChangeMap();
        if(modelChangeMap) Object.assign(changeMap,modelChangeMap);

        return changeMap;
    }

    getChangeMapAll() {
        let changeMapAll = {};
        changeMapAll[this.getId()] = {action: "workspaceManager_updated", instance: this};

        let referenceManager = this.getReferenceManager();
        let referenceChangeMap = referenceManager.getChangeMapAll();
        if(referenceChangeMap) Object.assign(changeMapAll,referenceChangeMap);

        let modelManager = this.getModelManager();
        let modelChangeMap = modelManager.getChangeMapAll();
        if(modelChangeMap) Object.assign(changeMapAll,modelChangeMap);

        return changeMapAll;
    }

    /** This method locks this workspace instance and all the contained object instances. */
    lockAll() {
        //we maybe shouldn't be modifying the members in place, but we will do it anyway
        this.getReferenceManager().lockAll();
        this.getModelManager().lockAll();
        this.lock();
    }

    getReferenceManager() {
        return this.getField("referenceManager");
    }

    /** This method returns an unlocked reference manager instance. If the current
     * reference manager is unlocked it will return that. Otherwise it will return
     * a new unlocked instance that will also be set as the current instance. */
    getMutableReferenceManager() {
        let oldReferenceManager = this.getReferenceManager();
        if(oldReferenceManager.getIsLocked()) {
            //create a new instance that is a copy of this one
            let newReferenceManager = new ReferenceManager(this.app,oldReferenceManager);
            this.setField("referenceManager",newReferenceManager);
            return newReferenceManager;
        }
        else {
            //return this instance since it si already unlocked
            return oldReferenceManager;
        }
    }

    getModelManager() {
        return this.getField("modelManager");
    }

    /** This method returns an unlocked model manager instance. If the current
     * model manager is unlocked it will return that. Otherwise it will return
     * a new unlocked instance that will also be set as the current instance. */
    getMutableModelManager() {
        let oldModelManager = this.getModelManager();
        if(oldModelManager.getIsLocked()) {
            //create a new instance that is a copy of this one
            let newModelManager = new ModelManager(this.app,oldModelManager);
            this.setField("modelManager",newModelManager);
            return newModelManager;
        }
        else {
            //return this instance since it si already unlocked
            return oldModelManager;
        }
    }

    getIsDirty() {
        return this.isDirty;
    }
    
    setIsDirty() {
        this.isDirty = true;
    }
    
    clearIsDirty() {
        this.isDirty = false;
    }

    getIsClosed() {
        return this.isClosed;
    }
    
    
    //====================================
    // asynch run context methods
    //====================================

    /** This runs a command asynchronously */
    runFutureCommand(commandData) {
        //run command asynchronously
        setTimeout(() => this.app.executeCommand(commandData),0);
    }

    getModelRunContext() {
        let modelRunContext = {};
        modelRunContext.doAsynchActionCommand = (modelId,action) => {
            //create a command to run this action
            let modelActionCommand = {};
            modelActionCommand.type = "futureModelActionCommand";
            modelActionCommand.modelId = modelId;
            modelActionCommand.action = action;

            //execut this command as a future command
            this.runFutureCommand(modelActionCommand);
        };

        return modelRunContext;
    }

    //====================================
    // configuration
    //====================================

    /** This retrieves the file metadata used to save the file. */
    getFileMetadata() {
        return this.fileMetadata;
    }

    /** This method should be used to update the file metadata for the workspace, such as after the file is saved. */
    setFileMetadata(fileMetadata) {
        this.fileMetadata = fileMetadata;
    }

    //====================================
    // open and save methods
    //====================================

    setViewStateCallback(viewStateCallback) {
        this.viewStateCallback = viewStateCallback;
    }

    getCachedViewState() {
        return this.cachedViewState;
    }

    /** This saves the workspace. It the optionalSavedRootFolder is passed in,
     * it will save a workspace with that as the root folder. */
    toJson(optionalSavedRootFolder) {
        var json = {};
        json.fileType = "apogee app js workspace";

        json.version = WorkspaceManager.FILE_VERSION;

        json.references = this.getReferenceManager().toJson();

        json.code = this.getModelManager().toJson(optionalSavedRootFolder);

        if(this.viewStateCallback) {
            this.cachedViewState = this.viewStateCallback();
            if(this.cachedViewState) json.viewState = this.cachedViewState;
        }

        return json;
    }

    
     /** This method sets the workspace. The argument workspaceJson should be included
      * if the workspace is not empty, such as when opening a existing workspace. It
      * contains the data for the component associated with each model member. For 
      * a new empty workspace the workspaceJson should be omitted. 
      * The argument fileMetadata is the file identifier if the workspace is opened from a file.
      * This will be used for the "save" function to save to an existing file. */
     load(json,fileMetadata) {

        //check file format
        if(json) {
            if(json.version != WorkspaceManager.FILE_VERSION) {
                let msg = "Version mismatch. Expected version " + WorkspaceManager.FILE_VERSION + ", Found version " + json.version;
                throw new Error(msg);
            }
        }
        else {
            //create aan empty json to load
            json = {};
        }

        //store the file metadata
        this.fileMetadata = fileMetadata;

        //set the view state
        if(json.viewState !== undefined) {
            this.cachedViewState = json.viewState;
        }

        //check for references. If we have references we must load these before loading the model
        if(json.references) {
            //if there are references, load these before loading the model.
            //this is asynchronous so we must load the model in a future command
            let referenceManager = this.getReferenceManager();
            let referenceLoadPromise = referenceManager.load(this,json.references);

            let onReferencesLoaded = () => {
                //load references regardless of success or failure in loading references
                let loadModelCommand = {};
                loadModelCommand.type = "loadModelManager";
                loadModelCommand.json = json.code;
                this.runFutureCommand(loadModelCommand);
            };

            referenceLoadPromise.then(onReferencesLoaded);
        }
        else {
            //if there are not references we can load the model directly.
            let modelManager = this.getModelManager();
            modelManager.load(this,json.code);
        }
    }

    /** This method closes the workspace object. */
    close() {
        //close model manager
        let modelManager = this.getModelManager();
        modelManager.close();

        //close reference manager
        let referenceManager = this.getReferenceManager();
        referenceManager.close();

        //flag the workspace as closed
        this.isClosed = true;
    }

}

WorkspaceManager.FILE_VERSION = "0.60";


//=====================================
// Command Object
//=====================================

/*** 
 * This command loads the model manager. It is a follow on command to opening a workspace,
 * if there are references present, which must be loaded first.
 * 
 * commandData.type = "loadModelManager"
 * commandData.json = (json for the model/model manager)
 */

let loadmodelmanager = {};

//There is no undo command since this is a follow on to opening a workspace
//loadmodelmanager.createUndoCommand = function(workspaceManager,commandData) {

/** This method loads an existing, unpopulated model manager. It is intended only as
 * a asynchronous follow on command to opening a workspace, once any references have
 * been loaded.
 */
loadmodelmanager.executeCommand = function(workspaceManager,commandData) {
    try {
        let modelManager = workspaceManager.getMutableModelManager();
        return modelManager.load(workspaceManager,commandData.json);
    }
    catch(error) {
        throw error;
    }
};

loadmodelmanager.commandInfo = {
    "type": "loadModelManager",
    "targetType": "modelManager",
    "event": "updated"
};

CommandManager.registerCommand(loadmodelmanager);

/** @private */
let apogeeInstance = null;

//======================================
//class definition
//======================================

/** This is the main class of the apogee application. 
 * This constuctor should not be called externally, the static creation method 
 * should be used. This is a singlet.
 * 
 * @param appConfigManager - An instance of an AppConfigManager on configure the application.
 * 
 * @private */
class Apogee {

    constructor(appConfigManager) {

        //mixin initialization
        this.eventManagerMixinInit();
        
        //make sure we define this once
        if(apogeeInstance != null) {
            throw new Error("Error: There is already an Apogee app instance - the Apogee class is a singleton.");
        }
        else {
            apogeeInstance = this;
        }
        
        this.appConfigManager = appConfigManager;
        
        //---------------------------------
        //construct the base app structures
        //---------------------------------
        
        //workspace manager
        this.workspaceManager = null;
        
        //component generators
        this.componentClasses = {};
        this.standardComponents = [];
        //these are a list of names of components that go in the "added component" list
        this.additionalComponents = [];
        
        //default settings
        this.appSettings = {};
        
        //reference manager
        this.referenceManager = new ReferenceManager(this);
        
        //command manager
        this.commandManager = new CommandManager(this);

        //subscribe to app events
        this.subscribeToAppEvents();
        
        //----------------------------------
        //configure the application
        //----------------------------------
        var appConfigPromise = this.appConfigManager.getConfigPromise(this);
        
        appConfigPromise.then(() => this.initApp()).catch(errorMsg => apogeeUserAlert("Fatal error configuring application: " + errorMsg));
        
    }

    /** This subscribes to all events needed by this class. On close, all listeners will be removed. This will 
     * be called to add back the need app events. */
    subscribeToAppEvents() {
        //subscribe to events
        this.addListener("workspaceDirty",() => this._setWorkspaceIsDirty());
    }

    //======================================
    // static singleton methods
    //======================================

    /** This retrieves an existing instance. It does not create an instance. */
    static getInstance() {
        return apogeeInstance;
    }

    // /** This function initializes the default classes for the application. */
    // static setBaseClassLists(standardComponents, additionalComponents, errorComponentClass) {
    //     Apogee.standardComponents = standardComponents;
    //     Apogee.additionalComponents = additionalComponents;
    //     Apogee.errorComponentClass = errorComponentClass;
    // }

    //==================================
    // Workspace Management
    //==================================

    /** This method returns the active WorkspaceManager object. */
    getWorkspaceManager() {
        return this.workspaceManager;
    }

    createWorkspaceManager() {
        return new WorkspaceManager(this);
    }

    /** This method returns the active model object. */
    getModelManager() {
        if(this.workspaceManager) {
            return this.workspaceManager.getModelManager();
        }
        else {
            return null;
        }
    }

    /** This method returns the active model object. */
    getModel() {
        if(this.workspaceManager) {
            return this.workspaceManager.getModelManager().getModel();
        }
        else {
            return null;
        }
    }

    /** This method makes an empty workspace object. This can be used to set the initial workspace
     * manager or to give the new instance of the workspace manager. However, if the workspace manager
     * is being updated it must have the same ID as the existing workspace manager or else an exception
     * will be thrown.
     */
    setWorkspaceManager(workspaceManager) {
        //we can only have one workspace of a given id
        if((this.workspaceManager)&&(this.workspaceManager.getId() != workspaceManager.getId())) {
            throw new Error("There is already an open workspace");
        }
        this.workspaceManager = workspaceManager;
        return true;
    }

    /** This method closes the active workspace. */
    clearWorkspaceManager() {
        //remove the workspace from the app
        this.workspaceManager = null;
        
        return true;
    }

    //====================================
    // Command Management
    //====================================

    /** This method should be called to execute commands. */
    executeCommand(command) {
        return this.commandManager.executeCommand(command);
    }

    /** This method is intended for the UI for the undo/redo functionality */
    getCommandManager() {
        return this.commandManager;
    }

    /** This method returns true if the workspcae contains unsaved data. */
    getWorkspaceIsDirty() {
        if(this.workspaceManager) {
            return this.workspaceManager.getIsDirty();
        }
        else {
            return false;
        }
    }

    /** This method clears the workspace dirty flag. */
    clearWorkspaceIsDirty() {
        if(this.workspaceManager) {
            return this.workspaceManager.clearIsDirty();
        }
        else {
            return false;
        }
    }

    /** This method returns true if the workspcae contains unsaved data. 
     * @private */
    _setWorkspaceIsDirty() {
        if(this.workspaceManager) {
            return this.workspaceManager.setIsDirty();
        }
        else {
            return false;
        }
    }

    
    //======================================
    // configuration methods methods
    //======================================

    /** This method returns the app settings json. */
    getAppSettings() {
        return this.appSettings;
    }

    /** This mehod return the application ReferenceManager. */
    getAppReferenceManager() {
        return this.referenceManager;
    }

    /** This method sets the file access object. */
    setFileAccessObject(fileAccessObject) {
        this.fileAccessObject = fileAccessObject;
    }

    /** This method retrieves the file access object for the application. */
    getFileAccessObject() {
        return this.fileAccessObject;
    }



    //==================================
    // App Initialization
    //==================================

    /** This should be called to set any settings, if there are any. If there are
     * no settings, this may be omitted.
     * 
     * configJson format:
     * {
     *   "settings": { (settings json - settings keys with associated settings value) },
     *   "references": [ (array of references - same format as refernces in workspace.) ]
     * }
     * 
     * References may include self-installing modules, for example a custom file
     * access method or custom components. See info on self installing modules.
     */ 
    getConfigurationPromise(configJson) {   
        if(!configJson) return;
        
        //set the settings JSON
        this.appSettings = configJson.settings;
        if(!this.appSettings) this.appSettings = {};
        
        //load references
        var openEntriesPromise;
        if(configJson.references) {
            openEntriesPromise = this.referenceManager.getOpenEntriesPromise(configJson.references);
        }
        else {
            //instant resolve promise (with no meaningful return)
            openEntriesPromise = Promise.resolve();
        }
        
        var onLoadReferenceError = errorMsg => apogeeUserAlert("Error setting application level modules - some functionality may not be available: " + errorMsg);
        
        //if there is an error loading the promise, print a mesage and continue.
        return openEntriesPromise.catch(onLoadReferenceError);
    }
        
    /** This completes application initialization after any settings have been set. 
     * @private
     * */    
    initApp() {
        
        //file accessor - load the default if it wasn't loaded in cofiguration
        if(!this.fileAccessObject) {
            this.fileAccessObject = this.appConfigManager.getDefaultFileAccessObject(this);
        }
        
        //open the initial workspace or create a new workspace
        var workspaceFilePromise = this.appConfigManager.getInitialWorkspaceFilePromise(this);
        if(workspaceFilePromise) {
            var workspaceFileMetadata = this.appConfigManager.getInitialWorkspaceFileMetadata(this);
            
            var openInitialWorkspace = workspaceText => {
                let workspaceJson = JSON.parse(workspaceText);

                //open workspace
                var commandData = {};
                commandData.type = "openWorkspace";
                commandData.workspaceJson = workspaceJson;
                commandData.fileMetadata = workspaceFileMetadata;

                this.executeCommand(commandData);
            };
            
            workspaceFilePromise.then(openInitialWorkspace).catch(errorMsg => apogeeUserAlert("Error downloading initial workspace: " + errorMsg));
        }
        else {
            var commandData = {};
            commandData.type = "openWorkspace";
            
            this.executeCommand(commandData);
        }
        
    }
}

//add mixins to this class
apogeeutil$1.mixin(Apogee,EventManager);


Apogee.DEFAULT_Workspace_NAME = "workspace";

/** 
 * This is a base class for workspace opening and saveing, or whatever actions
 * are appropriate. It should be extended to provide functionality.
 */
class BaseFileAccess {
    /**
     * Constructor
     */
    constructor() {
        
    }

    /** 
     * This method should return a list of menu options for opening and closing
     * the workspace. The format should be a array with each entry being a
     * two entry array. The first item is the menu entry text and the second 
     * is the callback for the menu item action. 
     * Example: [["Open",openCallback],["Save",saveCallback]]
     * */
    getWorkspaceOpenSaveMenuOptions(app) {
        
    }

    //===============================
    // The following methods must be implmented by the extending class
    //===============================

    /**
     * This method returns true if the workspace has an existing file to which 
     * is can be saved without opening a save dialog. 
     */
    directSaveOk(fileMetadata) {
        return false;
    }
    
    /**
     * This method opens a file, including dispalying a dialog
     * to select the file.
     * arguments:
     * - onOpen(err,workspaceData,fileMetadata);
     * 
     * onOpen callback arguments:
     * - err - This is a string that will be populated if there was an error
     * - fileData - This is the file contents as a string
     * - fileMetadata - This is a implementation-defined structure that is used to store the file location.
     */
    //openFile(onOpen);

    /** This  method shows a save dialog and saves the file.
     * arguments:
     * - fileMetadata - This is a implementation-defined structure that is used to store the file location.
     * - fileData - This is the file contents as a string
     * - onSave(err,fileSaved,fileMetadata);
     * 
     * onSave callback arguments:
     * - err - This is a string that will be populated if there was an error
     * - fileSaved - This is boolean telling if the file was saved.
     * - fileMetadata - This is a implementation-defined structure that gives the saved file location.
     */
    //saveFileAs(fileMetadata,data,onSave);

    /** This  method directly saves the file without letting the user select the location.
     * arguments:
     * - fileMetadata - This is a implementation-defined structure that is used to store the file location.
     * - fileData - This is the file contents as a string
     * - onSave(err,fileSaved,fileMetadata);
     * 
     * onSave callback arguments:
     * - err - This is a string that will be populated if there was an error
     * - fileSaved - This is boolean telling if the file was saved.
     * - fileMetadata - This is a implementation-defined structure that gives the saved file location.
     */
    //saveFile(fileMetadata,data,onSave);


}

/** This is a simple custom component example. */
class FormInputBaseComponent extends Component {
    constructor(member,modelManager,instanceToCopy,keepUpdatedFixed) {
        super(member,modelManager,instanceToCopy,keepUpdatedFixed);

        //this should be present in the json that builds the folder, but in case it isn't (for one, because of a previous mistake)
        member.setChildrenWriteable(false);
        
        let model = modelManager.getModel();

        //==============
        //Fields
        //==============
        //Initailize these if this is a new instance
        if(!instanceToCopy) {
            //internal tables
            let dataMember = member.lookupChild(model,"data");
            if(dataMember) this.registerMember(modelManager,dataMember,"member.data",false);

            let formDataMember = member.lookupChild(model,"formData");
            if(formDataMember) this.registerMember(modelManager,formDataMember,"member.formData",false);

            let formResultMember = member.lookupChild(model,"formResult");
            if(formResultMember) this.registerMember(modelManager,formResultMember,"member.formResult",false);
        }
    }

    /** A class should be made to extend this base class. Then this initializer should be called with
     * the state class object to complete initialization of the class. */
    static initializeClass(classObject,cellDisplayName,cellUniqueName,dataProcessingFunctionBody) {

        //this defines the hardcoded type we will use
        let dataMemberDisplayName = cellUniqueName + "-data";
        let dataMemberTypeName = cellUniqueName + "-data";
        defineHardcodedJsonTable(dataMemberDisplayName,dataMemberTypeName,dataProcessingFunctionBody);

        //here we initialize some constants on the class
        classObject.displayName = cellDisplayName;
        classObject.uniqueName = cellUniqueName;
        classObject.DEFAULT_MEMBER_JSON = {
            "type": "apogee.Folder",
            "childrenNotWriteable": true,
            "children": {
                "formData": {
                    "name": "formData",
                    "type": "apogee.JsonMember",
                    "updateData": {
                        "data": ""
                    }
                },
                "formResult": {
                    "name": "formResult",
                    "type": "apogee.JsonMember",
                    "updateData": {
                        "data": "",
                        "contextParentGeneration": 2
                    }
                },
                "data": getSerializedHardcodedTable("data",dataMemberTypeName)
            }
        };
    }
}

/** Add Component Command
 *
 * Command JSON format:
 * {
 *   "type":"addComponent",
 *   "parentId":(parent ID),
 *   "memberJson":(member property json),
 *   "componentJson":(component property json)
 * }
 */ 

let addcomponent = {};

//=====================================
// Command Object
//=====================================

addcomponent.createUndoCommand = function(workspaceManager,commandData) {
    
    var undoCommandJson = {};
    undoCommandJson.type = "deleteComponent";
    undoCommandJson.parentId = commandData.parentId;
    undoCommandJson.memberName = commandData.memberJson.name;
    
    return undoCommandJson;
};

addcomponent.executeCommand = function(workspaceManager,commandData) { 
    
    let modelManager = workspaceManager.getMutableModelManager();
    let model = modelManager.getMutableModel();

    //create the member
    let createAction = {};
    createAction.action = "createMember";
    createAction.parentId = commandData.parentId;
    createAction.createData = commandData.memberJson;
    let actionResult = doAction(model,createAction);
    
    //create the components for the member
    //I need error handling for the create component action
    if(actionResult.actionDone) {
        //this is a bit clumsy...
        let parentMember = model.lookupMemberById(commandData.parentId);
        let name = commandData.memberJson.name;
        let componentMember = parentMember.lookupChild(model,name);
        modelManager.createComponentFromMember(componentMember,commandData.componentJson);
    }
    else {
        throw new Error("Failure creating member: " + actionResult.errorMsg);
    }
};

addcomponent.commandInfo = {
    "type": "addComponent",
    "targetType": "component",
    "event": "created"
};

CommandManager.registerCommand(addcomponent);

/** Add Link Command
 *
 * Command JSON format:
 * {
 *   "type":"addLink",
 *   "entryType":(entry type),
 *   "url":(url),
 *   "nickname":(nickname - optional)
 * }
 */ 
let addlink = {};

//=====================================
// Command Object
//=====================================

addlink.createUndoCommand = function(workspaceManager,commandData) {
    var undoCommandJson = {};
    undoCommandJson.type = "deleteLink";
    undoCommandJson.entryType = commandData.entryType;
    undoCommandJson.url = commandData.url;
    return undoCommandJson;
};

addlink.executeCommand = function(workspaceManager,commandData) {
    let referenceManager = workspaceManager.getMutableReferenceManager();
    //this creates the entry but does not load it
    let referenceEntry = referenceManager.createEntry(commandData);
    //this loads the entry - it will cause an asynchronouse command on completion
    referenceEntry.loadEntry(workspaceManager);
};

addlink.commandInfo = {
    "type": "addLink",
    "targetType": "link",
    "event": "created"
};

CommandManager.registerCommand(addlink);

let closeworkspace = {};

//=====================================
// Action
//=====================================

//NO UNDO FOR CLOSE Workspace
//closeworkspace.createUndoCommand = function(workspaceManager,commandData) {

closeworkspace.executeCommand = function(workspaceManager,commandData) {
    workspaceManager.close();
};

closeworkspace.commandInfo = {
    "type": "closeWorkspace",
    "targetType": "workspace",
    "event": "deleted"
};

CommandManager.registerCommand(closeworkspace);

let compoundcommand = {};

//=====================================
// Command Object
//=====================================

compoundcommand.createUndoCommand = function(workspaceManager,commandData) {
    let undoCommandJson = {};
    undoCommandJson.type = compoundcommand.commandInfo.type;
    undoCommandJson.childCommands = [];
    
    //add the child undo commands in the reverse order
    for(var i = commandData.childCommands.length-1; i >= 0; i--) {
        let childCommandJson = commandData.childCommands[i];
        let childCommandObject = CommandManager.getCommandObject(childCommandJson.type);
        let childUndoCommandJson = childCommandObject.createUndoCommand(workspaceManager,childCommandJson);
        if(childUndoCommandJson) undoCommandJson.childCommands.push(childUndoCommandJson);
    }
    
    if(undoCommandJson.childCommands.length > 0) return undoCommandJson;
    else return null;
};

/** This method is used for updating property values from the property dialog. 
 * If there are additional property lines, in the generator, this method should
 * be extended to edit the values of those properties too. */
compoundcommand.executeCommand = function(workspaceManager,commandData) {
    //execute all child commands
    for(var i = 0; i < commandData.childCommands.length; i++) {
        let childCommandJson = commandData.childCommands[i];
        let childCommandObject = CommandManager.getCommandObject(childCommandJson.type);
        childCommandObject.executeCommand(workspaceManager,childCommandJson);
    }
};

compoundcommand.commandInfo = {
    "type": "compoundCommand",
};

CommandManager.registerCommand(compoundcommand);

let deletecomponent = {};

//=====================================
// Command Object
//=====================================

/*** 
 * This command supports two formats:
 * 
 * Format 1: member ID
 * commandData.type = "deleteComponent"
 * commandData.memberId = (memberId)
 * 
 * Format 2: parent ID, memberName
 * commandData.type = "deleteComponent"
 * commandData.parentId = (parentId)
 * commandData.memberName = (memberName)
 */
deletecomponent.createUndoCommand = function(workspaceManager,commandData) {
    
    //problems
    // - is this member a component main member?
    
    let modelManager = workspaceManager.getModelManager();
    var model = modelManager.getModel();
    let member;
    let parent;

    if(commandData.memberId) {
        member = model.lookupMemberById(commandData.memberId);
        parent = member.getParent(model);
    }
    else {
        parent = model.lookupMemberById(commandData.parentId);
        member = parent.lookupChild(commandData.memberName);
    }

    let componentId = modelManager.getComponentIdByMemberId(member.getId());
    let component = modelManager.getComponentByComponentId(componentId);
    
    var commandUndoJson = {};
    commandUndoJson.type = "addComponent";
    commandUndoJson.parentId = parent.getId();
    commandUndoJson.memberJson = member.toJson(model);
    //this must be added so when we create the member, it matches our "delete" redo command
    commandUndoJson.memberJson.specialIdValue = member.getId();
    commandUndoJson.componentJson = component.toJson(modelManager);
    
    return commandUndoJson;
};

/** This method deletes the component and the underlying member. It should be passed
 *  the model and the member full name. (We delete by name and model to handle
 *  undo/redo cases where the instance of the member changes.)
 */
deletecomponent.executeCommand = function(workspaceManager,commandData) {
    
    let modelManager = workspaceManager.getMutableModelManager();
    let model = modelManager.getMutableModel();

    var actionJson = {};
    actionJson.action = "deleteMember";

    if(commandData.memberId) {
        actionJson.memberId = commandData.memberId;
    }
    else {
        let parent = model.lookupMemberById(commandData.parentId);
        let member = parent.lookupChild(model,commandData.memberName);
        actionJson.memberId = member.getId();
    }
    
    var actionResult = doAction(model,actionJson);
    if(!actionResult.actionDone) {
        throw new Error("Error deleting component: " + actionResult.errorMsg);
    }
};

deletecomponent.commandInfo = {
    "type": "deleteComponent",
    "targetType": "component",
    "event": "deleted"
};

CommandManager.registerCommand(deletecomponent);

/** Delete Link Command
 *
 * Command JSON format:
 * {
 *   "type":"deleteLink",
 *   "entryType":(entry type),
 *   "url":(url)
 * }
 */ 
let deletelink = {};

//=====================================
// Command Object
//=====================================

deletelink.createUndoCommand = function(workspaceManager,commandData) {
    
    var nickname;

    var referenceManager = workspaceManager.getReferenceManager();
    var referenceEntry = referenceManager.lookupEntry(commandData.entryType,commandData.url);
    
    if(referenceEntry) nickname = referenceEntry.getNickname();

    var undoCommandJson = {};
    undoCommandJson.type = "addLink";
    undoCommandJson.entryType = commandData.entryType;
    undoCommandJson.url = commandData.url;
    undoCommandJson.nickname = nickname;
    
    return undoCommandJson;
};

deletelink.executeCommand = function(workspaceManager,commandData) {
    var referenceManager = workspaceManager.getMutableReferenceManager();
    
    //lookup entry
    let referenceEntry = referenceManager.lookupEntry(commandData.entryType,commandData.url);
    if(!referenceEntry) throw new Error("Reference entry not found. refEntryId: " + refEntryId);

    referenceEntry.removeEntry();
    referenceManager.unregisterRefEntry(referenceEntry);
};

deletelink.commandInfo = {
    "type": "deleteLink",
    "targetType": "link",
    "event": "deleted"
};

CommandManager.registerCommand(deletelink);

/**
 * This command is intended to run asynchronous commands, for which no undo is given.
 * The intention is that these commands are byproducts of a different action that will be
 * undone by undoing that different action. (NEED TO THINK ABOUT HOW THIS IS GARUNTEED)
 */

let futuremodelactioncommand = {};

//=====================================
// Command Object
//=====================================

/** NO UNDO - DANGEROUS. THIS IS MEANT ONLY FOR FUTURE ACTIONS. IIF SOMEONE USES
 * IT FOR A REGULAR ACTION THEN IT WILL NOT PROPERLY BE REVERSIBLE!!!
 */
//futuremodelactioncommand.createUndoCommand = function(workspaceManager,commandData) {};

/** This method deletes the component and the underlying member. It should be passed
 *  the model and the member full name. (We delete by name and model to handle
 *  undo/redo cases where the instance of the member changes.)
 */
futuremodelactioncommand.executeCommand = function(workspaceManager,commandData) {
    
    let modelManager = workspaceManager.getMutableModelManager();
    let model = modelManager.getMutableModel();

    var actionResult = doAction(model,commandData.action);
    if(!actionResult.actionDone) {
        throw new Error("Error in model action command: " + actionResult.errorMsg);
    }
};

futuremodelactioncommand.commandInfo = {
    "type": "futureModelActionCommand",
    "targetType": "component",
    "event": "unknown :-)"
};

CommandManager.registerCommand(futuremodelactioncommand);

/** Set plugins
 * This command is needed because of a small philosophy difference between apogee and prosemirror
 * We need to set the editor view "plugins" on our editor state. The editor state itself is part of
 * the philosophy difference. Preferbly we woul donly store the doc in the component/app layer. But
 * we are doing this because it gives the best mapping between prosemirror transactions and 
 * apogee commands, which overall seems to be the best path to take, for now. 
 *
 * Command JSON format:
 * {
 *   "type":"literatePagePlugins",
 *   "componentId":(component id),
 *   "plugins":(plugins object (not a json))
 * }
 */ 
let literatepagesetstateplugins = {};

//=====================================
// Command Object
//=====================================

//no undo command here
//literatepagesetstatePlugins.createUndoCommand = function(workspaceManager,commandData) {}


literatepagesetstateplugins.executeCommand = function(workspaceManager,commandData) {
    let modelManager = workspaceManager.getMutableModelManager();
    let component = modelManager.getMutableComponentByComponentId(commandData.componentId);

    //note - component may not exist, in the case this was triggered by delete component
    if(component) {
        let oldEditorState = component.getEditorState();
        let plugins = commandData.plugins;

        let newEditorState = attachPluginsToEditorState(oldEditorState,plugins);

        component.setEditorState(newEditorState);
    }
};

literatepagesetstateplugins.commandInfo = {
    "type": "literatePagePlugins",
    "targetType": "component",
    "event": "updated"
};

CommandManager.registerCommand(literatepagesetstateplugins);

let movecomponent = {};

//=====================================
// Action
//=====================================


/** This creates the command. Both the initial and full names should be passed in 
 * even is they are the same. */
movecomponent.createUndoCommand = function(workspaceManager,commandData) {
    let modelManager = workspaceManager.getModelManager();
    var model = modelManager.getModel();
    var member = model.lookupMemberById(commandData.memberId);
    var parent = member.getParent(model);
    var oldMemberName = member.getName();
    
    var undoCommandJson = {};
    undoCommandJson.type = movecomponent.commandInfo.type;
    undoCommandJson.memberId = commandData.memberId;
    undoCommandJson.newMemberName = oldMemberName;
    undoCommandJson.newParentId = parent.getId();
    
    return undoCommandJson;
};

movecomponent.executeCommand = function(workspaceManager,commandData) {
    
    let modelManager = workspaceManager.getMutableModelManager();
    let model = modelManager.getMutableModel();

    var actionData = {};
    actionData.action = "moveMember";
    actionData.memberId = commandData.memberId;
    actionData.targetName = commandData.newMemberName;
    actionData.targetParentId = commandData.newParentId;

    let actionResult = doAction(model,actionData);
    if(!actionResult.actionDone) {
        throw new Error("Error moving member: " + actionResult.errorMsg);
    }
};

movecomponent.commandInfo = {
    "type": "moveComponent",
    "targetType": "component",
    "event": "updated"
};

CommandManager.registerCommand(movecomponent);

/** Open Workspace Command
 *
 * Command JSON format:
 * {
 *   "type":"openWorkspace",
 *   "workspaceJson":(workspace JSON),
 *   "fileMetadata":(file metadata)
 * }
 */ 
let openworkspace = {};

//=====================================
// Action
//=====================================

//NO UNDO FOR OPEN Workspace
//openworkspace.createUndoCommand = function(workspaceManager,commandData) {

openworkspace.executeCommand = function(workspaceManager,commandData) {
    workspaceManager.load(commandData.workspaceJson,commandData.fileMetadata);
};

openworkspace.commandInfo = {
    "type": "openWorkspace",
    "targetType": "workspace",
    "event": "created"
};

CommandManager.registerCommand(openworkspace);

/** This file contains some methods for creating commands to do updates for component members.
 * There are 
 */



/** This method can be called to create a undo function to return a member to the current state
 * following a code or data update. */
function getMemberStateUndoCommand(model, memberId) {
    
    var member = model.lookupMemberById(memberId);
    var command = {};
    
    if((member.isCodeable)&&(member.hasCode())) {
        //check if the current state has code set - if so, set the code for the undo function
        command.type = "saveMemberCode";
        command.argList = member.getArgList();
        command.functionBody = member.getFunctionBody();
        command.supplemental = member.getSupplementalCode();      
    }
    else {
        command.type = "saveMemberData";
        
        //here the object has data set. Check if an "alternate" data values was set - error, pending or invalid
        let state = member.getState();
        if(state == apogeeutil$1.STATE_ERROR) {
            //save a sngle error
            command.data = [member.getErrorMsg()];
            
        }
        else if(state == apogeeutil$1.STATE_INVALID) {
            //result is invalid - set value to invalid in undo
            command.data = apogeeutil$1.INVALID_VALUE;
        }
        else if(state == apogeeutil$1.STATE_PENDING) {
            //we have a pending promise. use it for the command
            commandData = member.getPendingPromise();
        }
        else {
            //normal data case
            command.data = member.getData();
        }
    }

    command.memberId = memberId;
    
    return command;
}




/** @private */
function getSaveDataAction(model,memberId,data) {

    var actionData = {};
    actionData.action = "updateData";
    actionData.memberId = memberId;
    actionData.data = data;
    return actionData;
}

function getSetCodeAction$1(model,memberId,argList,functionBody,supplementalCode,optionalClearCodeDataValue) {
     
    var actionData = {};

    if((optionalClearCodeDataValue != undefined)&&(functionBody == "")&&(supplementalCode == "")) {
        //special case - clear code
        actionData.action = "updateData";
        actionData.memberId = memberId;
        actionData.data = optionalClearCodeDataValue;
    }
    else {
        //standard case - edit code
        actionData.action = "updateCode";
        actionData.memberId = memberId;
        actionData.argList = argList;
        actionData.functionBody = functionBody;
        actionData.supplementalCode = supplementalCode;  
    }

    return actionData;
}

/** Save Member Data Command
 *
 * Command JSON format:
 * {
 *   "type":"saveMembeData",
 *   "memberId":(main member ID),
 *   "argList":(argument list json array),
 *   "functionBody":(function body)
 *   "supplementalCode":(supplementalCode code - optional)
 *   "clearCodeDataValue":(value to set data is code cleared - optional)
 * }
 */ 
let savemembercode = {};

//=====================================
// Action
//=====================================

savemembercode.createUndoCommand = function(workspaceManager,commandData) {
    let modelManager = workspaceManager.getModelManager();
    let model = modelManager.getModel();
    var undoCommandJson = getMemberStateUndoCommand(model,commandData.memberId); 
    return undoCommandJson;
};

savemembercode.executeCommand = function(workspaceManager,commandData) {
    
    let modelManager = workspaceManager.getMutableModelManager();
    let model = modelManager.getMutableModel();
    
    var actionData = getSetCodeAction$1(model,
        commandData.memberId,
        commandData.argList,
        commandData.functionBody,
        commandData.supplementalCode,
        commandData.clearCodeDataValue);
    
    var actionResult = doAction(model,actionData);
    if(!actionResult.actionDone) {
        throw new Error("Error saving member code: " + actionResult.errorMsg);
    }
};

savemembercode.commandInfo = {
    "type": "saveMemberCode",
    "targetType": "component",
    "event": "updated"
};

CommandManager.registerCommand(savemembercode);

/** Compound Update Member Command
*
* Command JSON format:
* {
*   "type":"saveMemberCompound",
*   "updateList": [
*          {    //for data update entry
*              "memberId": (member id),
*              "data": (member data value)
*          },
*          {    //for code update entry
*               "memberId": (member id),
 *              "argList":(argument list json array),
 *              "functionBody":(function body)
 *              "supplementalCode":(supplementalCode code - optional)
 *              "clearCodeDataValue":(value to set data is code cleared - optional)
*          }
*    ]
* }
*/


let savemembercompound = {};

savemembercompound.createUndoCommand = function(workspaceManager,commandData) {
    let modelManager = workspaceManager.getModelManager();
    let model = modelManager.getModel();

    let undoCommandJson = {};
    undoCommandJson.type = "saveMemberCompound";
    //each entry looks like the associated command, but with "type" removed
    undoCommandJson.updateList = commandData.updateList.forEach( updateEntry => {
        let childUndoUpdateEntry = getMemberStateUndoCommand(model,updateEntry.memberId);
        //the udpate entry is identical to he command without the type, so we will just delete it
        delete childUndoUpdateEntry.type;
        return childUndoUpdateEntry;
    }); 
    return undoCommandJson;
};

savemembercompound.executeCommand = function(workspaceManager,commandData) {
    let modelManager = workspaceManager.getMutableModelManager();
    let model = modelManager.getMutableModel();
    
    let actionData = {};
    actionData.action = "compoundAction";
    actionData.actions = commandData.updateList.map( updateEntry => {
        if(updateEntry.data != undefined) {
            return getSaveDataAction(model,
                updateEntry.memberId,
                updateEntry.data);
        }
        else if(updateEntry.functionBody != undefined) {
            return getSetCodeAction(model,
                updateEntry.memberId,
                updateEntry.argList,
                updateEntry.functionBody,
                updateEntry.supplementalCode,
                updateEntry.clearCodeDataValue);
        }
    });
    
    var actionResult = doAction(model,actionData);
    if(!actionResult.actionDone) {
        throw new Error("Error saving member data: " + actionResult.errorMsg);
    }
};

savemembercompound.commandInfo = {
    "type": "saveMemberCompound",
    "targetType": "component",
    "event": "updated"
};

CommandManager.registerCommand(savemembercompound);

/** Save Member Data Command
 *
 * Command JSON format:
 * {
 *   "type":"saveMemberData",
 *   "memberId":(main member Id),
 *   "data":(member data value)
 * }
 */ 
let savememberdata = {};

//=====================================
// Action
//=====================================

savememberdata.createUndoCommand = function(workspaceManager,commandData) {
    let modelManager = workspaceManager.getModelManager();
    let model = modelManager.getModel();
    var undoCommandJson = getMemberStateUndoCommand(model,commandData.memberId); 
    return undoCommandJson;
};

savememberdata.executeCommand = function(workspaceManager,commandData) {
    let modelManager = workspaceManager.getMutableModelManager();
    let model = modelManager.getMutableModel();
    
    var actionData = getSaveDataAction(model,commandData.memberId,commandData.data);
    
    var actionResult = doAction(model,actionData);
    if(!actionResult.actionDone) {
        throw new Error("Error saving member data: " + actionResult.errorMsg);
    }
};

savememberdata.commandInfo = {
    "type": "saveMemberData",
    "targetType": "component",
    "event": "updated"
};

CommandManager.registerCommand(savememberdata);

/** Update Component Command
 *
 * Command JSON format:
 * {
 *   "type":"updateComponent",
 *   "memberId":(main member ID),
 *   "updatedMemberProperties":(member property json),
 *   "updatedComponentProperties":(component property json)
 * }
 */ 
let updatecomponent = {};

//=====================================
// Command Object
//=====================================

updatecomponent.createUndoCommand = function(workspaceManager,commandData) {
    let modelManager = workspaceManager.getModelManager();
    let model = modelManager.getModel();
    var member = model.lookupMemberById(commandData.memberId);
    var componentId = modelManager.getComponentIdByMemberId(commandData.memberId);
    var component = modelManager.getComponentByComponentId(componentId);

    var originalMemberProperties = {};
    if(member.constructor.generator.readProperties) member.constructor.generator.readProperties(member,originalMemberProperties);
    var originalComponentProperties = {};
    if(component.readExtendedProperties) component.readExtendedProperties(originalComponentProperties);
    
    var undoMemberProperties;
    var undoComponentProperties;
    
    if(commandData.updatedMemberProperties) {
        undoMemberProperties = {};
        for(var propKey in commandData.updatedMemberProperties) {
            undoMemberProperties = originalMemberProperties[propKey];
        }
    }
    
    if(commandData.updatedComponentProperties) {
        undoComponentProperties = {};
        for(var propKey in commandData.updatedComponentProperties) {
            undoComponentProperties = originalComponentProperties[propKey];
        }
    }
    
    var undoCommandJson = {};
    undoCommandJson.type = updatecomponent.commandInfo.type;
    undoCommandJson.memberId = commandData.memberId;
    if(undoMemberProperties) undoCommandJson.updatedMemberProperties = undoMemberProperties;
    if(undoComponentProperties) undoCommandJson.updatedComponentProperties = undoComponentProperties;
    
    return undoCommandJson;
};

/** This method is used for updating property values from the property dialog. 
 * If there are additional property lines, in the generator, this method should
 * be extended to edit the values of those properties too. */
updatecomponent.executeCommand = function(workspaceManager,commandData) {
    
    let modelManager = workspaceManager.getMutableModelManager();
    //wait to get a mutable model instance only if we need it
    let model = modelManager.getModel();
    var member = model.lookupMemberById(commandData.memberId);
    var componentId = modelManager.getComponentIdByMemberId(commandData.memberId);
    var component = modelManager.getMutableComponentByComponentId(componentId);
    
    //create an action to update an member additional properties
    var memberGenerator = member.constructor.generator;
    let actionResult;
    if(memberGenerator.getPropertyUpdateAction) {
        var actionData = memberGenerator.getPropertyUpdateAction(member,commandData.updatedMemberProperties);  
        if(actionData) {
            //get a new, mutable model instance here
            model = modelManager.getMutableModel();
            actionResult = doAction(model,actionData);
            if(!actionResult.actionDone) {
                throw new Error("Error updating member properties: " + actionResult.errorMsg);
            }
        }
    }
 
    //update an component additional properties
    component.loadPropertyValues(commandData.updatedComponentProperties);
};

updatecomponent.commandInfo = {
    "type": "updateComponent",
    "targetType": "component",
    "event": "updated"
};

CommandManager.registerCommand(updatecomponent);

/** Update Link Command
 *
 * Command JSON format:
 * {
 *   "type":"updateLink",
 *   "entryType":(entry type),
 *   "oldUrl":(original url),
 *   "newUrl":(new url - optional),
 *   "newNickname":(new nickname - optional)
 * }
 */ 
let updatelink = {};


updatelink.createUndoCommand = function(workspaceManager,commandData) {
    var undoCommandJson = {};
    undoCommandJson.type = updatelink.commandInfo.type;
    
    undoCommandJson.entryType = commandData.entryType;
    undoCommandJson.oldUrl = commandData.newUrl;
    
    if(commandData.newUrl != commandData.oldUrl) undoCommandJson.newUrl = commandData.oldUrl;
    
    if(commandData.newNickname !== undefined) {
        //look up the pre-command entry (we change back gto this)
        var referenceManager = workspaceManager.getReferenceManager();
        var referenceEntry = referenceManager.lookupEntry(commandData.entryType,commandData.oldUrl);
        if((referenceEntry)&&(commandData.newNickname != referenceEntry.getNickname())) {
            undoCommandJson.newNickname = referenceEntry.getNickname();
        }
    }
    
    return undoCommandJson;
};

updatelink.executeCommand = function(workspaceManager,commandData) {
    let referenceManager = workspaceManager.getMutableReferenceManager();

    let refEntryId = referenceManager.lookupRefEntryId(commandData.entryType,commandData.oldUrl);
    if(!refEntryId) throw new Error("Reference entry not found. " + entryType + ":" + url);

    let referenceEntry = referenceManager.getMutableRefEntryById(refEntryId);
    if(!referenceEntry) throw new Error("Reference entry not found. refEntryId: " + refEntryId);

    //update entry
    let targetUrl = (commandData.newUrl !== undefined) ? commandData.newUrl : referenceEntry.getUrl();
    let targetNickname = (commandData.newNickname !== undefined) ? commandData.newNickname : referenceEntry.getNickname();
    referenceEntry.updateData(workspaceManager,targetUrl,targetNickname);

    referenceManager.registerRefEntry(referenceEntry);
};

updatelink.commandInfo = {
    "type": "updateLink",
    "targetType": "component",
    "event": "updated"
};

CommandManager.registerCommand(updatelink);

/** Update Workspace Command
 *
 * Command JSON format:
 * {
 *   "type":"updateWorkspace",
 *   "updatedCoreProperties":(member property json), //name only
 *   "updatedAppProperties":(component property json) //currently not used
 * }
 */ 
let updateworkspace = {};

//=====================================
// Action
//=====================================

updateworkspace.createUndoCommand = function(workspaceManager,commandData) {
    var undoCommandJson = {};
    undoCommandJson.type = updateworkspace.commandInfo.type;
    
    //right now we assume this is just a name update
    let modelManager = workspaceManager.getModelManager();
    let model = modelManager.getModel();
    undoCommandJson.updatedCoreProperties = {};
    undoCommandJson.updatedCoreProperties.name = model.getName();
    
    return undoCommandJson;
};

updateworkspace.executeCommand = function(workspaceManager,commandData) {
    
    let modelManager = workspaceManager.getMutableModelManager();
    let model = modelManager.getMutableModel();

    var actionResult;    
    var actionData;
    actionData = {};
    actionData.action = "updateModel";
    actionData.model = model;
    actionData.properties = commandData.updatedCoreProperties;

    actionResult = doAction(model,actionData);
    if(!actionResult.actionDone) {
        throw new Error("Error updating workspace: " + actionResult.errorMsg);
    }

    //update any workspace manager properties here - none for now
};

updateworkspace.commandInfo = {
    "type": "updateWorkspace",
    "targetType": "workspace",
    "event": "updated"
};

CommandManager.registerCommand(updateworkspace);

/** This class manages references for the web page.*/
class ReferenceEntry extends FieldObject {
    
    /** The reference data is a json entry with the referenceType, url and optionally nickname.
     * If this is a copy, the reference data wil be ignored and can be set to null. */
    constructor(referenceData,instanceToCopy,keepUpdatedFixed) {
        super("referenceEntry",instanceToCopy,keepUpdatedFixed);

        if(instanceToCopy) {
            this.referenceType = instanceToCopy.referenceType;
        }
        else {
            this.referenceType = referenceData.entryType;
        }

        //==============
        //Fields
        //==============
        //Initailize these if this is a new instance
        if(!instanceToCopy) {
            this.setField("url",referenceData.url);

            //we create in a pending state because the link is not loaded.
            this.setField("state",apogeeutil$1.STATE_PENDING);
            this.setField("stateMsg",PENDING_STATE_MSG);

            let nickname = referenceData.nickname;
            if(!nickname) nickname = this.createNickname(referenceData.url); 
            this.setField("nickname",nickname);
        }

        //==============
        //Working variables
        //==============
        this.viewStateCallback = null;
        this.cachedViewState = null;    
    }

    //---------------------------
    // references entry interface
    //---------------------------
    
    getEntryType() {
        return this.referenceType;
    }

    getState() {
        return this.getField("state");
    }

    getStateMsg() {
        return this.getField("stateMsg");
    }

    getUrl() {
        return this.getField("url");
    }

    getNickname() {
        return this.getField("nickname");
    }

    setViewStateCallback(viewStateCallback) {
        this.viewStateCallback = viewStateCallback;
    }

    getCachedViewState() {
        return this.cachedViewState;
    }



    ///////////////////////////////////////////////////////////////////////////

    /** This method loads the link onto the page. If passed, the onLoadComplete
     * callback will be called when load completes successfully or fails. */
    loadEntry(workspaceManager) {

        let entryLoadPromise = new Promise( (resolve,reject) => {

            //create load event handlers
            //on completion execute a command to update the link status
            let onLoad = () => {
                let commandData = {
                    type: "updateLinkLoadStatus",
                    entryType: this.referenceType,
                    url: this.getUrl(),
                    success: true
                };
                workspaceManager.getApp().executeCommand(commandData);
                //call resolve in any case
                resolve();
            };
            let onError = (error) => {
                //for osme on loads we get an event object with no error info
                //convert this to a string
                if(error instanceof Event) {
                    error = "Link load unsuccessful";
                }

                let commandData = {
                    type: "updateLinkLoadStatus",
                    entryType: this.referenceType,
                    url: this.getUrl(),
                    success: false,
                    error: error
                };
                workspaceManager.getApp().executeCommand(commandData);
                //call resolve in any case
                resolve();
            };

            this.implementationLoadEntry(onLoad,onError,workspaceManager);
        });

        return entryLoadPromise;
    }

    /** This method loads the link onto the page. It should call the 
     * appropriate callback on completion. */
    //implementationLoadEntry(onLoad,onError);
    
    /** This method removes the reference. It returns true if the link remove is successful. */
    //remove()
    
    
    ///////////////////////////////////////////////////////////////////////////

    /** This method loads the link onto the page. It returns a promise that
     * resolves when the link is loaded. */
    toJson() {
        var entryJson = {};
        entryJson.url = this.getUrl();
        if(this.nickname != NO_NICKNAME_EMPTY_STRING) entryJson.nickname = this.getNickname();
        entryJson.entryType = this.referenceType;
        return entryJson;
    }

    //-------------------------
    // Entry specific management methods
    //-------------------------

    /** This method removes and reloads the link, returning a promise. */
    updateData(workspaceManager,url,nickname) {

        //update nickname
        if(!nickname) nickname = NO_NICKNAME_EMPTY_STRING;
        if(this.nickname != nickname) {
            this.setField("nickname",nickname);
        }

        //update url
        if(this.url != url) {
            this.removeEntry();
            this.setField("url",url);
            var promise = this.loadEntry(workspaceManager);
        }

        //if we didn't do a URL update, make a promise that says update was successful
        if(!promise) promise = Promise.resolve({
            cmdDone: true,
            target: this,
            eventAction: "updated"
        });

        return promise;
    }

    //===================================
    // private methods
    //===================================

    setClearState() {
        this.setState(apogeeutil$1.STATE_NORMAL);
    }

    setError(errorMsg) {
        this.setState(apogeeutil$1.STATE_ERROR,errorMsg);
    }

    setPendingState() {
        this.setState(apogeeutil$1.STATE_PENDING,PENDING_STATE_MSG);
    }

    setState(state,msg) {
        let currentState = this.getField("state");
        let currentMessage = this.getField("stateMsg");
        if(currentState != state) {
            //for now we are not tracking msg. If we do, we should check for that change too
            this.setField("state",state);
        }
        if(currentMessage != msg) {
            //for now we are not tracking msg. If we do, we should check for that change too
            if(msg !== undefined) this.setField("stateMsg",msg);
            else this.clearField("stateMsg");
        }
    }

    createNickname(url) {
        let lastSeperatorIndex = url.lastIndexOf("/");
        if(lastSeperatorIndex == 0) return url.substr(0,MAX_AUTO_NICKNAME_LENGTH);

        let fileName = url.substr(lastSeperatorIndex+1);
        let queryStart = fileName.indexOf("?");
        if(queryStart > 0) {
            fileName = fileName.substring(0,queryStart);
        }
        if(fileName.length > MAX_AUTO_NICKNAME_LENGTH) {
            fileName = fileName.substring(0,MAX_AUTO_NICKNAME_LENGTH);
        }
        return fileName;
    }

}

//====================================
// Static Fields
//====================================

let MAX_AUTO_NICKNAME_LENGTH = 24;


ReferenceEntry.ELEMENT_ID_BASE = "__apogee_link_element_";

let NO_NICKNAME_EMPTY_STRING = "";

//=====================================
// Status Commands
// These are commands run to update the status of the link after loading completes
//=====================================

/*
 *
 * Command JSON format:
 * {
 *   "type":"updateLinkLoadStatus",
 *   "entryType":(entry type),
 *   "url":(url),
 *   "success":(boolean),
 *   "error":(error object or error string - optional. Only used in the success=false case)
 * }
 * 
 */ 

let updatelinkstatus = {};

//No undo command. Only the original call needs to be undone.
//updatelinkstatus.createUndoCommand = function(workspaceManager,commandData) {

updatelinkstatus.executeCommand = function(workspaceManager,commandData) {
    
    var commandResult = {};
    var referenceManager = workspaceManager.getMutableReferenceManager();
    
    //lookup entry for this reference
    let refEntryId = referenceManager.lookupRefEntryId(commandData.entryType,commandData.url);
    let referenceEntry = referenceManager.getMutableRefEntryById(refEntryId);
    if(referenceEntry) {
        //update entry status
        //add event handlers
        if(commandData.success) {
            commandResult.cmdDone = true;
            referenceEntry.setClearState();
        }
        else {
            var errorMsg = "Failed to load link '" + referenceEntry.getUrl() + "':" + commandData.error.toString();
            console.error(errorMsg);
            referenceEntry.setError(errorMsg);
        }

        //save the updated entry
        referenceManager.registerRefEntry(referenceEntry);
    }
    else {
        //reference entry not found
        throw new Error("Reference entry not found: " + commandData.url);
    }
    
    return commandResult;
};

updatelinkstatus.commandInfo = {
    "type": "updateLinkLoadStatus",
    "targetType": "referenceEntry",
    "event": "updated"
};

CommandManager.registerCommand(updatelinkstatus);


const PENDING_STATE_MSG = "loading...";

/* 
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
class EsModuleEntry extends ReferenceEntry {
    
    constructor(referenceList,referenceData) {
        super(referenceList,referenceData,EsModuleEntry.REFERENCE_TYPE_INFO);
    }
            
    /** This method loads the actual link. */
    implementationLoadEntry(onLoad,onError,workspaceManager) {
        let localOnLoad = (module) => {
            if(module) {
                if(module.initApogeeModule) module.initApogeeModule();
            
                let commandData = {
                    type: "setEsModule",
                    entryType: this.referenceType,
                    url: this.getUrl(),
                    module: module
                };
                workspaceManager.getApp().executeCommand(commandData);
                onLoad();
            }
            else {
                onError("Unknown error: Module not properly loaded. " + this.getUrl());
            }

        };

        //load the module
        var moduleLoadPromise = new Promise(function (resolve) { resolve(_interopNamespace(require(this.getUrl()))); }).then(localOnLoad).catch(onError);
    }
    
    /** This method removes the link. This returns a command result for the removed link. */
    removeEntry() {
        //allow for an optional module remove step
        let module = this.getField("module");
        if(module) {
            if(module.removeApogeeModule) module.removeApogeeModule();
            this.clearField("module");
        }
        return true;
    }
    
}

EsModuleEntry.REFERENCE_TYPE = "es module";

//=====================================
//Load Module Command
// These are commands run to update the status of the link after loading completes
//=====================================

/*
 *
 * Command JSON format:
 * {
 *   "type":"setEsModule",
 *   "entryType":(entry type),
 *   "url":(url),
 *   "module":(the module),
 * }
 * 
 */ 

let setesmodule = {};

//No undo command. Only the original call needs to be undone.
//setesmodule.createUndoCommand = function(workspaceManager,commandData) {

setesmodule.executeCommand = function(workspaceManager,commandData) {
    
    let referenceManager = workspaceManager.getMutableReferenceManager();

    let refEntryId = referenceManager.lookupRefEntryId(commandData.entryType,commandData.url);
    if(!refEntryId) throw new Error("Reference entry not found. " + commandData.entryType + ":" + commandData.url);

    let referenceEntry = referenceManager.getMutableRefEntryById(refEntryId);
    if(!referenceEntry) throw new Error("Reference entry not found. refEntryId: " + refEntryId);
    
    referenceEntry.setField("module",commandData.module);
};

setesmodule.commandInfo = {
    "type": "setEsModule",
    "targetType": "referenceEntry",
    "event": "updated"
};

CommandManager.registerCommand(setesmodule);

/* 
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
class NpmModuleEntry extends ReferenceEntry {
    
    constructor(referenceList,referenceData) {
        super(referenceList,referenceData,NpmModuleEntry.REFERENCE_TYPE_INFO);

    }

    /** This method loads the actual link. */
    implementationLoadEntry(onLoad,onError) {

        //synchronous loading
        try {
            let module = require(this.getUrl());
            if((module)&&(module.initApogeeModule)) module.initApogeeModule();
            this.setField("module",module);
            
            onLoad();
        }
        catch(error) {
            if(error.stack) console.error(error.stack);
            
            onError(errorMsg);
        }

    }
    
    /** This method removes the link. */
    removeEntry() {
        //allow for an optional module remove step
        let module = this.getField("module");
        if(module) {
            if(module.removeApogeeModule) module.removeApogeeModule();

            this.clearField("module");
        }
        
        //we aren't really removing it...
        //require.undef(this.url);

        return true;
    }
    
}

NpmModuleEntry.REFERENCE_TYPE = "npm module";

//---------------------------------
// Link Element Management - This manages DOM elements for links
//---------------------------------
class LinkLoader {
    /** 
     * This is a singleton and the constructor should not be called.
     * @private
     */
    constructor() {          
        this.scriptElements = [];
        this.cssElements = [];
        this.nextLinkCallerId = 1;
    }
    
    /** This returns a unique caller id which should bbe used when adding or removing
     * a link. This is done to allow mulitple callers to share a link.
     */
    createLinkCallerId() {
        return this.nextLinkCallerId++;
    }

    /** 
     * This method adds a link element to a page, supporting 'css' and 'script'. 
     * The caller identifer should be a unique identifier among people
     * requesting links of this given type. It cna be requested from
     * ReferenceEntry._createId
     * @protected
     */
    addLinkElement(type,url,linkCallerId,onLoad,onError) {
        try {
            var addElementToPage = false;
            var elementType;

            var elementList;
            if(type == "css") {
                elementList = this.cssElements;
                elementType = "link";
            }
            else if(type == "script") {
                elementList = this.scriptElements;
                elementType = "script";
            }
            else throw new Error("Unknown link type: " + type);

            var elementEntry = elementList[url];
            if(!elementEntry) {
                //create script element reference
                elementEntry = {};
                elementEntry.url = url;
                elementEntry.callerInfoList = [];

                //create script element
                var element = document.createElement(elementType);

                if(type == "css") {
                    element.href = url;
                    element.rel = "stylesheet";
                    element.type = "text/css";
                }
                else if(type == "script") {
                    element.src = url;
                }

                element.onload = () => {
                    elementEntry.callerInfoList.forEach(callerInfo => {if(callerInfo.onLoad) callerInfo.onLoad();});
                };
                element.onerror = (error) => {
                    elementEntry.callerInfoList.forEach(callerInfo => {if(callerInfo.onError) callerInfo.onError(error);});
                };

                elementEntry.element = element;
                elementList[url] = elementEntry;

                addElementToPage = true;  
            }

            //add this to the caller info only if it is not there
            if(!elementEntry.callerInfoList.some(callerInfo => (callerInfo.id == linkCallerId))) {
                var callerInfo = {};
                callerInfo.id = linkCallerId;
                if(onLoad) callerInfo.onLoad = onLoad;
                if(onError) callerInfo.onError = onError;

                elementEntry.callerInfoList.push(callerInfo);
            }

            if(addElementToPage) {
                document.head.appendChild(elementEntry.element);
            }
        }
        catch(error) {
            if(error.stack) console.error(error.stack);
            
            //error loading link  
            if(onError) {
                onError(error);
            }
            else {
                console.error(error.stack);
            }
        }

    }

    /** This method removes a link element from the page.
     * @protected */
    removeLinkElement(type,url,linkCallerId) {
        var elementList;
        if(type == "css") elementList = this.cssElements;
        else if(type == "script") elementList = this.scriptElements;
        else throw new Error("Unknown link type: " + type);

        var elementEntry = elementList[url];
        if(elementEntry) {
            //remove this caller from caller list
            elementEntry.callerInfoList = elementEntry.callerInfoList.filter(callerInfo => callerInfo.id != linkCallerId);

            //remove link if there are no people left using it
            if(elementEntry.callerInfoList.length === 0) {
                if(elementEntry.element) document.head.removeChild(elementEntry.element);
                delete elementList[url];
            }
        }
    }
}

//======================================
// static singleton methods
//======================================

/** @private */
let instance = null;

/** This retrieves the link loader instance. */
function getLinkLoader() {
    if(!instance) {
        instance = new LinkLoader();
    }
    return instance;
}

/* 
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
class JsScriptEntry extends ReferenceEntry {
    
    constructor(referenceList,referenceData) {
        super(referenceList,referenceData,JsScriptEntry.REFERENCE_TYPE_INFO);

    }

    /** This method loads the actual link. */
    implementationLoadEntry(onLoad,onError) {
        this.linkCallerId = getLinkLoader().createLinkCallerId();
        getLinkLoader().addLinkElement("script",this.getUrl(),this.getId(),onLoad,onError);
    }
    
    /** This method removes the link. */
    removeEntry() {
        getLinkLoader().removeLinkElement("script",this.getUrl(),this.getId());
        return true;
    }
    
    _getLinkCallerHandle() {
        return "JsScriptEntry-" + this.getId();
    }
}

JsScriptEntry.REFERENCE_TYPE = "js link";

/* 
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
class CssEntry extends ReferenceEntry {
    
    constructor(referenceList,referenceData) {
        super(referenceList,referenceData,CssEntry.REFERENCE_TYPE_INFO);
    }


    /** This method loads the actual link. */
    implementationLoadEntry(onLoad,onError) {
        this.linkCallerId = getLinkLoader().createLinkCallerId();
        getLinkLoader().addLinkElement("css",this.getUrl(),this.getId(),onLoad,onError);
    }

    
    /** This method removes the link. It returns true if the link is removed. */
    removeEntry() {
        getLinkLoader().removeLinkElement("css",this.getUrl(),this.getId());
        return true;
    }
}

CssEntry.REFERENCE_TYPE = "css link";

/** This file initializes the reference class types available. */

let referenceClassArray = [];
if(__APOGEE_ENVIRONMENT__ == "WEB") {
    referenceClassArray.push(EsModuleEntry);
    referenceClassArray.push(JsScriptEntry);
    referenceClassArray.push(CssEntry);
}
else if(__APOGEE_ENVIRONMENT__ == "NODE") {
    referenceClassArray.push(NpmModuleEntry);
}
else {
    console.log("Warning - apogee environment not recognized!");
}

ReferenceManager.setReferenceClassArray(referenceClassArray);

//This is a single module that exports the public items from the apogee app namespace

var apogeeapp = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Apogee: Apogee,
    BaseFileAccess: BaseFileAccess,
    Component: Component,
    FormInputBaseComponent: FormInputBaseComponent,
    componentInfo: componentInfo
});

/** This is the main apogeeapp ui file */
let uiutil = {};

/** This should be called to initializethe resource path. */
uiutil.initResourcePath = function(resourceDirectory) {
    uiutil.RESOURCE_DIR = resourceDirectory;
};

/** This retreives the resoruce path for a resource. */
uiutil.getResourcePath = function(relativePath) {
    return uiutil.RESOURCE_DIR + relativePath;
};

//I put some utilities in here. I shoudl figure out a better place to put this.

//======================================
// ID Generator
//======================================

uiutil.idIndex = 0;
uiutil.idBase = "_visiui_id_";

/** This method generates a generic id for dom elements. */
uiutil.createId = function() {
    return uiutil.idBase + uiutil.idIndex++;
};

//=========================================
// style methods
//=========================================

/** This method applies the style json to the dom element. */
uiutil.applyStyle = function(element,style) {
    for(var key in style) {
        element.style[key] = style[key];
    }
};

//=========================================
// resources
//=========================================

uiutil.MINIMIZE_CMD_IMAGE = "/minimize.png";
uiutil.RESTORE_CMD_IMAGE = "/restore.png";
uiutil.MAXIMIZE_CMD_IMAGE = "/maximize.png";
uiutil.CLOSE_CMD_IMAGE = "/close_gray.png";
uiutil.HAMBURGER_MENU_IMAGE = "/hamburger.png";
uiutil.DOT_MENU_IMAGE = "/menuDots16_darkgray.png";
uiutil.GENERIC_CELL_ICON = "/icons3/genericCellIcon.png";
uiutil.GENERIC_PAGE_ICON = "/icons3/pageIcon.png";

//=========================================
// dom methods
//=========================================


/** This method removes all the content from a DOM element. */
uiutil.removeAllChildren = function(element) {
	while(element.lastChild) {
		element.removeChild(element.lastChild);
	}
};

/** This method applies the style json to the dom element. All arguments
 * besides type are optional.
 * 
 * type is the element type
 * properties are javascript properties, 
 * styleProperties are the style properties
 * */
uiutil.createElement = function(type,properties,styleProperties) {
    var element = document.createElement(type);
    if(properties) {
        for(var key in properties) {
            element[key] = properties[key];
        }
    }
    if(styleProperties) {
        uiutil.applyStyle(element,styleProperties);
    }
    return element;
};

/** This method creates a DOM element of the given type, sets the class name
 * and, if present, adds it to the given parent. */
uiutil.createElementWithClass = function(elementType,className,parent) {
    var element = document.createElement(elementType);
    element.className = className;
    if(parent) parent.appendChild(element);
    return element;
};

//=========================================
// window and dialog methods
//=========================================

uiutil.dialogLayer = null;

uiutil.BASE_ELEMENT_STYLE = {
    "position":"absolute",
    "left":"0px",
    "right":"0px",
    "top":"0px",
    "bottom":"0px",
    "zIndex":1
};

uiutil.DIALOG_LAYER_STYLE = {
    "position":"absolute",
    "left":"0px",
    "right":"0px",
    "top":"0px",
    "bottom":"0px",
    "zIndex": 2,
    "pointerEvents": "none"
};

uiutil.DIALOG_SHIELD_STYLE = {
    "position":"absolute",
    "left":"0px",
    "right":"0px",
    "top":"0px",
    "bottom":"0px",
    "pointerEvents": "auto"
};
    
uiutil.initWindows = function(appElementId) {
    //create the ui elements from the app element
    var appContainer = document.getElementById(appElementId);
    if(!appContainer) {
        throw new Error("Container ID not found: " + appElementId);
    }
    
    var elements = {};
    elements.baseElement = uiutil.createElement("div",null,uiutil.BASE_ELEMENT_STYLE); 
    elements.dialogLayer = uiutil.createElement("div",null,uiutil.DIALOG_LAYER_STYLE);
    
    appContainer.appendChild(elements.baseElement);
    appContainer.appendChild(elements.dialogLayer);
    
    uiutil.dialogLayer = elements.dialogLayer;
    
    return elements;
};


/** This is a handler name used to request closing the window, tab or other UI element. */
uiutil.REQUEST_CLOSE = "request_close";
uiutil.DENY_CLOSE = -1;

uiutil.CLOSE_EVENT = "closed";
uiutil.RESIZED_EVENT = "resized";
uiutil.SHOWN_EVENT = "shown";
uiutil.HIDDEN_EVENT = "hidden";

/** This function adds CSS data for a given member id. */
uiutil.setObjectCssData = function(objectId,cssText) {
    var cssElementId = "css_" + objectId;
    
    var cssElement = document.getElementById(cssElementId);
    if(cssText != "") {
        if(!cssElement) {
            cssElement = document.createElement("style");
            cssElement.id = cssElementId;
            document.head.appendChild(cssElement);
        }
        cssElement.innerHTML = cssText;
    }
    else {
        if(cssElement) {
            document.head.removeChild(cssElement);
        }
    }
};

//======================================
//window content types
//These are types of content that can be put in a window or other container. If is it 
//resizable it can be fitted to the window size. If it is fixed size it can be 
//added to a scrolling window or used to set the container size
//======================================
uiutil.RESIZABLE = 0x01;
uiutil.FIXED_SIZE = 0x02;

uiutil.SCROLL_NONE = 0x00;
uiutil.SCROLL_VERTICAL = 0x01;
uiutil.SCROLL_HORIZONTAL = 0x02;
uiutil.SCROLL_BOTH = 0x03;


//this is not an actual content type, but an option for displaying FIXED_SIZE content
uiutil.SIZE_WINDOW_TO_CONTENT = 0x03;

/** This is a simple window frame component. It is movable but not resizable.
 *
 * @class 
 */
class DialogFrame {

    constructor() {
        
        //variables
        this.windowParent = null;
        this.parentElement = null;
        
        //set default size values
        this.posInfo = {};
        this.posInfo.x = 0;
        this.posInfo.y = 0;
        
        this.frame = null;
        this.headerBar = null;
        this.body = null;
        
        this.content = null;
        
        this.windowDragActive = false;
        this.moveOffsetX = null;
        this.moveOffsetY = null;
        
        this.moveOnMouseDown = null;
        //handlers we place on the parent during a move
        this.moveOnMouseMove = null; 
        this.moveOnMouseLeave = null;
        this.moveOnMouseUp = null;
        
        //initialize
        this.initUI();
    }


    //====================================
    // Public Methods
    //====================================


    /** This sets the content for the window. */
    setContent(contentElement) {
        uiutil.removeAllChildren(this.body);
        this.body.appendChild(contentElement);
        
        this.content = contentElement;
    }

    //---------------------------
    // WINDOW CHILD
    //---------------------------

    /** This method returns the parent container for the window.*/
    getParent() {
        return this.windowParent;
    }

    /** This method closes the window. */
    close() {
        this.headerBar.removeEventListener("mousedown",this.moveOnMouseDown);

        if(!this.windowParent) return;
        this.windowParent.removeWindow(this);
        this.windowParent = null;
    }

    /** This method moves the window if it starts going off the page. */
    verifyInView(windowSize) {
        if((!this.posInfo)||(!this.frame)) return;

        let centerX = this.posInfo.x + this.frame.clientWidth/2;
        let centerY = this.posInfo.y + this.frame.clientHeight/2;

        if( ((centerX > windowSize.x)&&(centerX > 0)) ||
            ((centerY > windowSize.y)&&(centerY > 0)) ) {
            this.centerInParent();
        }
    }

    /** This method sets the position of the window frame in the parent. */
    setPosition(x,y) {
        //don't let window be placed at a negative coord. We can lose it.
        if(x < 0) x = 0;
        if(y < 0) y = 0;
        this.posInfo.x = x;
        this.posInfo.y = y;
        
        this.updateCoordinates();
    }


    //---------------------------
    // GUI ELEMENT
    //---------------------------

    /** This method returns the main dom element for the window frame. */
    getElement() {
        return this.frame;
    }

    /** This method centers the window in its parent. it should only be called
     *after the window is shown. */
    centerInParent() {
        var coords = this.windowParent.getCenterOnPagePosition(this);
        this.setPosition(coords[0],coords[1]);
    }

    //================================
    // Internal
    //================================

    /** This method shows the window. This automatically called internally when the window is
     * added to the parent. */
    onAddedToParent(newWindowParent) {
        this.windowParent = newWindowParent;
        this.parentElement = newWindowParent.getOuterElement();
    }

    //====================================
    // Motion/Reseize Event Handlers and functions
    //====================================

    /** Mouse down handler for moving the window. */
    moveMouseDown(e) {
        if(this.parentElement) {
            this.windowDragActive = true;
            this.moveOffsetX = e.clientX - this.frame.offsetLeft;
            this.moveOffsetY = e.clientY - this.frame.offsetTop;
            
            //add move events to the parent, since the mouse can leave this element during a move
            this.parentElement.addEventListener("mousemove",this.moveOnMouseMove);
            this.parentElement.addEventListener("mouseleave",this.moveOnMouseLeave);
            this.parentElement.addEventListener("mouseup",this.moveOnMouseUp);
            
            //move start event would go here
        }
    }

    /** Mouse m,ove handler for moving the window. */
    moveMouseMoveImpl(e) {
        if(!this.windowDragActive) return;
        var newX = e.clientX - this.moveOffsetX;
        if(newX < 0) newX = 0;
        var newY = e.clientY - this.moveOffsetY;
        if(newY < 0) newY = 0;
        this.posInfo.x = newX;
        this.posInfo.y = newY;
        this.updateCoordinates();
    }

    /** Mouse up handler for moving the window. */
    moveMouseUpImpl(e) {
        this.endMove();
    }

    /** Mouse leave handler for moving the window. */
    moveMouseLeaveImpl(e) {
        this.endMove();
    }

    /** This method ends a move action. 
     * @private */
    endMove(e) {
        this.windowDragActive = false;
        this.parentElement.removeEventListener("mousemove",this.moveOnMouseMove);
        this.parentElement.removeEventListener("mouseup",this.moveOnMouseUp);
        this.parentElement.removeEventListener("mouseleave",this.moveOnMouseLeave);
    }

    /** @private */
    updateCoordinates() {
        this.frame.style.left = this.posInfo.x + "px";
        this.frame.style.top = this.posInfo.y + "px";
    }

    //====================================
    // Initialization Methods
    //====================================

    /** @private */
    initUI() {

        this.frame = document.createElement("div");
        this.frame.className = "visiui_dialog_main";

        this.headerBar = document.createElement("div");
        this.headerBar.className = "visiui_dialog_header";
        this.frame.appendChild(this.headerBar);

        //add mouse handlers for moving the window 
        this.moveOnMouseDown = (event) => {
            this.moveMouseDown(event);
        };
        //these are added only during a move
        this.moveOnMouseMove = (event) => {
            this.moveMouseMoveImpl(event);
        };
        this.moveOnMouseUp = (event) => {
            this.moveMouseUpImpl(event);
        };
        this.moveOnMouseLeave = (event) => {
            this.moveMouseLeaveImpl(event);
        };

        this.headerBar.addEventListener("mousedown",this.moveOnMouseDown);

        this.body = document.createElement("div");
        this.body.className = "visiui_dialog_body";
        this.frame.appendChild(this.body);
    }


}

/** This object is a container for window frames. The argument of the constructor should
 * be an element that will hold the window frames.  */
class WindowParent {

    constructor(containerElement) {       
        this.containerElement = containerElement;
        this.windowFrameStack = [];
        this.onResizeListener = () => this._onResize();
        window.addEventListener("resize",this.onResizeListener);
    }

    //==============================
    // Public Instance Methods
    //==============================

    close() {
        window.removeEventListener("resize",this.onResizeListener);
    }

    getOuterElement() {
        return this.containerElement;
    }

    /** This method adds a windows to the parent. It does not show the window. Show must be done. */
    addWindow(windowFrame) {
        this.containerElement.appendChild(windowFrame.getElement());
        this.windowFrameStack.push(windowFrame);
        windowFrame.onAddedToParent(this);
    }

    /** This method removes the window from the parent container. */
    removeWindow(windowFrame) {
        this.containerElement.removeChild(windowFrame.getElement());
        var index = this.windowFrameStack.indexOf(windowFrame);
        this.windowFrameStack.splice(index,1);
    }

    /** This method centers the dialog on the page. It must be called after the conten
     * is set, and possibly after it is rendered, so the size of it is calculated. */
    getCenterOnPagePosition(child) {
        var element = child.getElement();
        var x = (this.containerElement.offsetWidth - element.clientWidth)/2;
        var y = (this.containerElement.offsetHeight - element.clientHeight)/2;
        return [x,y];
    }

    //=============================
    // Privat Methods
    //=============================

    _onResize() {
        let windowSize = {x: window.innerWidth, y:window.innerHeight};
        this.windowFrameStack.forEach(childFrame => childFrame.verifyInView(windowSize));
    }

}

let dialogMgr = {};

/** This method creates a normal window which is situated above a shiled layer blocking
 *out events to the app, making the dialog like a modal dialog. If this function is used
 *to create a dialog, it must be closed with the dialogMgr.closeDialog function to
 *remove the modal layer, whether or not the dialog was shown. The options passed are the 
 *normal options for a window frame. (Note - if there are other events with whihc to act with
 *the app they may need to be shileded too.) */
dialogMgr.createDialog = function(options) {
    var dialog = new DialogFrame();
    return dialog;
};

dialogMgr.showDialog = function(dialog) {
    var shieldElement = uiutil.createElement("div",null,uiutil.DIALOG_SHIELD_STYLE);
    var dialogParent = new WindowParent(shieldElement);
    uiutil.dialogLayer.appendChild(shieldElement);

    dialogParent.addWindow(dialog);

    dialog.centerInParent();
};

/** This method closes a dialog created with createDialog. It
 *hides the window and removes the modal shiled. */
dialogMgr.closeDialog = function(dialog) {
    var parent = dialog.getParent();
    dialog.close();
    uiutil.dialogLayer.removeChild(parent.getOuterElement());
    parent.close();
};

/** This namespacve provides methods to create a status banner and icon overlay. */

//constants for the window banner bar
let bannerConstants = {};

bannerConstants.BANNER_TYPE_ERROR = apogeeutil$1.STATE_ERROR;
bannerConstants.BANNER_BGCOLOR_ERROR = "red";
bannerConstants.BANNER_FGCOLOR_ERROR = "white";
bannerConstants.ERROR_ICON_IMAGE = "/error.png";

bannerConstants.BANNER_TYPE_PENDING = apogeeutil$1.STATE_PENDING;
bannerConstants.BANNER_BGCOLOR_PENDING = "yellow";
bannerConstants.BANNER_FGCOLOR_PENDING = "black";
bannerConstants.PENDING_ICON_IMAGE = "/pending.png";

bannerConstants.BANNER_TYPE_INVALID = apogeeutil$1.STATE_INVALID;
bannerConstants.BANNER_BGCOLOR_INVALID = "gray";
bannerConstants.BANNER_FGCOLOR_INVALID = "white";
bannerConstants.INVALID_ICON_IMAGE = "/invalid.png";

bannerConstants.BANNER_BGCOLOR_UNKNOWN = "yellow";
bannerConstants.BANNER_FGCOLOR_UNKNOWN = "black";

bannerConstants.BANNER_TYPE_NONE = apogeeutil$1.STATE_NORMAL;

bannerConstants.PENDING_MESSAGE = "Calculation pending...";bannerConstants.INVALID_MESSAGE = "Result not valid!";

/** This method returns a banner for the given state and message. This should 
 * not be called for banner state bannerConstants.BANNER_TYPE_NONE */
function getBanner(text,bannerState) {
    
    //get banner colors and icon overlay resource
    var bgColor;
    var fgColor;
    if(bannerState == bannerConstants.BANNER_TYPE_INVALID) {
        bgColor = bannerConstants.BANNER_BGCOLOR_INVALID;
        fgColor = bannerConstants.BANNER_FGCOLOR_INVALID;
    }
    else if(bannerState == bannerConstants.BANNER_TYPE_ERROR) {
        bgColor = bannerConstants.BANNER_BGCOLOR_ERROR;
        fgColor = bannerConstants.BANNER_FGCOLOR_ERROR;
    }
    else if(bannerState == bannerConstants.BANNER_TYPE_PENDING) {
        bgColor = bannerConstants.BANNER_BGCOLOR_PENDING;
        fgColor = bannerConstants.BANNER_FGCOLOR_PENDING;
    }
    else {
        bgColor = bannerConstants.BANNER_BGCOLOR_UNKNOWN;
        fgColor = bannerConstants.BANNER_FGCOLOR_UNKNOWN;
    }
   
    //banner showing
    var bannerDiv = uiutil.createElement("div",null,
        {
            //"display":"block",
            //"position":"relative",
            //"top":"0px",
            "backgroundColor":bgColor,
            "color":fgColor
        });
    bannerDiv.innerHTML = text;
    
    return bannerDiv;
}

/** This method creates an icon overlay for a given banner state. This should 
 * not be called for banner state bannerConstants.BANNER_TYPE_NONE */
function getIconOverlay(bannerState,tooltip) {
    var resource;
    if(bannerState == bannerConstants.BANNER_TYPE_INVALID) {
        resource = bannerConstants.INVALID_ICON_IMAGE;
    }
    else if(bannerState == bannerConstants.BANNER_TYPE_ERROR) {
        resource = bannerConstants.ERROR_ICON_IMAGE;
    }
    else if(bannerState == bannerConstants.BANNER_TYPE_PENDING) {
        resource = bannerConstants.PENDING_ICON_IMAGE;
    }
    else {
        //unknown
        resource = null;
    }
    
    var iconOverlayElement = document.createElement("img");
    if(resource) {
        var url = uiutil.getResourcePath(resource);
        iconOverlayElement.src = url;
        if(tooltip) iconOverlayElement.title = tooltip;
    }
    return iconOverlayElement;
}

/** This is is a layout element to fill a parent element with a header element and
 * a display element which takes all the remaning vertical space.
 * 
 * The header and display types may be the following:
 * DisplayAndHeader.SCROLLING_PANE
 * DisplayAndHeader.FIXED_PANE
 * 
 * Additionally a CSS class may be specified for each fo give information such as
 * coloring and, for the sake of the header, height.
 */ 
class DisplayAndHeader {

    constructor(headerType,headerStyleClass,bodyType,bodyStyleClass) {
    //    this.container = uiutil.createElementWithClass("div","visiui-dnh-container");
    //    
    //    this.headerOuter = uiutil.createElementWithClass("div","visiui-dnh-header",this.container);
    //    this.header = uiutil.createElementWithClass("div","visiui-dnh-header-inner",this.headerOuter);
    //    this.bodyOuter = uiutil.createElementWithClass("div","visiui-dnh-body",this.container);
    //    this.body = uiutil.createElementWithClass("div","visiui-dnh-body-inner",this.bodyOuter);
    //    
    //    this.headerStyleClass = headerStyleClass;
    //    this.bodyStyleClass = bodyStyleClass;
    //    
    //    this.headerContent = document.createElement("div");
    //    this.header.appendChild(this.headerContent);
    //    this.bodyContent = document.createElement("div");
    //    this.body.appendChild(this.bodyContent);
        
        this.container = uiutil.createElementWithClass("table","visiui-dnh-container");
        
        this.headerOuter = uiutil.createElementWithClass("tr","visiui-dnh-header",this.container);
        this.header = uiutil.createElementWithClass("td","visiui-dnh-header-inner",this.headerOuter);
        this.bodyOuter = uiutil.createElementWithClass("tr","visiui-dnh-body",this.container);
        this.body = uiutil.createElementWithClass("td","visiui-dnh-body-inner",this.bodyOuter);
        
        this.headerStyleClass = headerStyleClass;
        this.bodyStyleClass = bodyStyleClass;
        
        this.headerContent = document.createElement("div");
        this.header.appendChild(this.headerContent);
        this.bodyContent = document.createElement("div");
        this.body.appendChild(this.bodyContent);
        
        //this.setHeaderType(headerType);
        this.setHeaderType("visiui-dnh-shrink-to-fit");
        this.setBodyType(bodyType);
    }

    /** this method sets the header type. */
    setHeaderType(headerType) {
        var headerClass = headerType;
        if(this.headerStyleClass) headerClass += " " + this.headerStyleClass;
        this.headerContent.className = headerClass;
    }

    /** this method sets the body type. */
    setBodyType(bodyType) {
        var bodyClass = bodyType;
        if(this.bodyStyleClass) bodyClass += " " + this.bodyStyleClass;
        this.bodyContent.className = bodyClass;
    }

    /** this method returns the DOM element for ths combined layout. */
    getOuterElement() {
        return this.container;
    }

    /** this method returns the content element for the header. */
    getHeaderContainer() {
        return this.header;
    }

    /** this method returns the content element for the display pane. */
    getBodyContainer() {
        return this.body;
    }

    /** this method returns the content element for the header. */
    getHeader() {
        return this.headerContent;
    }

    /** this method returns the content element for the display pane. */
    getBody() {
        return this.bodyContent;
    }

}

/** This is the pane type for a pane that scrolls in both X and Y, iv needed. */
DisplayAndHeader.FIXED_PANE = "visiui-dnh-fixed";

/** This is the pane type for a pane that does not scrolling, hiding any overflow. */
DisplayAndHeader.SCROLLING_PANE = "visiui-dnh-scrolling";

class Tab {

    constructor(id) {
        //mixin initialization
        this.eventManagerMixinInit();
        
        this.tabFrame = null;
        this.id = id;
        this.tabLabelElement = uiutil.createElementWithClass("div","visiui-tf-tab-base visiui-tf-tab-inactive");
        
        this.iconContainerElement = uiutil.createElementWithClass("div", "visiui-tf-tab-icon-container",this.tabLabelElement);
        this.icon = uiutil.createElementWithClass("img", "visiui-tf-tab-icon",this.iconContainerElement);
        this.iconOverlayElement = uiutil.createElementWithClass("div","visiui_tf_tab_icon_overlay",this.iconContainerElement);
        
        this.titleElement = uiutil.createElementWithClass("div","visiui_tf_tab_title",this.tabLabelElement);
        
        this.closeButton = uiutil.createElementWithClass("img","visiui_tf_tab_cmd_button",this.tabLabelElement);
        this.closeButton.src = uiutil.getResourcePath(uiutil.CLOSE_CMD_IMAGE);
        
        this.closeButton.onclick = () => {
            this.close();
        };
        
        //create the tab element
        this.displayFrame = uiutil.createElementWithClass("div","visiui-tf-tab-window");
        this.tabInsideContainer = new DisplayAndHeader(DisplayAndHeader.FIXED_PANE,
                null,
                DisplayAndHeader.FIXED_PANE,
                null
            );
        this.displayFrame.appendChild(this.tabInsideContainer.getOuterElement());
        
        this.headerContainer = this.tabInsideContainer.getHeaderContainer();
        this.bodyContainer = this.tabInsideContainer.getBodyContainer();
        
        this.isShowing = false;
    }

    //---------------------------
    // WINDOW CONTAINER
    //---------------------------

    /** This is called by the tab frame. */
    setTabFrame(tabFrame) {
        this.tabFrame = tabFrame;
        var instance = this;
        //attach to listeners to forward show and hide events
        this.tabShownListener = (tab) => {
            if(tab == instance) {
                this.isShowing = true;
                instance.dispatchEvent(uiutil.SHOWN_EVENT,instance);
            }
        };
        this.tabFrame.addListener(uiutil.SHOWN_EVENT, this.tabShownListener);
        this.tabHiddenListener = (tab) => {
            if(tab == instance) {
                this.isShowing = false;
                instance.dispatchEvent(uiutil.HIDDEN_EVENT,instance);
            }
        };
        this.tabFrame.addListener(uiutil.HIDDEN_EVENT, this.tabHiddenListener);
    }

    /** This sets the tab as the active tab. It returns true if it can do this. In the case
     * it does not have an active frame, it returns false. */
    makeActive() {
        if(this.tabFrame) {
            this.tabFrame.setActiveTab(this.id);
            return true;
        }
        else {
            return false;
        }
    }

    /** This method must be implemented in inheriting objects. */
    getId() {
        return this.id;
    }

    /** This returns true if the tab is showing in the display. */
    getIsShowing() {
        return this.isShowing;
    }

    /** This method must be implemented in inheriting objects. */
    setTitle(title) {
        this.titleElement.innerHTML = title;
        this.title = title;
    }

    /** This method shows the window. */
    setIconUrl(iconUrl) {
        if(!iconUrl) {
            iconUrl = uiutil.getResourcePath(uiutil.GENERIC_CELL_ICON);
        }

        this.icon.src = iconUrl; 
    }

    /** This sets the content for the window. If null (or otherwise false) is passed
     * the content will be set to empty.*/
    setHeaderContent(contentElement) {
        uiutil.removeAllChildren(this.headerContainer);
        if(contentElement) {
            this.headerContainer.appendChild(contentElement);
        }
    }

    /** This sets the content for the window. */
    setContent(contentElement) {
        if(!this.contentContainer) {
            this.contentContainer = uiutil.createElement("div");
            uiutil.removeAllChildren(this.bodyContainer);
            this.bodyContainer.appendChild(this.contentContainer);
        }
        this.contentContainer.className = "visiui_tf_tab_container";
        
        uiutil.removeAllChildren(this.contentContainer);
        this.contentContainer.appendChild(contentElement);
        
        this.content = contentElement;
    }

    /** This method must be implemented in inheriting objects. */
    getTitle() {
        return this.title;
    }

    /** This sets the given element as the icon overlay. If null or other [false} is passed
     * this will just clear the icon overlay. */
    setIconOverlay(element) {
        if(this.iconOverlayElement) {
            this.clearIconOverlay();
            if(element) {
                this.iconOverlayElement.appendChild(element);
            }
        }
    }

    clearIconOverlay() {
        if(this.iconOverlayElement) {
            uiutil.removeAllChildren(this.iconOverlayElement);
        }
    }

    /** This method closes the window. */
    close(forceClose) {
        if(!this.tabFrame) return;
        
        if(!forceClose) {
            //make a close request
            var requestResponse = this.callHandler(uiutil.REQUEST_CLOSE,this);
            if(requestResponse == uiutil.DENY_CLOSE) {
                //do not close the window
                return;
            }
        }
        
        this.tabFrame.closeTab(this.id);
        this.tabFrame.removeListener(uiutil.SHOWN_EVENT, this.tabShownListener);
        this.tabFrame.removeListener(uiutil.HIDDEN_EVENT, this.tabHiddenListener);
        this.tabFrame = null;
        
        this.dispatchEvent(uiutil.CLOSE_EVENT,this);
        
        
    }

    //---------------------------
    // GUI ELEMENT
    //---------------------------

    /** This method must be implemented in inheriting objects. */
    getMainElement() {
        return this.displayFrame;
    }

    /** This method must be implemented in inheriting objects. */
    getLabelElement() {
        return this.tabLabelElement;
    }

}

//add mixins to this class
apogeeutil$1.mixin(Tab,EventManager);

/** This is a tab frame.
 * 
 * @class 
 */
class TabFrame {

    constructor() {
        //mixin initialization
        this.eventManagerMixinInit();
        
        //variables
        this.tabTable = {};
        this.activeTab = null;
        
        this.tabFrameControl = uiutil.createElementWithClass("div","visiui-tf-frame");
        this.tabBar = uiutil.createElementWithClass("div","visiui-tf-tab-bar",this.tabFrameControl);
        this.tabFrame = uiutil.createElementWithClass("div","visiui-tf-tab-container",this.tabFrameControl);   	
    }

    /** This method returns the dom element for the control. */
    getElement() {
        return this.tabFrameControl;
    }

    /** This method returns the main dom element for the window frame. */
    getTab(id) {
        return this.tabTable[id];
    }

    /** This method adds a tab to the tab frame. */
    addTab(tab,makeActive) {
        var id = tab.getId();
        
        //make sure there is no tab with this name
        if(this.tabTable[id]) {
            alert("There is already a tab with this id!");
            return null;
        }
        
        tab.setTabFrame(this);
        this.tabFrame.appendChild(tab.getMainElement());
        
        var tabLabelElement = tab.getLabelElement();
        this.tabBar.appendChild(tabLabelElement);
        
        //add the click handler
        tabLabelElement.onclick = () => {
            this.setActiveTab(id);
        };
        tabLabelElement.onmousedown = (e) => {
            //this prevents text selection
            e.preventDefault();
        };
        
        //add to tabs
        this.tabTable[id] = tab;
        
        if((makeActive)||(this.activeTab == null)) {
            this.setActiveTab(id);
        }
        else {
            this.updateTabDisplay();
        }
    }

    /** This method adds a tab to the tab frame. */
    closeTab(id) {
        var tab = this.tabTable[id];
        if(tab) {
            this.tabFrame.removeChild(tab.getMainElement());
            
            var tabLabelElement = tab.getLabelElement();
            this.tabBar.removeChild(tabLabelElement);
            delete tabLabelElement.onclick;
            delete tabLabelElement.onmousedown;
            
            delete this.tabTable[id];
            
            if(this.activeTab == id) {
                this.dispatchEvent(uiutil.HIDDEN_EVENT,tab);
                this.activeTab = null;
                //choose a random tab
                for(var newId in this.tabTable) {
                    this.setActiveTab(newId);
                    break;
                }
            }
            
            this.updateTabDisplay();
        }
    }

    /** This gets the active tab, by tab id. */
    getActiveTab() {
        return this.activeTab;
    }

    /** This sets the active tab, by tab id. */
    setActiveTab(id) {
        var tab = this.tabTable[id];
        if(tab) {
            var oldTab;
            if(this.activeTab) {
                oldTab = this.tabTable[this.activeTab];
            }
            this.activeTab = id;
            this.tabFrame.appendChild(tab.getMainElement());
            this.updateTabDisplay();
            if(oldTab) {
                this.dispatchEvent(uiutil.HIDDEN_EVENT,oldTab);
            }
            this.dispatchEvent(uiutil.SHOWN_EVENT,tab);
            
        }
    }

    /** This gets the active tab, by tab id. */
    getOpenTabs() {
        var openTabs = [];
        for(var idString in this.tabTable) {
            var id = parseInt(idString);
            openTabs.push(id);
        }
        return openTabs;
    }

    /** This updates the tabs. */
    updateTabDisplay() {
        var id;
        for(id in this.tabTable) {
            var tab = this.tabTable[id];
            if(id == this.activeTab) {
                tab.getMainElement().style.display = "";
                tab.getLabelElement().className = "visiui-tf-tab-base visiui-tf-tab-active";
            }
            else {
                tab.getMainElement().style.display = "none";
                tab.getLabelElement().className = "visiui-tf-tab-base visiui-tf-tab-inactive";
            }
        }
    }

}

//add mixins to this class
apogeeutil$1.mixin(TabFrame,EventManager);

/** Thiis is a namespace with functions to control menu operation
 *
 * NOTE - the name Menu should probably be menu because this
 * is just a namespace and not a class, however when I converted this from a namespace
 * qualified by apogeeui, I didn't want to collide with local variables which are
 * often named "menu".
 *
 * @class 
 */
let Menu = {};

Menu.initialized = false;
Menu.activeMenu = null;

/** This method creates a static menu with the given text. */
Menu.createMenu = function(text) {

    //initialize menus, if needed
    if(!Menu.initialized) {
        Menu.initialize();
    }

    var labelElement = uiutil.createElementWithClass("div", "visiui-menu-label");
    labelElement.innerHTML = text;
    return new MenuHeader(labelElement);
};

/** This method creates a static menu from the given img url. */
Menu.createMenuFromImage = function(imageUrl) {

    //initialize menus, if needed
    if(!Menu.initialized) {
        Menu.initialize();
    }

    var imageElement = uiutil.createElementWithClass("img", "visiui-menu-label");
    imageElement.src = imageUrl;
    return new MenuHeader(imageElement);
};

/** This method creates a context menu object. */
Menu.createContextMenu = function() {

    //initialize menus, if needed
    if(!Menu.initialized) {
        Menu.initialize();
    }

    return new MenuBody();
};

Menu.showContextMenu = function(menuBody,contextEvent) {
    //create menu and attach to document body
    menuBody.setPosition(contextEvent.clientX, contextEvent.clientY, document.body);
    //cacnel default popup
    contextEvent.preventDefault();
    //show
    Menu.show(menuBody);
};

Menu.menuHeaderPressed = function(menuHeader) {
	//if there is an active menu, pressing that header closes the active menu otherwise show the menu
	if(Menu.activeMenu === menuHeader) {
		//active menu - close the menu
		Menu.hideActiveMenu();
	}
	else {
		//no active menu, open this menu
		Menu.show(menuHeader.getMenuBody());
	}
};

Menu.globalPress = function(event) {
    if(event.target.classList.contains("visiui-menu-item")) {
        //menu item click - handled in menu item
        return;
    }
    else if(event.target.classList.contains("visiui-menu-label")) {
        //menu header clicked - handled in menu header
        return;
    }
    else {
        //if the mouse is pressed outside the menu, close any active menu
        if(Menu.activeMenu) {
            Menu.hideActiveMenu();
        }
    }
};

Menu.discardMenu = function(menuHeader) {

};

//================================
// Internal
//================================

Menu.show = function(menuBody) {
	if(Menu.activeMenu) {
		Menu.hideActiveMenu();
	}
	var parentElement = menuBody.getParentElement();
    menuBody.prepareShow();
    var menuElement = menuBody.getMenuElement();
    if((parentElement)&&(menuElement)) {
        parentElement.appendChild(menuElement);
        Menu.activeMenu = menuBody;
        //set the header to active
        var menuHeader = menuBody.getMenuHeader();
        if((menuHeader)&&(menuHeader.domElement)) {
            menuHeader.domElement.className = "visiui-menu-heading visiui-menu-heading-active";
        }
    }
};

Menu.hideActiveMenu = function() {
	if(Menu.activeMenu) {
        var activeMenu = Menu.activeMenu;
        //set the header to normal (not active)
        var menuHeader = activeMenu.getMenuHeader();
        if((menuHeader)&&(menuHeader.domElement)) {
            menuHeader.domElement.className = "visiui-menu-heading";
        }
        
        var parentElement = activeMenu.getParentElement();
        var menuElement = activeMenu.getMenuElement();
        if((parentElement)&&(menuElement)) {
            parentElement.removeChild(menuElement);
            Menu.activeMenu = null;
        }
        activeMenu.menuHidden();
	}
};

Menu.nonMenuMouseHandler = null;

Menu.initialize = function() {
	window.addEventListener("mousedown",Menu.globalPress);
	Menu.initialized = true;
};

/** This method allows you to undo the initialization actions. I am not sure you would ever need to do it. */
Menu.deinitialize = function() {
	window.removeEventListener("mousedown",Menu.globalPress);
	Menu.initialized = false;
};

//##################################################################################################


/** This is a menu component
 * This class shoudl only be constructed internally the Menu namespace. 
 * Before it is constructed, the Menu should be initialized.
 *
 * @class 
 */
class MenuBody {

    constructor() {
        
        //variables
        this.menuDiv = null;
        this.parentElement = null;
        
        this.menuItems = {};
        
        //construct the menu
        this.createMenuElement();
        
        //this will be set if it is a static menu
        this.menuHeader = null;
    }

    /** this returns the dom element for the menu object. */
    getMenuElement() {
        return this.menuDiv;
    }

    /** This returns the parent element for the menu.  */
    getParentElement() {
        return this.parentElement;
    }

    /** This returns the parent element for the menu.  */
    getMenuHeader() {
        return this.menuHeader;
    }

    /** This returns the parent element for the menu.  */
    getIsContext() {
        return (this.menuHeader == null);
    }

    /** This is called before the menu body is shown */
    prepareShow() {
        if(this.isOnTheFlyMenu) {
            this.constructItemsForShow();
        }
    }

    /** This is called after the menu body is hidden. */
    menuHidden() {
        if(this.isOnTheFlyMenu) {
            this.destroyItemsForHides();
        }
    }

    /** This method is used to attach the menu to the menu head, in a static menu. */
    attachToMenuHeader(menuHeader) {
        //attach menu to heading
        this.parentElement = menuHeader.getElement();
        this.menuDiv.style.left = "0%";
        this.menuDiv.style.top = "100%";
        this.menuHeader = menuHeader;
    }

    /** This method is used to set the position for a context menu. The x and y coordinates
     * should be the coordinates in the parent element. It is recommended to use the 
     * document body. */
    setPosition(x, y, parentElement) {
        this.parentElement = parentElement;
    
        //we need to calculate the size, so I add and remove it - there is probably another way
        parentElement.appendChild(this.menuDiv);
        var parentWidth = parentElement.offsetWidth;
        var parentHeight = parentElement.offsetHeight;
        var menuWidth = this.menuDiv.clientWidth;
        var menuHeight = this.menuDiv.clientHeight;
        parentElement.appendChild(this.menuDiv);

        //position
        if((x + menuWidth > parentWidth)&&(x > parentWidth/2)) {
            this.menuDiv.style.left = (x - menuWidth) + "px";
        }
        else {
            this.menuDiv.style.left = x + "px";
        }
        if((y + menuHeight > parentHeight)&&(y > parentHeight/2)) {
            this.menuDiv.style.top = (y - menuHeight) + "px";
        }
        else {
            this.menuDiv.style.top = y + "px";
        }
    }

    /** This sets a callback to create the menu when the menu is opened. This is
     * for static menus where we do not want to populate it ahead of time. */
    setAsOnTheFlyMenu(menuItemsCallback) {
        this.isOnTheFlyMenu = true;
        this.menuItemsCallback = menuItemsCallback;
    }

    /** this adds a menu item that dispatchs the given event when clicked. */
    addEventMenuItem(title, eventName, eventData, eventManager) {
        var itemInfo = {};
        itemInfo.title = title;
        itemInfo.eventName = eventName;
        itemInfo.eventData = eventData;
        itemInfo.eventManager = eventManager;
        this.addMenuItem(itemInfo);
    }

    /** this adds a menu item that dispatchs the given event when clicked. */
    addCallbackMenuItem(title, callback) {
        var itemInfo = {};
        itemInfo.title = title;
        itemInfo.callback = callback;
        this.addMenuItem(itemInfo);
    }
        
    /** this adds a menu item that dispatchs the given event when clicked. */
    addMenuItem(itemInfo) {
        itemInfo.element = uiutil.createElementWithClass("div","visiui-menu-item");
        itemInfo.element.innerHTML = itemInfo.title;
        
        if(itemInfo.childMenuItems) {
            //create a parent menu item
            var childMenuBody = this.createChildMenuBody(itemInfo.childMenuItems);
            itemInfo.childMenuBody = childMenuBody;
            var childMenuDiv = childMenuBody.getMenuElement();
            childMenuDiv.style.left = "100%";
            childMenuDiv.style.top = "0%";
            itemInfo.element.appendChild(childMenuDiv);
        }
        else {
            //create a norman (clickable) menu item
            itemInfo.element.onclick = (event) => {
                //close menu
                Menu.hideActiveMenu();

                //do menu action
                if(itemInfo.eventName) {
                    //dispatch event
                    itemInfo.eventManager.dispatchEvent(itemInfo.eventName,itemInfo.eventData);
                }
                else if(itemInfo.callback) {
                    //use the callback
                    itemInfo.callback();
                }
            };
        }
        
        this.menuDiv.appendChild(itemInfo.element);
        this.menuItems[itemInfo.title] = itemInfo;
    }

    /** this adds a menu item that dispatchs the given event when clicked. */
    setMenuItems(itemInfos) {
        for(var i = 0; i < itemInfos.length; i++) {
            this.addMenuItem(itemInfos[i]);
        }
    }

    /** this adds a menu item that dispatchs the given event when clicked. */
    removeMenuItem(title) {
        var itemInfo = this.menuItems[title];
        if(itemInfo) {
            //clean up the dom elements
            if(itemInfo.childMenuBody) {
                itemInfo.childMenUBody.removeAllMenuItems();
            }
            else {
                itemInfo.element.onclick = null;
            }

            this.menuDiv.removeChild(itemInfo.element);
            delete this.menuItems[title];
        }
    }

    /** this adds a menu item that dispatchs the given event when clicked. */
    removeAllMenuItems() {
        for(var title in this.menuItems) {
            this.removeMenuItem(title);
        }
    }

    //================================
    // Internal
    //================================

    /** This method creates the menu body that is shown below the header. */
    createMenuElement() {
        this.menuDiv = uiutil.createElementWithClass("div","visiui-menu-body");
    }

    constructItemsForShow () {
        if(this.menuItemsCallback) {
            var menuItems = this.menuItemsCallback();
            this.setMenuItems(menuItems);
        }
    }

    /** This is called after the menu body is hidden. */
    destroyItemsForHides() {
        if(this.menuDiv) {
            uiutil.removeAllChildren(this.menuDiv);
        }
        this.menuItems = {};
    }

    createChildMenuBody(menuItems) {
        var childMenuBody = new MenuBody();
        childMenuBody.setMenuItems(menuItems);
        return childMenuBody;
    }

    destroy() {
        for(let key in this.menuItems) {
            itemInfo = this.menuItems[key];

            if(itemInfo.childMenuItems) {
                //create a parent menu item
                var childMenuBody = this.createChildMenuBody(itemInfo.childMenuItems);
                var childMenuDiv = childMenuBody.getMenuElement();
                childMenuDiv.style.left = "100%";
                childMenuDiv.style.top = "0%";
                itemInfo.element.appendChild(childMenuDiv);
            }
        }
    }

}

//###########################################################################################################

/** This is a menu component, attached to the given dom element
 * This class shoudl only be constructed internally the Menu namespace. 
 * Before it is constructed, the Menu should be initialized.
 *
 * @class 
 */
class MenuHeader {

    constructor(labelElement) {
        
        //variables
        this.labelElement = labelElement;
        this.domElement = uiutil.createElementWithClass("div", "visiui-menu-heading");
        this.domElement.appendChild(this.labelElement);
        this.menuBody = new MenuBody();

        //construct the menu
        this.labelElement.onmousedown = (e) => {
            Menu.menuHeaderPressed(this);
        };
   
        //attach menu to heading
        this.menuBody.attachToMenuHeader(this);
    }

    /** this returns the dom element for the menu heading. */
    getElement() {
        return this.domElement;
    }

    /** this returns the dom element for the menu heading. */
    setChildLocation(childLocation) {
        this.childLocation = childLocation;
    }

    /** this returns the dom element for the menu heading. */
    getChildLocation() {
        return this.childLocation;
    }

    /** this returns the dom element for the menu object. */
    getMenuBody() {
        return this.menuBody;
    }

    /** this adds a menu item that dispatchs the given event when clicked. */
    addEventMenuItem(title, eventName, eventData, eventManager) {
        this.menuBody.addEventMenuItem(title,eventName, eventData, eventManager);
    }

    /** this adds a menu item that dispatchs the given event when clicked. */
    addCallbackMenuItem(title, callback) {
        this.menuBody.addCallbackMenuItem(title,callback);
    }

    /** this adds a menu item that dispatchs the given event when clicked. */
    addMenuItem(itemInfo) {
        this.menuBody.addMenuItem(itemInfo);
    }

    /** this adds a menu item that dispatchs the given event when clicked. */
    setMenuItems(itemInfos) {
        this.menuBody.setMenuItems(itemInfos);
    }

    /** this adds a menu item that dispatchs the given event when clicked. */
    removeMenuItem(title) {
        this.menuBody.removeMenuItem(title);
    }

    /** this adds a menu item that dispatchs the given event when clicked. */
    removeAllMenuItems() {
        this.menuBody.removeAllMenuItems();
    }

    /** This sets a callback to create the menu when the menu is opened. This is
     * for static menus where we do not want to populate it ahead of time. */
    setAsOnTheFlyMenu(getMenuItemsCallback) {
        this.menuBody.setAsOnTheFlyMenu(getMenuItemsCallback);
    }

    destroy() {
        if(this.labelElement) this.labelElement.onmousedown = null;
        this.labelElement = null;
        this.domElement = null;
        if(this.menuBody) this.menuBody.removeAllMenuItems();
        this.menuBody = null;
    }

}

/** This is a split pane, with a right and left pane. The types of pane are 
 * given by the constants defined below:
 * SplitPane.SCROLLING_PANE
 * SplitPane.FIXED_PANE
 */ 
class SplitPane {

    constructor(leftPaneType,rightPaneType) {
        //mixin initialization
        this.eventManagerMixinInit();

        //-----------------
        // Create the DOM elements
        //-----------------
        
        this.container1 = uiutil.createElementWithClass("div","visiui-sp-parent");
        var container2 = uiutil.createElementWithClass("div","visiui-sp-parent2",this.container1);
        var table = uiutil.createElementWithClass("table","visiui-sp-table",container2);
        
        var row = uiutil.createElementWithClass("tr","visiui-sp-row",table);
        
        var leftCell = uiutil.createElementWithClass("td","visiui-sp-left",row);
        var divider = uiutil.createElementWithClass("td","visiui-sp-divider",row);
        var rightCell = uiutil.createElementWithClass("td","visiui-sp-right",row);

        var leftInnerPane = uiutil.createElementWithClass("div","visiui-sp-inner",leftCell);
        this.leftOuterPane = uiutil.createElementWithClass("div",leftPaneType,leftInnerPane);
        
        var rightInnerPane = uiutil.createElementWithClass("div","visiui-sp-inner",rightCell);
        this.rightOuterPane = uiutil.createElementWithClass("div",rightPaneType,rightInnerPane);

        //-----------------
        // Create the mouse handler logic for resizing
        //-----------------
        var resizeActive = false;
        var resizeBasePixels = 0;
        var resizeBasePosition = 0;
        
        //mouse down handler
        var mouseDown = function(e) {

                resizeActive = true;
                resizeBasePixels = e.clientX;
                resizeBasePosition = leftCell.offsetWidth;

                //add resize events to the parent, since the mouse can leave this element during a move
                table.addEventListener("mouseup",mouseUp);
                table.addEventListener("mousemove",mouseMove);
                table.addEventListener("mouseleave",mouseLeave);
        };

        //mouse move handler
        var mouseMove = (e) => {
            if(resizeActive) {
                var delta = e.clientX - resizeBasePixels;
                leftCell.style.width = (resizeBasePosition + delta) + "px";
                this.dispatchEvent("move",this);
            }
        };

        //mouse up handler
        var mouseUp = function(e) {
            endResize();
        };

        //mouse leave handler
        var mouseLeave = function(e) {
            endResize();
        };
        
        //end resize function
        var endResize = function() {
            resizeActive = false;
            table.removeEventListener("mouseup",mouseUp);
            table.removeEventListener("mousemove",mouseMove);
            table.removeEventListener("mouseleave",mouseLeave);
        };
        
        divider.addEventListener("mousedown",mouseDown);

    }

    /** this method returns the DOM element for ths split pane. */
    getOuterElement() {
        return this.container1;
    }

    /** this method returns the content element for the left pane. */
    getLeftPaneContainer() {
        return this.leftOuterPane;
    }

    /** this method returns the content element for the left pane. */
    getRightPaneContainer() {
        return this.rightOuterPane;
    }

}

//add mixins to this class
apogeeutil$1.mixin(SplitPane,EventManager);

/** This is the pane type for a pane that scrolls in both X and Y, iv needed. */
SplitPane.SCROLLING_PANE = "visiui-sp-scrolling";

/** This is the pane type for a pane that does not scrolling, hiding any overflow. */
SplitPane.FIXED_PANE = "visiui-sp-fixed";

class TreeControl {

    constructor() {
        this.list = uiutil.createElementWithClass("ul","visiui-tc-child-list",this.element); 
    }

    /** The outer DOM element */
    getElement() {
        return this.list;
    }

    setRootEntry(treeEntry) {
        this.clearRootEntry();
        this.list.appendChild(treeEntry.getElement());
    }

    clearRootEntry() {
        uiutil.removeAllChildren(this.list);
    }

}

class TreeEntry {

    constructor(labelText,iconSrc,clickCallback,menuItemCallback,isRoot) {
        
        // this.contractUrl = uiutil.getResourcePath("/opened_bluish.png");
        // this.expandUrl = uiutil.getResourcePath("/closed_bluish.png");
        // this.noControlUrl = uiutil.getResourcePath("/circle_bluish.png");
        // this.emptyControlUrl = uiutil.getResourcePath("/circle_bluish.png");
        this.contractUrl = uiutil.getResourcePath("/opened_darkgray.png");
        this.expandUrl = uiutil.getResourcePath("/closed_darkgray.png");
        this.noControlUrl = uiutil.getResourcePath("/circle_darkgray.png");
        this.emptyControlUrl = uiutil.getResourcePath("/circle_darkgray.png");
        
        this.isRoot = isRoot;
        
        var baseCssClass;
        if(isRoot) {
            baseCssClass = "visiui-tc-root";
        }
        else {
            baseCssClass = "visiui-tc-child";
        }
        
        this.element = uiutil.createElementWithClass("li", baseCssClass);
        this.control = uiutil.createElementWithClass("img", "visiui-tc-control",this.element);

        if(clickCallback) {
            this.mainContent = uiutil.createElementWithClass("a", "visiui-tc-main-content-link",this.element);
            this.mainContent.href = "#";
            this.mainContent.onclick = () => {
                clickCallback();
                return false;
            };
        }
        else {
            this.mainContent = uiutil.createElementWithClass("div", "visiui-tc-main-content-div",this.element);
        }

        //icon/menu
        if(!iconSrc) {
            iconSrc = uiutil.getResourcePath(uiutil.GENERIC_CELL_ICON);
        }

        this.iconContainerElement = uiutil.createElementWithClass("div", "visiui-tc-icon-container",this.mainContent);
        this.icon = uiutil.createElementWithClass("img", "visiui-tc-icon",this.iconContainerElement);
        this.icon.src = iconSrc; 
        this.iconOverlayElement = uiutil.createElementWithClass("div","visiui_tc_icon_overlay",this.iconContainerElement);
        
        //label
        this.label = uiutil.createElementWithClass("div", "visiui-tc-label",this.mainContent);
        if(labelText) {
            this.setLabel(labelText);
        }

        //menu
        if(menuItemCallback) {
            let menuImage = uiutil.getResourcePath(uiutil.DOT_MENU_IMAGE);
            this.menu = Menu.createMenuFromImage(menuImage);
            this.menu.setAsOnTheFlyMenu(menuItemCallback);
            let menuElement = this.menu.getElement();
            //update the style of the menu element
            menuElement.style.verticalAlign = "middle";
            this.element.appendChild(menuElement);
        }
        
        this.childContainer = null;
        this.childEntries = [];
        this.parent = null;
        this.sortFunction = null;
        this.extraSortParam = null;
        
        //set the non-empty state for in case we get children
        //but for now it will be empty
        this.nonEmptyState = TreeEntry.DEFAULT_STATE;
        this.setState(TreeEntry.NO_CONTROL);
    }

    /** The outer DOM element */
    getElement() {
        return this.element;
    }

    /** This sets a sort function for the children of the node. If none is set the
     * children will be sorted by the order they are added. */
    setSortFunction(sortFunction) {
        this.sortFunction = sortFunction;
    }

    /** The label for the entry. */
    setLabel(labelText) {
        this.labelText = labelText;
        this.label.innerHTML = labelText;
        if(this.parent) {
            this.parent._notifyNameChange(this);
        }
    }

    /** The label for the entry. */
    getLabel() {
        return this.labelText;
    }

    /** This allows for specified ordering of the chidlren. */
    setExtraSortParam(value) {
        this.extraSortParam = value;
    }

    /** This allows for specified ordering of the chidlren. */
    getExtraSortParam() {
        return this.extraSortParam;
    }

    addChild(childTreeEntry) {
        this.childEntries.push(childTreeEntry);
        this._insertChildIntoList(childTreeEntry);
        childTreeEntry._setParent(this);
    }

    removeChild(childTreeEntry) {
        if(this.childContainer) {
            var index = this.childEntries.indexOf(childTreeEntry);
            if(index >= 0) {
                this.childEntries.splice(index,1);
                this._removeChildFromList(childTreeEntry);
                childTreeEntry._setParent(null);
            }
        }
    }

    getState() {
        return this.state;
    }

    setState(state) {
        //if we have no children, always make the state no control
        //but we will store the state below for latert
        if((!this.childContainer)||(this.childContainer.length == 0)) {
            this.state = TreeEntry.NO_CONTROL;
        }
        else {
            this.state = state;
        }
        
        //save this as the non-empty state if it is not no control
        if(state != TreeEntry.NO_CONTROL) {
            this.nonEmptyState = state;
        }
        
        //configure the state
        if(this.state == TreeEntry.NO_CONTROL) {
            if(this.isRoot) {
                this.control.src = this.emptyControlUrl;
            }
            else {
                this.control.src = this.noControlUrl;
            }
            this.control.classList.remove("visiui-tc-control_interactive");
        }
        else if(this.state == TreeEntry.EXPANDED) {
            this.control.src = this.contractUrl;
            
            if(!this.collapse) {
                this.collapse = () => {
                    this.setState(TreeEntry.COLLAPSED);
                };
            }
            
            this.control.onclick = this.collapse;
            this.childContainer.style.display = "";
            this.control.classList.add("visiui-tc-control_interactive");
        }
        else if(this.state == TreeEntry.COLLAPSED) {
            this.control.src = this.expandUrl;
            
            if(!this.expand) {
                this.expand = () => {
                    this.setState(TreeEntry.EXPANDED);
                };
            }
            
            this.control.onclick = this.expand;
            this.childContainer.style.display = "none";
            this.control.classList.add("visiui-tc-control_interactive");
        }
    }

    /** This sets the given element as the icon overlay. If null or other [false} is passed
     * this will just clear the icon overlay. */
    setIconOverlay(element) {
        this.clearIconOverlay();
        if(element) {
            this.iconOverlayElement.appendChild(element);
        }
    }

    clearIconOverlay() {
        uiutil.removeAllChildren(this.iconOverlayElement);
    }

    setBannerState(bannerState,tooltip) {
        var iconOverlay = getIconOverlay(bannerState,tooltip);
        if(iconOverlay) {
            this.setIconOverlay(iconOverlay);
        }
        else {
            this.clearIconOverlay();
        }
    }

    //=====================================
    // Private
    //=====================================

    /** I want to make sure people don't do this themselves. It is done in add/remove child. 
     * @private */
    _setParent(parent) {
        this.parent = parent;
    }

    /** I want to make sure people don't do this themselves. It is done in add/remove child. 
     * @private */
    _insertChildIntoList(childEntry) {
        if(!this.childContainer) {
            //add the child list if it does not exist
            this.childContainer = uiutil.createElementWithClass("ul","visiui-tc-child-list",this.element); 
            this.setState(this.nonEmptyState);
        }
        
        if(this.sortFunction) {
            this._updateChildElements();
        }
        else {
            this.childContainer.appendChild(childEntry.getElement());
        }
    }

    /** I want to make sure people don't do this themselves. It is done in add/remove child. 
     * @private */
    _removeChildFromList(childEntry) {
        this.childContainer.removeChild(childEntry.getElement());
        
        //remove the child list if there are no children
        if(this.childContainer.childElementCount === 0) {
            this.element.removeChild(this.childContainer);
            this.childContainer = null;
            //set state to empty, but save our old setting
            this.nonEmtpyState = this.state;
            this.setState(TreeEntry.NO_CONTROL); 
        }
    }

    /** I want to make sure people don't do this themselves. It is done in add/remove child. 
     * @private */
    _notifyNameChange(childEntry) {
        if(this.sortFunction) {
            this._updateChildElements();
        }
    }

    /** This sets the children elements in the sorted order 
     * @private */
    _updateChildElements() {
    var temp = this.childEntries.map( element => element);
    temp.sort(this.sortFunction);
    uiutil.removeAllChildren(this.childContainer);
    temp.forEach(child => this.childContainer.appendChild(child.getElement()));

    }    

}


TreeEntry.NO_CONTROL = 0;
TreeEntry.EXPANDED = 1;
TreeEntry.COLLAPSED = -1;

TreeEntry.DEFAULT_STATE = TreeEntry.EXPANDED;

let ConfigurablePanelConstants = {};

ConfigurablePanelConstants.STATE_NORMAL = "normal";
ConfigurablePanelConstants.STATE_DISABLED = "disabled";
ConfigurablePanelConstants.STATE_HIDDEN = "hidden";
ConfigurablePanelConstants.STATE_INACTIVE = "inactive";

ConfigurablePanelConstants.DEFAULT_SUBMIT_LABEL = "OK";
ConfigurablePanelConstants.DEFAULT_CANCEL_LABEL = "Cancel";

ConfigurablePanelConstants.SELECTOR_ACTION_NORMAL_INACTIVE = "normalInactive"; //element is either active or inactive (meaning not showing and value not reported for form)
ConfigurablePanelConstants.SELECTOR_ACTION_NORMAL_HIDDEN = "normalHidden"; //element is either active or hidden(meaning not showing but value is reported for form)
ConfigurablePanelConstants.SELECTOR_ACTION_NORMAL_DISABLE = "normalDisabled"; //element is either active or disabled (meaning showing and value is reported, but element can not be set by user)
ConfigurablePanelConstants.SELECTOR_ACTION_VALUE = "value"; //element value is set to true or false depending on selector condition

ConfigurablePanelConstants.DEFAULT_SELECTOR_ACTION = ConfigurablePanelConstants.SELECTOR_ACTION_NORMAL_INACTIVE; 

ConfigurablePanelConstants.SELECTOR_FALSE_STATE = {
    "normalInactive": ConfigurablePanelConstants.STATE_INACTIVE,
    "normalHidden": ConfigurablePanelConstants.STATE_HIDDEN,
    "normalDisabled": ConfigurablePanelConstants.STATE_DISABLED
};

/** This function wraps a given content element so it has a tooltip. 
  * Argments:
  * - contentElement - the DOM element to wrap
  * - text - the tooltip text
  * - options - an object with these possible keys, all optional:
  * -- wrapperAddonClass - This is a class to add to the wrapper element, such as to modify positioning
  * -- textAddonClass - This is a class to add to the text element
  * -- textWidth - This allows the user to set the desired width of the text element. 
  * Return Value:
  * An object with the following keys:
  * - wrapperElement - The outside element
  * - textElement - the text element. This is returned to allow modification if desired.
  */
function wrapWithTooltip(contentElement,text,options) {
    let tooltipWrapper = document.createElement("div");
    tooltipWrapper.className = "apogee_tooltip_element";
    let tooltipText = document.createElement("div");
    tooltipText.className = "apogee_tooltip_text";
    tooltipText.innerHTML = text;
    tooltipWrapper.appendChild(contentElement);
    tooltipWrapper.appendChild(tooltipText);

    //add options
    if(options) {
        if(options.wrapperAddonClass) tooltipWrapper.classList.add(options.wrapperAddonClass);
        if(options.textAddonClass) tooltipText.classList.add(options.textAddonClass);
        if(options.textWidth) tooltipText.style.width = options.textWidth;
    }

    return {wrapperElement: tooltipWrapper, textElement: tooltipText};
}

 /** This function creates a help image with a tooltip.  
  * Argments:
  * - text - the help text
  * - options - These are the same options as in the function wrapWithTooltip with one added entry:
  * -- imageAddonClass - This is a class to add to the image element
  * Return Value:
  * An object with the following keys:
  * - wrapperElement - The outside element
  * - textElement - the text element. This is returned to allow modification if desired.
  * - imgElement - the 'help' image element
  */
function getHelpElement(helpText,options) {
    let helpIconUrl = uiutil.getResourcePath(HELP_ICON_PATH);
    let helpImgElement = document.createElement("img");
    helpImgElement.className = "apogee_tooltip_help_image";
    if(options) {
        if(options.imageAddonClass) helpImgElement.classList.add(options.imageAddonClass);
    }
    helpImgElement.src = helpIconUrl;
    let elements = wrapWithTooltip(helpImgElement,helpText,options);
    elements.imgElement = helpImgElement;
    return elements;
}

const HELP_ICON_PATH = "/helpIcon_darkGray.png";

/** This is an element that composes the content of a configurable panel.
 * 
 * @class 
 */
class ConfigurableElement {
    constructor(form,elementInitData) {
        this.form = form;
        this.state = ConfigurablePanelConstants.STATE_NORMAL;
        this.key = elementInitData.key;
        this.meta = elementInitData.meta;
        this.selectorConfig = elementInitData.selector;
        this.isMultiselect = false;
        this.focusElement = null;

        this.onChangeListeners = [];
        this.onInputListeners = [];

        this.domElement = uiutil.createElement("div",{"className":ConfigurableElement.CONTAINER_CLASS});
        //explicitly set the margin and padding
        this.domElement.style.margin = ConfigurableElement.ELEMENT_MARGIN_STANDARD;
        this.domElement.style.padding = ConfigurableElement.ELEMENT_PADDING_STANDARD;
        this.domElement.style.display = ConfigurableElement.ELEMENT_DISPLAY_FULL_LINE;

        this.errorDiv;

        this.visibleDisplayStyle = ConfigurableElement.ELEMENT_DISPLAY_FULL_LINE;
    }
    
    /** This method returns the key for this ConfigurableElement within this panel. */
    getKey() {
        return this.key;
    }

    /** This method returns the configured meta value for this element. */
    getMeta() {
        return this.meta;
    }

    /** This method returns value for this given element, if applicable. If not applicable
     * this method returns undefined. */
    getValue() {
        return undefined;
    }  

    /** This method updates the value for a given element. See the specific element
     * to see if this method is applicable. */
    setValue(value) {
        this.setValueImpl(value);
        this.valueChanged(true);
    }
    
    getState() {
        return this.state;
    }

    /** This hides or shows the given element within the panel. */
    setState(state) {
        this.state = state;
        switch(state) {
            case ConfigurablePanelConstants.STATE_NORMAL:
                this._setVisible(true);
                this._setDisabled(false);
                break;
                
            case ConfigurablePanelConstants.STATE_DISABLED:
                this._setVisible(true);
                this._setDisabled(true);
                break;
                
            case ConfigurablePanelConstants.STATE_HIDDEN:
                this._setVisible(false);
                break;
                
            case ConfigurablePanelConstants.STATE_INACTIVE:
                this._setVisible(false);
                break;
        }
        
    }

    /** This function attempts to give focus to the element. It will return true if element successfullly got focus. */
    giveFocus() {
        if((this.state == ConfigurablePanelConstants.STATE_NORMAL)&&(this.focusElement)) {
            this.focusElement.focus();
            return (document.activeElement == this.focusElement);
        }
        else {
            return false;
        }
    }

    /** This method returns the DOM element for this configurable element. */
    getElement() {
        return this.domElement;
    }
    
    /** This method returns the parent form for this configurable element. */
    getForm() {
        return this.form;
    }

    getBaseForm() {
        return this.form.getBaseForm();
    }

    addOnChange(onChange) {
        this.onChangeListeners.push(onChange);
    }

    addOnInput(onInput) {
        this.onInputListeners.push(onInput);
    }

    /** This is used to determine what type of child element this is for a panel. */
    get elementType() {
        return "ConfigurableElement";
    }

    /** This method is called during configuration to populate the selectors of the element. */
    populateSelectors() {
        if(this.selectorConfig) {
            try {
                this._addSelector(this.selectorConfig);
            }
            catch(error) {
                let errorMsg = "Error calling selector: " + error.toString();
                console.error(errorMsg);
                if(error.stack) console.error(error.stack);
                this.setElementErrorMsg(errorMsg);
            }
        }
    }

    //==================================
    //protected methods
    //==================================

    /** If the element returns multiple selected values, such as a checkbox group, then isMultiselect
     * should be set to true. The default is false. */
    setIsMultiselect(isMultiselect) {
        this.isMultiselect = isMultiselect;
    }

    /** This method should be implemented by extending to set the value for the element. The method 
     * "valueChanged" does not need to be called. It is called automatically. */
    setValueImpl(value) {}

    /** This method should be called when the value changes. Here value changed refers to a completed
     * input. For example typing a character a text field should not trigger this event, only the update 
     * of the value of a given field. */
    valueChanged() {
        if(this.onChangeListeners.length > 0) {
            let value =this.getValue();
            this.onChangeListeners.forEach( listener => listener(value,this.form));
        }
    }

    /** This method should be called input is done at the user interface. Thiw is should be called when typing
     * characters in a text field or when changing an element such as a checkbox. */
    inputDone() {
        if(this.onInputListeners.length > 0) {
            let value =this.getValue();
            this.onInputListeners.forEach( listener => listener(value,this.form));
        }
    }

    /** This function should be used to set the display state for the element, since that variable
     * is also used to control visibility. */
    setVisibleDisplayStyle(visibleDisplayStyle) {
        this.visibleDisplayStyle = visibleDisplayStyle;
        if((this.domElement)&&(this.domElement.style.display != "none")) {
            this.domElement.style.display = this.visibleDisplayStyle;
        }
    }

    /** This method should be called by extending methods to set the focus element, if there is one. */
    setFocusElement(focusElement) {
        this.focusElement = focusElement;
    }

    /** This cleans up the element. It should be extended to do any additional cleanup in an extending class. */
    destroy() {
        this.form = null;
        this.onChangeListeners = [];
        this.onInputListeners = [];
        this.domElement = null;
        this.focusElement  = null;
    }

    /** This function creates a label element and returns it if the element init data defines a label.
     * Otherwise it returns null. */
    getLabelElement(elementInitData) {
        if(elementInitData.label) {
            let labelElement = document.createElement("span");
            labelElement.className = "apogee_configurablePanelLabel apogee_configurableElement_hideSelection";
            labelElement.innerHTML = elementInitData.label;
            return labelElement;
        }
        else {
            return null;
        }
    }

    getHelpElement(elementInitData) {
        if(elementInitData.help) {
            //note - the funciton below is the imported one, not the class member function
            let options = {
                wrapperAddonClass: "apogee_configurableElementHelpWrapperAddon",
                textAddonClass: "apogee_configurableElementHelpTextAddon"
            };
            if(elementInitData.help.length > 24) {
                options.textWidth = "300px";
            }
            let helpElements = getHelpElement(elementInitData.help,options);
            helpElements.wrapperElement.classList.add("apogee_configurableElementHelpAddon");
            return helpElements.wrapperElement;
        }
        else {
            return null;
        }
    }

    /** This function creates a label element and returns it if the element init data defines a label.
     * Otherwise it returns null. */
    getHintElement(elementInitData) {
        if(elementInitData.hint) {
            let hintElement = document.createElement("span");
            hintElement.className = "apogee_configurablePanelHint";
            hintElement.innerHTML = elementInitData.hint;
            return hintElement;
        }
        else {
            return null;
        }
    }

    /** This sets the content of a div that displays an error mesage */
    setElementErrorMsg(errorMsg) {
        if(!this.errorDiv) {
            //add an error display
            this.errorDiv = document.createElement("div");
            this.errorDiv.className = "apogee_configubleElementErrorDiv";
            this.domElement.append(this.errorDiv);
        }
        this.errorDiv.innerHTML = errorMsg;
    }
    
    //===================================
    // internal Methods
    //==================================
    
    /** This method does standard initialization which requires the element be created. 
     * Any extending method should call this at the end of the constructor. */
    _postInstantiateInit(elementInitData) {
        
        //standard fields
        if(elementInitData.value !== undefined) {
            this.setValue(elementInitData.value);
        }
        
        var state = (elementInitData.state != undefined) ? elementInitData.state : ConfigurablePanelConstants.STATE_NORMAL;
        this.setState(state);
        
        //standard events
        if(elementInitData.onChange) {
            this.addOnChange(elementInitData.onChange);
        }
        if(elementInitData.onInput) {
            this.addOnInput(elementInitData.onInput);
        }
    }
    
    _setDisabled(isDisabled) {};
    
    _setVisible(isVisible) {
        if(!this.domElement) return;

        if(isVisible) {
            this.domElement.style.display = this.visibleDisplayStyle;
        }
        else {
            this.domElement.style.display = "none";
        }
    }

    /** This processes a selector entry from the init data */
    _addSelector(selectorConfig) {

        //get parent element list
        let parentKeys = selectorConfig.parentKey ? [selectorConfig.parentKey] : selectorConfig.parentKeys;
        if(!parentKeys) throw new Error("Parent key(s) not found for selectable child element " + selectorConfig.key);
        let parentElements = parentKeys.map( parentKey => {
            if(Array.isArray(parentKey)) {
                //absolute path
                let baseForm = this.getBaseForm();
                return baseForm.getEntryFromPath(parentKey);
            }
            else {
                //local key in form
                return this.form.getEntry(parentKey);

            }
        });
        if(parentElements.indexOf(undefined) >= 0) throw new Error("Parent element not found for selectable child element " + selectorConfig.key);

        
        //get the internal function
        let actionFunction;
        if(selectorConfig.actionFunction) {
            actionFunction = selectorConfig.actionFunction;
        }
        else {
            actionFunction = this._getPredefinedActionFunction(selectorConfig,parentElements);
        }
        if(!actionFunction) throw new Error("Action function not found for selectable child element " + selectorConfig.key);

        //handler
        let functionArgs = [this].concat(parentElements);
        let onValueChange = () => actionFunction.apply(null,functionArgs);
        
        if(onValueChange) {
            parentElements.forEach(parentElement =>parentElement._addDependentCallback(onValueChange));
        }
    }

    /** This method gets an instance of a predefined action function for the given selector config. */
    _getPredefinedActionFunction(selectorConfig,parentElements) {

        //these only apply to single parent objects, not multiple parents
        let inputParentElement = parentElements[0];

        //get the action
        let action = selectorConfig.action;
        if(!action) action = ConfigurablePanelConstants.DEFAULT_SELECTOR_ACTION;

        //get the target values. This can be a single value of a list of values
        let target, targetIsMultichoice;
        if(selectorConfig.parentValue !== undefined) {
            target = selectorConfig.parentValue;
            targetIsMultichoice = false;
        }
        else if(selectorConfig.parentValues !== undefined) {
            target = selectorConfig.parentValues;
            targetIsMultichoice = true;
        }
        else {
            throw new Error("A child selectable element must contain a value or list of values: " + selectorConfig.key)
        }

        //get the match check function
        //handle cases of potential multiple target values and multiple select parents
        let valueMatch;
        if(inputParentElement.isMultiselect) {
            if(targetIsMultichoice) {
                valueMatch = parentValue => containsCommonValue(target,parentValue);
            }
            else {
                valueMatch = parentValue => (parentValue.indexOf(target) >= 0);
            }
        }
        else {
            if(targetIsMultichoice) {
                valueMatch = parentValue => (target.indexOf(parentValue) >= 0);
            }
            else {
                valueMatch = parentValue => (parentValue == target);
            }
        }
        
        //this is the function that will do the test at compare time
        return (childElement,parentElement) => {
            let match = valueMatch(parentElement.getValue());
            if(action == ConfigurablePanelConstants.SELECTOR_ACTION_VALUE) {
                if(childElement.getValue() !== match) {
                    childElement.setValue(match);
                }
            }
            else {
                let state; 
                if(match) {
                    state = ConfigurablePanelConstants.STATE_NORMAL;
                }
                else {
                    state = ConfigurablePanelConstants.SELECTOR_FALSE_STATE[action];
                }
                if(childElement.getState() != state) {
                    childElement.setState(state);
                }
            }
        }
    }

    /** This function adds a callback that came from config element initialization */
    _addDependentCallback(onValueChange) {
        if(!this.dependentCallbacks) {
            this._initForDependents();
        }
        this.dependentCallbacks.push(onValueChange);

        //call now to initialize state
        try {
            onValueChange();
        }
        catch(error) {
            let errorMsg = "Error calling selector: " + error.toString();
            console.error(errorMsg);
            if(error.stack) console.error(error.stack);
            this.setElementErrorMsg(errorMsg);
        }
    }

    /** This function calls all the onValueChange callbacks for dependent elements. */
    _callDependentCallbacks() {
        if(this.dependentCallbacks) {
            try {
                this.dependentCallbacks.forEach( onValueChange => onValueChange() );
            }
            catch(error) {
                let errorMsg = "Error calling selector: " + error.toString();
                console.error(errorMsg);
                if(error.stack) console.error(error.stack);
                this.setElementErrorMsg(errorMsg);
            }
        }
    }

    _initForDependents() {
        this.dependentCallbacks = [];
        this.addOnChange( (value,form) => this._callDependentCallbacks() );
    }
            
}

ConfigurableElement.CONTAINER_CLASS = "apogee_configurablePanelLine";

ConfigurableElement.ELEMENT_MARGIN_STANDARD = "0px";
ConfigurableElement.ELEMENT_MARGIN_NONE = "0px";
ConfigurableElement.ELEMENT_PADDING_STANDARD = "4px";
ConfigurableElement.ELEMENT_PADDING_NONE = "0px";
ConfigurableElement.ELEMENT_DISPLAY_FULL_LINE = "block";
ConfigurableElement.ELEMENT_DISPLAY_PARTIAL_LINE = "inline-block";
ConfigurableElement.ELEMENT_DISPLAY_INVISIBLE = "none";

//================
//Other functions
//================

/**This function checks if the two array share any common values. */
function containsCommonValue(array1,array2) {
    return array1.some( value => (array2.indexOf(value) >= 0) );
}

/** This is a heading element configurable element.
 * 
 * @class 
 */
class ErrorElement extends ConfigurableElement {

    constructor(form,elementInitData,error) {
        super(form,DUMMY_INIT);
        
        var containerElement = this.getElement();
        
        let errorMsg = error.toString();
        let initData;
        try {
            initData = elementInitData ? JSON.stringify(elementInitData,null,"\t") : NO_INIT_DATA_MSG;
        }
        catch {
            initData = NO_INIT_DATA_MSG;
        }

        containerElement.style.color = "red";
        containerElement.style.border = "1px dashed red";
        containerElement.style.fontSize = ".8em";
        containerElement.innerHTML = `<b>Error<b>: ${errorMsg}<br><pre>${initData}</pre>`;
    }

}

let DUMMY_INIT = {
    type: "error"
};

const NO_INIT_DATA_MSG = "-- init data not available --";

ErrorElement.TYPE_NAME = "error";

/** This is a panel with forma elements that can be configured using a javascript object.
 * 
 * @class 
 */
class ConfigurablePanel {
    
    constructor() {
        this.elementObjects = [];
        this.layouts = [];
        this.panelDomElement = this.createPanelDomElement(ConfigurablePanel.PANEL_CLASS_NORMAL); 
    }

    configureForm(formInitData) {
        //first create form
        this.createForm(formInitData);
        //selectors must be initialized after complete form is created
        this.populateSelectors();
    }
    
    createForm(formInitData) {
        
        //TEMPORARY - legacy check correction----------------------
        if((formInitData)&&(formInitData.constructor == Array)) {
            formInitData = {layout:formInitData};
        }
        //---------------------------------------------------------
        
        //check for an invalid input
        if(formInitData === apogeeutil.INVALID_VALUE) {
            formInitData = ConfigurablePanel.getErrorMessageLayoutInfo("Form Data Unavailable");
        }
        else if((!formInitData)||(!formInitData.layout)||(formInitData.layout.constructor != Array)) {
            formInitData = ConfigurablePanel.getErrorMessageLayoutInfo("Invalid form layout!");
        }
        
        //clear data
        uiutil.removeAllChildren(this.panelDomElement);
        this.elementObjects = [];
        
        try {
            //create elements     
            formInitData.layout.forEach(elementInitData => this.addToPanel(elementInitData));

            // //add selectors
            // this.elementObjects.forEach(elementObject => {
            //     elementObject.initSelector();
            // }); 

            //additional init
            if(formInitData.onChange) {
                this.addOnChange(formInitData.onChange);
            }

            if(formInitData.onSubmitInfo) {
                this.addSubmit(formInitData.onSubmitInfo.onSubmit,
                    formInitData.onSubmitInfo.onCancel,
                    formInitData.onSubmitInfo.submitLabel,
                    formInitData.onSubmitInfo.cancelLabel);
            }

            if(formInitData.disabled) {
                this.setDisabled(true);
            }
        }
        catch(error) {
            var errorMsg = "Error in panel: " + error.toString();
            if(error.stack) console.error(error.stack);
            
            //display an error layout
            //but only try this once. If the error layout throws an error jsut continue
            if(!formInitData.isErrorLayout) {
                var errorLayoutInfo = ConfigurablePanel.getErrorMessageLayoutInfo(errorMsg);
                this.configureForm(errorLayoutInfo);
            }
        }
    }

    /** This returns the meta value for the panel. */
    getMeta() {
        //create the meta value
        let meta = {};
        this.elementObjects.forEach(elementObject => {
            let childMeta = elementObject.getMeta();
            let childKey = elementObject.getKey();
            if((childMeta)&&(childKey)) {
                meta[childKey] = childMeta;
            }
        });
        return meta;
    }

    /** This method returns the data value object for this given panel. */
    getValue() {
        var formValue = {};
        var addValue = elementObject => {
            if(elementObject.getState() != ConfigurablePanelConstants.STATE_INACTIVE) {
                var elementValue = elementObject.getValue();
                if(elementValue !== undefined) {
                    var key = elementObject.getKey();
                    formValue[key] = elementValue;
                }
            }
        };
        this.elementObjects.forEach(addValue);
        return formValue;
    }
    
    /** This method returns the data value object for this given panel. */
    setValue(formValue) {
        for(var key in formValue) {
            var entry = this.getEntry(key);
            if(entry) {
                entry.setValue(formValue[key]);
            }
        }
    }
    
    getElement() {
        return this.panelDomElement;
    }
    
    getChildEntries() {
        return this.elementObjects;
    }

    /** This element will give focus to the first element which can hold the focus. */
    giveFocus() {   
        for(let i = 0; i < this.elementObjects.length; i++) {
            let element = this.elementObjects[i];
            if(element.giveFocus()) return true;
        }
        return false;
    }
    
    /** This is an alternate way to add a submit entry to the form. This is useful
     * if the layout has no other handlers in it and is a pure JSON object. This 
     * will then separate out any handlers from the layout. */
    addSubmit(onSubmit,
            onCancel,
            optionalSubmitLabel = ConfigurablePanelConstants.DEFAULT_SUBMIT_LABEL,
            optionalCancelLabel = ConfigurablePanelConstants.DEFAULT_CANCEL_LABEL) {
                
        var data = {};
        data.type = "submit";
        if(onSubmit) {
            data.onSubmit = onSubmit;
            data.submitLabel = optionalSubmitLabel;
        }
        if(onCancel) {
            data.onCancel = onCancel;
            data.cancelLabel = optionalCancelLabel;
        }
        
        this.addToPanel(data);
    }
    
    //takes a handler onChange(formValue,form)
    addOnChange(onChange) {
        let onChildChange = (childValue,form) => {
            var formValue = this.getValue();
            onChange(formValue,form);
        };
        this.elementObjects.forEach( elementObject => elementObject.addOnChange(onChildChange));
    }

    addOnInput(onInput) {
        let onChildInput = (childValue,form) => {
            var formValue = this.getValue();
            onInput(formValue,form);
        };
        this.elementObjects.forEach( elementObject => elementObject.addOnInput(onChildInput));
    }
    
    setDisabled(isDisabled) {
        this.elementObjects.forEach( elementObject => {
            if(elementObject._setDisabled) {
                elementObject._setDisabled(isDisabled);
            }
        });
    }

    destroy() {
        this.elementObjects.forEach( elementObject => {
            elementObject.destroy();
        });
        this.elementObjects = [];
        this.layouts.forEach( layout => {
            layout.destroy();
        });
        this.layouts = [];
        this.panelDomElement = null; 
    }

    //------------------
    // Entry interface
    //------------------

    /** This method returns the ConfigurableElement for the given key. */
    getEntry(key) {
        return this.elementObjects.find(elementObject => elementObject.getKey() == key);
    }

    /** This gets an entry from the given path, where the path is an array of keys. 
     * Start index is the index of the key for this element. If it is omitted the value is
     * assumed to be 0.
    */
    getEntryFromPath(path,startIndex) {
        if(startIndex === undefined) startIndex = 0;
        if(startIndex >= path.length) {
            //invalid path
            return 0;
        }

        let childKey = path[startIndex];
        let childElement = this.getEntry(childKey);
        if(startIndex === path.length - 1) {
            return childElement;
        }
        else {
            if(childElement.getEntryFromPath) {
                //this means we can look up children from this element
                return childElement.getEntryFromPath(path,startIndex+1);
            }
            else {
                //invalid path
                return undefined;
            }
        }
    }

    setParentForm(form) {
        this.parentForm = form;
    }

    getBaseForm() {
        return this.parentForm ? this.parentForm.getBaseForm() : this;
    }

    /** This method is called during configuration to populate the selectors of the form. */
    populateSelectors() {
        this.elementObjects.forEach(elementObject => elementObject.populateSelectors());
    }

    //---------------------
    // static methods
    //---------------------
    
    /** This method is used to register configurable elements with the panel */
    static addConfigurableElement(constructorFunction) {
        var type = constructorFunction.TYPE_NAME;
        ConfigurablePanel.elementMap[type] = constructorFunction;
    }
    
    /** This method can be used to generate an error message layout. */
    static getErrorMessageLayoutInfo(errorMsg) {
        var layout = [];
        var entry = {};
        entry.type = "htmlDisplay";
        entry.html = "<em style='color:red'>" + errorMsg + "</em>";
        layout.push(entry);
        return {"layout":layout, "isErrorLayout": true};
    }

    //=================================
    // Private methods
    //=================================
    
    /** This creates the container element for the panel. */
    createPanelDomElement(containerClassName) {
        var panelDomElement = document.createElement("div");
        panelDomElement.className = containerClassName;
        //explicitly remove margin and padding
        panelDomElement.style.margin = "0px";
        panelDomElement.style.padding = "0px";
        return panelDomElement;
    }
    
    /** this is called internally to add an element to the panel. */
    addToPanel(elementInitData) {
        let elementObject;

        try {
            elementObject = ConfigurablePanel.instantiateConfigurableType(this,elementInitData);
        }
        catch(error) {
            //create an error element if there is an error
            elementObject = new ErrorElement(this,elementInitData,error);
        }

        //add the dome element for the container
        var domElement = elementObject.getElement();
        if(domElement) {
            this.panelDomElement.appendChild(domElement);
        }

        if(elementObject.elementType == "ConfigurableElement") {
            //add all child elements from this container to the child element list
            this.elementObjects.push(elementObject);  
        }
        else if(elementObject.elementType == "ConfigurableLayoutContainer") {
            this.layouts.push(elementObject);
        }
    }

    /** This method is called by a child layout container to pass children element objects to the form.  */
    insertChildElement(configurableElement) {
        this.elementObjects.push(configurableElement);
    }

    static instantiateConfigurableType(form,elementInitData) {
        var type = elementInitData.type;
        if(!type) {
            throw new Error("Type not found for configurable form entry!");
        }
        
        var constructor = ConfigurablePanel.elementMap[type];
        if(!constructor) {
            throw new Error("Type not found for configurable element: " + type);
        }

        return new constructor(form,elementInitData);
    }
}

//static fields
ConfigurablePanel.elementMap = {};

ConfigurablePanel.PANEL_CLASS = "apogee_configurablePanelBody";
ConfigurablePanel.PANEL_CLASS_FILL_PARENT = "apogee_configurablePanelBody_fillParent";

//This is displayed if there is an invalid layout passed in
ConfigurablePanel.INVALID_INIT_DATA = {
    layout: [
        {
            type: "heading",
            text: "INVALID FORM LAYOUT!",
            level: 4
        }
    ]
};

ConfigurablePanel.EMPTY_LAYOUT = {
    layout: []
};

/** This function takes a configurable form value and converts it to a function body that
 * allows for expressions to be entered into the form. Definition of what is an expression versus
 * a simple value is done in the "meta" field of the form config. */
function getFormResultFunctionBody(formValue,formMeta) {
    let parentObjectName = "output";
    let functionLines = [];
    functionLines.push("let output = {};");

    //load the converted data
    _loadPanelLines(parentObjectName,formValue,formMeta,functionLines);

    functionLines.push("return output;");
    return functionLines.join("\n");
}

/** This loads a value to an assignee, as part of the form result function body. */
function _loadEntry(assigneeName,value,meta,functionLines) {
    if((value === undefined)||(value === null)||((meta)&&(meta.excludeValue !== undefined)&&(meta.excludeValue === value))) {
        //value excluded
        //handle value === undefined!!
        return false;
    }
        
    //add value
    if((meta)&&(meta.expression)) {
        //expression
        switch(meta.expression) {
            case "simple":
                return _loadSimpleExpressionEntry(assigneeName,value,functionLines);
                
            case "object":
                functionLines.push(assigneeName + "= {};");
                _loadPanelLines(assigneeName,value,meta.childMeta,functionLines);
                //for now we always add the base object, even if empty
                return true;
                
            case "array": 
                functionLines.push(assigneeName + "= []");
                if(meta.childMeta) {
                    _loadMultiTypedArrayLines(assigneeName,value,meta.childMeta,functionLines);
                }
                else if(meta.entryMeta) {
                    _loadSingleTypedArrayLines(assigneeName,value,meta.entryMeta,functionLines);
                }
                //for now we always add the base array, even if empty
                return true;
                
            default:
                console.error("Expression type not supported: " + meta.expression);
                return false;
        }
    }
    else {
        //plain value, not an expression
        return _loadSimpleValueEntry(assigneeName,value,functionLines);
    }
}

/** This loads a value to an assignee for a simple value, as part of the form result function body. */
function _loadSimpleValueEntry(assigneeName,value,functionLines) {
    let line = assigneeName + " = " + JSON.stringify(value);
    functionLines.push(line);
    return true;
}

/** This loads a value to an assignee for a simple expression, as part of the form result function body. */
function _loadSimpleExpressionEntry(assigneeName,value,functionLines) {
    let trimmedValue = value.toString().trim();
    if(trimmedValue === "") return false;
    
    let line = assigneeName + " = " + trimmedValue;
    functionLines.push(line);
    return true;
}

/** This loads a value to an assignee fpr a panel, as part of the form result function body. */
function _loadPanelLines(parentObjectName,panelValue,panelMeta,functionLines) {
    for(let key in panelValue) {
        let meta = panelMeta[key];
        let value = panelValue[key];
        let assigneeName = parentObjectName + "[" + JSON.stringify(key) + "]";
        _loadEntry(assigneeName,value,meta,functionLines);
    }
}

/** This loads a value to an assignee for a multi-typed list, as part of the form result function body. */
function _loadMultiTypedArrayLines(assigneeName,value,metaMap,functionLines) {
    let insertIndex = 0;
    let linesAdded = false;
    value.forEach( (keyedEntry) => {
        let key = keyedEntry.key;
        let entryValue = keyedEntry.value;
        let entryMeta = metaMap[key];
        let entryAssigneeName = assigneeName + "[" + insertIndex + "]";
        let lineAdded = _loadEntry(entryAssigneeName,entryValue,entryMeta,functionLines);
        if(lineAdded) {
            insertIndex++;
            linesAdded = true;
        }
    });
    return linesAdded;
}

/** This loads a value to an assignee for a single-typed list, as part of the form result function body. */
function _loadSingleTypedArrayLines(assigneeName,value,entryMeta,functionLines) {
    let insertIndex = 0;
    let linesAdded = false;
    value.forEach( (entryValue) => {
        let entryAssigneeName = assigneeName + "[" + insertIndex + "]";
        let lineAdded = _loadEntry(entryAssigneeName,entryValue,entryMeta,functionLines);
        if(lineAdded) {
            insertIndex++;
            linesAdded = true;
        }
    });
    return linesAdded;
}

/** This method shows a configurable dialog. The layout object
 * defines the form content for the dialog. The on submit
 * function is called when submit is pressed. The on submit function should
 * return true or false, indicating whether of not to close the dialog. */
function showLegacyConfigurableDialog(layout,onSubmitFunction,optionalOnCancelFunction) {

    var dialog = dialogMgr.createDialog({"movable":true});
    var lineObjects = [];
    
    //this is the action for the form
    var formActions = {};
    //close form, in case actions needed
    formActions.onClose = function() {
        for(var i = 0; i < lineObjects.length; i++) {
            lineObject = lineObjects[i];
            if(lineObject.onClose) {
                lineObject.onClose();
            }
        }
        dialogMgr.closeDialog(dialog);
    };
    //cancel
    formActions.onCancel = function() {
        if(optionalOnCancelFunction) optionalOnCancelFunction();
        formActions.onClose();
    };
    //submit
    formActions.onSubmit = function() {
        //load the form data
        var formData = {};
        var lineObject;
        for(var i = 0; i < lineObjects.length; i++) {
            lineObject = lineObjects[i];
            if(lineObject.addToResult) {
                lineObject.addToResult(formData);
            }
        }
        //submit data
        var closeDialog = onSubmitFunction(formData);
        if(closeDialog) {
            formActions.onClose();
        }
    };
    
    //this will be used if we want to set the initial focus
    var initialFocusElement;

    var content = uiutil.createElement("div",{"className":"dialogBody"});
    for(var i = 0; i < layout.lines.length; i++) {
        var lineDef = layout.lines[i];
        
        //create line
        var lineObject = createLine(lineDef,formActions);
        lineObjects.push(lineObject);
        if(lineObject.element) { //no element for "invisible" entry, which is used to pass values along
            content.appendChild(lineObject.element);
        }
        if((lineDef.focus)&&(lineObject.focusElement)) {
            initialFocusElement = lineObject.focusElement;
        }
    }
    
    //show dialog
    dialog.setContent(content,uiutil.SIZE_WINDOW_TO_CONTENT);
    dialogMgr.showDialog(dialog);
    if(initialFocusElement) {
        initialFocusElement.focus();
    }
}
    
    
    
function createLine(lineDef,formActions) {
    var lineFunction = lineFunctions[lineDef.type];
    if(lineFunction) {
        return lineFunction(lineDef,formActions);
    }
    else {
        //print an error message
        apogeeUserAlert("Error: Unknown for element type: " + lineDef.type);
        return null;
    }
}

let lineFunctions = {
    //linedef.type = "title"
    //linedef.title = title
    "title": function(lineDef,formActions) {
        var lineObject = {};
        //create the element
        var line = uiutil.createElement("div",{"className":"dialogLine"});
        line.appendChild(uiutil.createElement("div",{"className":"dialogTitle","innerHTML":lineDef.title}));
        lineObject.element = line;
        
        //no addToResult or onClose
        
        return lineObject;
    },
    
    //lineDef.type = "dropdown"
    //lineDef.heading = dropdown heading (optional)
    //lineDef.entries = list of strings (or values) in dropdown
    //lineDef.initial = index of initial selection (optional)
    //lineDef.resultKey = name of result in result data
    "dropdown": function(lineDef,formActions) {
        var lineObject = {};
        //create the element
        var line = uiutil.createElement("div",{"className":"dialogLine"});
        if(lineDef.heading) {
            line.appendChild(document.createTextNode(lineDef.heading));
        }
        var select = uiutil.createElement("select");
        lineObject.focusElement = select;
        for(var i = 0; i < lineDef.entries.length; i++) {
            var entry = lineDef.entries[i];
            let label, value;
            if(Array.isArray(entry)) {
                value = entry[0];
                label = entry[1];
            }
            else {
                value = entry;
                label = entry;   
            }
            select.add(uiutil.createElement("option",{"text":label, "value":value}));
        }
        if(lineDef.initial) {
            select.value = lineDef.initial;
        }
        if(lineDef.disabled) {
            select.disabled = true;
        }
        line.appendChild(select);
        lineObject.element = line;
        //get result
        lineObject.addToResult = function(formData) {
            var result = select.value;
            formData[lineDef.resultKey] = result;
        };
        //no on Close
        
        return lineObject;
    },
    
    //lineDef.type = "inputElement"
    //lineDef.heading = element heading (optional)
    //lineDef.resultKey = name of result in result data
    "inputElement": function(lineDef,formActions) {
        var lineObject = {};
        //create the element
        var line = uiutil.createElement("div",{"className":"dialogLine"});
        if(lineDef.heading) {
            line.appendChild(document.createTextNode(lineDef.heading));
        }
        var inputElement = uiutil.createElement("input",{"type":"text"});
        lineObject.focusElement = inputElement;
        if(lineDef.initial) {
            inputElement.value = lineDef.initial;
        }
        if(lineDef.disabled) {
            inputElement.disabled = true;
        }
        line.appendChild(inputElement);
        lineObject.element = line;
        //get result
        lineObject.addToResult = function(formData) {
            var result = inputElement.value.trim();
            formData[lineDef.resultKey] = result;
        };
        //no on Close
        
        return lineObject;
    },
    
    "aceEditor": function(lineDef,formActions) {
        
    },
    
    "radioButton": function(lineDef,formActions) {
        //implement!
    },
    
    "checkbox": function(lineDef,formActions) {
        var lineObject = {};
        //create the element
        var line = uiutil.createElement("div",{"className":"dialogLine"});
        if(lineDef.heading) {
            line.appendChild(document.createTextNode(lineDef.heading));
        }
        var checkbox = uiutil.createElement("input");
        checkbox.type = "checkbox";
        lineObject.focusElement = checkbox;
        if(lineDef.name) {
            checkbox.name = lineDef.name;
        }
        if(lineDef.value) {
            checkbox.value = lineDef.value;
        }
        if(lineDef.initial) {
            checkbox.checked = true;
        }
        line.appendChild(checkbox);
        lineObject.element = line;
        //get result
        lineObject.addToResult = function(formData) {
            var result = checkbox.checked;
            formData[lineDef.resultKey] = result;
        };
        //no on Close
        
        return lineObject;
    },
    
    //lineDef.type = "submit"
    //lineDef.submit = name of submit button (optional)
    //lineDef.cancel = name of cancel button (optional)
    "submit": function(lineDef,formActions) {
        var lineObject = {};
        //create the element
        var line = uiutil.createElement("div",{"className":"dialogLine"});
        if(lineDef.submit) {  
            line.appendChild(uiutil.createElement("button",
            {"className":"dialogButton","innerHTML":lineDef.submit,"onclick":formActions.onSubmit}));
        }
        if(lineDef.cancel) {
            line.appendChild(uiutil.createElement("button",
            {"className":"dialogButton","innerHTML":lineDef.cancel,"onclick":formActions.onCancel}));
        }
        lineObject.element = line;
        //no add to result or on close
        return lineObject;
    },
    
    //This allows the user to input a custom element
    //lineDef.type = "custom"
    //lineDef.createLineObject(formActions) - returns lineObject
    "custom": function(lineDef,formActions) {
        return lineDef.createLineObject(formActions);
    },
    
    //lineDef.type = "invisible"
    //lineDef.intial = value for this element (optional)
    //lineDef.resultKey = name of result in result data
    "invisible": function(lineDef,formActions) {
        var lineObject = {};
        //create the empty element
        lineObject.element = null;
        //get result
        lineObject.addToResult = function(formData) {
            
            formData[lineDef.resultKey] = lineDef.initial;
        };
        //no on Close
        
        return lineObject;
    }
    
    
};

/** This method shows a configurable dialog. The layout object
 * defines the form content for the dialog. The on submit
 * function is called when submit is pressed. The on submit function should
 * return true or false, indicating whether of not to close the dialog. */
function showConfigurableDialog(layout,onSubmitFunction,optionalOnCancelFunction) {

    var dialog = dialogMgr.createDialog({"movable":true});
    let panel = new ConfigurablePanel();
    panel.configureForm(layout);

    let onCancel = function() {
        if(optionalOnCancelFunction) optionalOnCancelFunction();
        dialogMgr.closeDialog(dialog);
    };
    //submit
    let onSubmit = function(formValue) {
        //submit data
        var closeDialog = onSubmitFunction(formValue);
        if(closeDialog) {
            dialogMgr.closeDialog(dialog);
        }
    };

    panel.addSubmit(onSubmit,onCancel);
    
    //show dialog
    dialog.setContent(panel.getElement(),uiutil.SIZE_WINDOW_TO_CONTENT);
    dialogMgr.showDialog(dialog);

    //give focus to the panel
    panel.giveFocus();
}

/** This dialog has a title, message and a number of buttons and associated actions. 
 * Both the title and message are optional.
 * For the message, HTML is allowed, including things such as formatting and links.
 * A button is added for each item in the buttonTextList argument. The action for the
 * button is the associated value in the buttonActionList. If no action is specified, such
 * as if the buttonActionList is null, then there is no action aside from the dialog close.
*/
function showSimpleActionDialog(title,msg,buttonTextList,buttonActionList) {

    var dialog = dialogMgr.createDialog({"movable":true});
    
    //add a scroll container
    var contentContainer = uiutil.createElement("div",null,
        {
			"display":"block",
            "position":"relative",
            "top":"0px",
            "height":"100%",
            "overflow": "auto"
        });
	dialog.setContent(contentContainer,uiutil.SIZE_WINDOW_TO_CONTENT);
    
	var content = uiutil.createElement("div",null,
			{
				"display":"table",
				"overflow":"hidden"
			});
	contentContainer.appendChild(content);
    
    var line;

    //title
    if(title) {
        line = uiutil.createElement("div",{"className":"dialogLine"});
        line.appendChild(uiutil.createElement("div",{"className":"dialogTitle","innerHTML":title}));
        content.appendChild(line);
    }
  
    //msg - HTML should be allowed for the "message"
    if(msg) {
        line = uiutil.createElement("div",{"className":"dialogLine"});
        line.appendChild(uiutil.createElement("div",{"className":"dialogMessage","innerHTML":msg}));
        content.appendChild(line);
    }
    
    //buttons
    if((!buttonTextList)||(buttonTextList.length == 0)) {
        buttonTextList = ["OK"];
    }
    line = uiutil.createElement("div",{"className":"dialogLine"});
    for(let i = 0; i < buttonTextList.length; i++) {
        let buttonLabel = buttonTextList[i];
        let buttonAction = () => {
            //include the action if one is specified
            if((buttonActionList)&&(buttonActionList.length > i)&&(buttonActionList[i])) buttonActionList[i]();
            dialogMgr.closeDialog(dialog);
        };
        line.appendChild(uiutil.createElement("button",{"className":"dialogButton","innerHTML":buttonLabel,"onclick":buttonAction}));
        content.appendChild(line);
    }
    dialog.setContent(content,uiutil.SIZE_WINDOW_TO_CONTENT);  
    
    //show dialog
    dialogMgr.showDialog(dialog);
}

/** This is an text field element configurable element.
 * 
 * @class 
 */
class CheckboxElement extends ConfigurableElement {
    constructor(form,elementInitData) {
        super(form,elementInitData);
        
        var containerElement = this.getElement();
        
        //label
        let labelElement = this.getLabelElement(elementInitData);
        if(labelElement) {
            containerElement.appendChild(labelElement);
        }
        
        //checkbox field
        this.checkbox = uiutil.createElement("input",{"type":"checkbox"}); 
        containerElement.appendChild(this.checkbox);

        this.setFocusElement(this.checkbox);
        
        //add dom listeners for events
        this.changeListener = () => {
            this.inputDone();
            this.valueChanged();
        };
        this.checkbox.addEventListener("change",this.changeListener);

        //hint
        let hintElement = this.getHintElement(elementInitData);
        if(hintElement) {
            containerElement.appendChild(hintElement);
        }

        //help element
        let helpElement = this.getHelpElement(elementInitData);
        if(helpElement) {
            containerElement.appendChild(helpElement);
        }
        
        this._postInstantiateInit(elementInitData);

    }
    
    /** This method returns value for this given element, if applicable. If not applicable
     * this method returns undefined. */
    getValue() {
        return this.checkbox.checked;
    } 

    destroy() {
        super.destroy();

        this.checkbox.removeEventListener("change",this.changeListener);
        this.changeListener = null;

        this.checkbox = null;
    }

    //===================================
    // protected Methods
    //==================================

    /** This method updates the UI value for a given element. */
    setValueImpl(value) {
        this.checkbox.checked = (value === true);
    }
    
    //===================================
    // internal Methods
    //==================================
    
    _setDisabled(isDisabled) { 
        this.checkbox.disabled = isDisabled;
    }
}

CheckboxElement.TYPE_NAME = "checkbox";

/** This is an text field element configurable element.
 * 
 * @class 
 */
class CheckboxGroupElement extends ConfigurableElement {
    constructor(form,elementInitData) {
        super(form,elementInitData);

        //this element returns a list of selections
        this.setIsMultiselect(true);
        
        var containerElement = this.getElement();
        
        //label
        let labelElement = this.getLabelElement(elementInitData);
        if(labelElement) {
            containerElement.appendChild(labelElement);
        }

        //horizonal - defaults to true. Is false if vetical flag is set to true or horizontal is set to false
        let doHorizontal = !((elementInitData.horizontal === false)||(elementInitData.vertical === true));

        //hint
        //if not horizontal, put the hint and help after the label
        if(!doHorizontal) {
            //hint element
            let hintElement = this.getHintElement(elementInitData);
            if(hintElement) {
                containerElement.appendChild(hintElement);
            }

            //help element
            let helpElement = this.getHelpElement(elementInitData);
            if(helpElement) {
                containerElement.appendChild(helpElement);
            }
        }

        //add dom listeners for events
        this.changeListener = () => {
            this.inputDone();
            this.valueChanged();
        };
        
        //check boxes
        this.checkboxList = [];
        this.valueMap = {};
        let focusElementSet = false;
        var addCheckbox = (checkboxInfo,index) => {
            var buttonContainer = uiutil.createElement("div");
            buttonContainer.style.display = doHorizontal ? "inline-block" : "block";
            containerElement.appendChild(buttonContainer);

            var checkbox = uiutil.createElement("input");
            checkbox.type = "checkbox";

            if(!focusElementSet) {
                this.setFocusElement(checkbox);
                focusElementSet = true;
            }

            var label;
            var value;
            if(Array.isArray(checkboxInfo)) {
                label = checkboxInfo[0];
                value = checkboxInfo[1];     
            }
            else {
                label = checkboxInfo;
                value = checkboxInfo; 
            }

            //checkbox only holds string values. We will store the user set value externally
            let standinValue = String(index);
            this.valueMap[standinValue] = value;
            checkbox.value = standinValue;

            this.checkboxList.push(checkbox);
            buttonContainer.appendChild(checkbox);
            let checkboxLabel = document.createElement("span");
            checkboxLabel.innerHTML = label;
            checkboxLabel.className = "apogee_configurableElement_hideSelection";
            buttonContainer.appendChild(checkboxLabel);

            if(doHorizontal) {
                let spacer = document.createElement("span");
                spacer.innerHTML = "\u00A0\u00A0\u00A0\u00A0";
                spacer.className = "apogee_configurableElement_hideSelection";
                buttonContainer.appendChild(spacer);
            }
            
            if(elementInitData.disabled) checkbox.disabled = true;

            //add the dom listener
            checkbox.addEventListener("change",this.changeListener);
        };
        elementInitData.entries.forEach(addCheckbox);  

        //hint
        //if  horizontal, put the hint and help at the end
        if(doHorizontal) {
            let hintElement = this.getHintElement(elementInitData);
            if(hintElement) {
                containerElement.appendChild(hintElement);
            }

            //help element
            let helpElement = this.getHelpElement(elementInitData);
            if(helpElement) {
                containerElement.appendChild(helpElement);
            }
        }
        
        this._postInstantiateInit(elementInitData);
    }
    
    /** This method returns value for this given element, if applicable. If not applicable
     * this method returns undefined. */
    getValue() {
        //return the check value mapped back to the proper (potentially non-string) value for the checkbox
        return this.checkboxList.filter(checkbox => checkbox.checked).map(checkbox => this.valueMap[checkbox.value]); 
    }   

    //==================================
    // protected methods
    //==================================

    /** This method updates the UI value for a given element. */
    setValueImpl(valueList) {
        this.checkboxList.forEach(checkbox => {
            let standinValue = checkbox.value;
            let properValue = this.valueMap[standinValue];
            checkbox.checked = (valueList.indexOf(properValue) >= 0);
        });
    }

    destroy() {
        super.destroy();
        
        this.checkboxList.forEach(checkbox => {
            checkbox.removeEventListener("change",this.changeListener);
        });
        this.checkboxList = [];
        this.changeListener = null;
    }

    //===================================
    // internal Methods
    //==================================
    
    _setDisabled(isDisabled) { 
        this.checkboxList.forEach(checkbox => checkbox.disabled = isDisabled);
    }
}

CheckboxGroupElement.TYPE_NAME = "checkboxGroup";

/** This is an text field element configurable element.
 * 
 * @class 
 */
class ColorPickerElement extends ConfigurableElement {
    constructor(form,elementInitData) {
        super(form,elementInitData);
        
        var containerElement = this.getElement();
        
        //label
        let labelElement = this.getLabelElement(elementInitData);
        if(labelElement) {
            containerElement.appendChild(labelElement);
        }
        
        //slider
        this.colorPickerElement = uiutil.createElement("input",{"type":"color"});
        containerElement.appendChild(this.colorPickerElement);
        
        this.setFocusElement(this.colorPickerElement);

        this.changeListener = () => {
            this.inputDone();
            this.valueChanged();
        };
        this.colorPickerElement.addEventListener("change",this.changeListener);

        //hint
        let hintElement = this.getHintElement(elementInitData);
        if(hintElement) {
            containerElement.appendChild(hintElement);
        }

        //help element
        let helpElement = this.getHelpElement(elementInitData);
        if(helpElement) {
            containerElement.appendChild(helpElement);
        }

        this._postInstantiateInit(elementInitData);
    }
    
    /** This method returns value for this given element, if applicable. If not applicable
     * this method returns undefined. */
    getValue() {
        return this.colorPickerElement.value;
    }  
    
    //===================================
    // protectd Methods
    //==================================

    /** This method updates the list of checked entries. */
    setValueImpl(value) {
        this.colorPickerElement.value = value;
    }

    destroy() {
        super.destroy();
        this.colorPickerElement.removeEventListener("change",this.changeListener);
        this.colorPickerElement = null;
    }

    //===================================
    // internal Methods
    //==================================
    
    _setDisabled(isDisabled) { 
        this.colorPickerElement.disabled = isDisabled;
    }
}

ColorPickerElement.TYPE_NAME = "colorPicker";

/** This is a custom configurable element.
 * It elementInfoData should contain the entries:
 * - type - this should be the value "custom"
 * - key - this is the standard element key
 * - builderFunction - this is a function that takes the instance as an argument. it should be used to add
 * or override any functions to the instance.
 * 
 * @class 
 */
class CustomElement extends ConfigurableElement {

    constructor(form,elementInitData) {
        super(form,elementInitData);
        
        elementInitData.builderFunction(this);
    }

}

CustomElement.TYPE_NAME = "custom";

/** This is an text field element configurable element.
 * 
 * @class 
 */
class DropdownElement extends ConfigurableElement {
    constructor(form,elementInitData) {
        super(form,elementInitData);
        
        var containerElement = this.getElement();
        
        //label
        let labelElement = this.getLabelElement(elementInitData);
        if(labelElement) {
            containerElement.appendChild(labelElement);
        }
        
        this.valueMap = {};
        this.select = uiutil.createElement("select");
        this.select.className = "apogee_configurableElement_hideSelection";
        var addEntry = (entryInfo,index) => {
            var label;
            var value;
            if(Array.isArray(entryInfo)) {
                label = entryInfo[0];
                value = entryInfo[1];
            }
            else {
                label = entryInfo;
                value = entryInfo;   
            }

            let standinValue = String(index);
            this.valueMap[standinValue] = value;

            var entry = document.createElement("option");
            entry.text = label;
            entry.value = standinValue;
            this.select.appendChild(entry);
        };
        if(elementInitData.entries) {
            elementInitData.entries.forEach(addEntry);
        }
        containerElement.appendChild(this.select); 

        this.setFocusElement(this.select);

        //add dom listeners
        this.changeListener = () => {
            this.inputDone();
            this.valueChanged();
        };
        this.select.addEventListener("change",this.changeListener);

        //hint
        let hintElement = this.getHintElement(elementInitData);
        if(hintElement) {
            containerElement.appendChild(hintElement);
        }

        //help element
        let helpElement = this.getHelpElement(elementInitData);
        if(helpElement) {
            containerElement.appendChild(helpElement);
        }
        
        this._postInstantiateInit(elementInitData);
    }
    
    /** This method returns value for this given element, if applicable. If not applicable
     * this method returns undefined. */
    getValue() {
        return this.valueMap[this.select.value];
    }  
    
    //===================================
    // protected Methods
    //==================================

    /** This method updates the UI value for a given element. */
    setValueImpl(value) {
        let standinValue;
        for(let key in this.valueMap) {
            if(this.valueMap[key] === value) standinValue = key;
        }
        if(standinValue !== undefined) {
            this.select.value = standinValue;
        }
    }

    destroy() {
        super.destroy();
        this.select.removeEventListener("change",this.changeListener);
        this.select = null;
    }
    
    //===================================
    // internal Methods
    //==================================
    
    _setDisabled(isDisabled) { 
        this.select.disabled = isDisabled;
    }
}

DropdownElement.TYPE_NAME = "dropdown";

/** This is a heading element configurable element.
 * 
 * @class 
 */
class HeadingElement extends ConfigurableElement {

    constructor(form,elementInitData) {
        super(form,elementInitData);
        
        var containerElement = this.getElement();
        
        var headingLevel;
        if(elementInitData.level) { 
            headingLevel = elementInitData.level;
        }
        else {
            headingLevel = HeadingElement.DEFAULT_HEADING_LEVEL;
        }
        var headingClass = "apogee_configurablePanelHeading_" + headingLevel;
        
        let headingElement = uiutil.createElement("span",{"className":headingClass,"innerHTML":elementInitData.text});
        headingElement.classList.add("apogee_configurableElement_hideSelection");
        containerElement.appendChild(headingElement);

        this._postInstantiateInit(elementInitData);
    }
}


HeadingElement.DEFAULT_HEADING_LEVEL = 2;

HeadingElement.TYPE_NAME = "heading";

/** This is a heading element configurable element.
 * 
 * @class 
 */
class HTMLDisplayElement extends ConfigurableElement {

    constructor(form,elementInitData) {
        super(form,elementInitData);
        
        var containerElement = this.getElement();
        
        containerElement.innerHTML = elementInitData.html;

        this._postInstantiateInit(elementInitData);
    }

}

HTMLDisplayElement.TYPE_NAME = "htmlDisplay";

/** This element holds a value that can only be set during configuration. The element is not 
 * visible on the form.
 * 
 * @class 
 */
class InvisibleElement extends ConfigurableElement {
    constructor(form,elementInitData) {
        //we will hide this element by setting display none. Someone can go ahead 
        //and show it, in which case they will get an empty element with margins.
        //maybe we should have a way to not create the element in the first place.
        super(form,elementInitData);

        //we set the element value here in initialization and do not allow it to be set
        //elsewhere. We disabled the setValue method.
        this.value = elementInitData.value;

        //update the class to be invisible
        this.setVisibleDisplayStyle(ConfigurableElement.ELEMENT_DISPLAY_INVISIBLE);
        
        this._postInstantiateInit(elementInitData);
    }
    
    /** This method returns value for this given element, if applicable. If not applicable
     * this method returns undefined. */
    getValue() {
        return this.value;
    }   

    //===================================
    // protected Methods
    //==================================

    /** This does NOT update the value. The value is only set in initialization. */
    setValueImpl(value) {
        //no action!
    }
}

InvisibleElement.TYPE_NAME = "invisible";

/** This is a list element.
 * 
 * @class 
 */
class ListElement extends ConfigurableElement {
    constructor(form,elementInitData) {
        super(form,elementInitData);

        var containerElement = this.getElement();

        this.upUrl = uiutil.getResourcePath("/up_black.png");
        this.downUrl = uiutil.getResourcePath("/down_black.png");
        this.closeUrl = uiutil.getResourcePath("/close_black.png");
        
        //label
        let labelElement = this.getLabelElement(elementInitData);
        if(labelElement) {
            containerElement.appendChild(labelElement);
        }
        
        //initialize the list
        if(elementInitData.entryType) {
            this.entryTypes = [elementInitData.entryType];
            this.isMultitypeList = false;
        }
        else if(elementInitData.entryTypes) {
            this.entryTypes = elementInitData.entryTypes;
            this.isMultitypeList = true;
        }
        
        this.listEntries = [];
        this.elementContainer = null;
        this.listElement = this._createListContainer(); 
        containerElement.appendChild(this.listElement); 

        this.inheritValueMap = {};
        
        this._postInstantiateInit(elementInitData);
    }
    
    /** This method returns value for this given element, if applicable. If not applicable
     * this method returns undefined. */
    getValue() {
        var listValue = [];
        this.listEntries.forEach(listEntry => {
            let elementObject = listEntry.elementObject;
            if(elementObject.getState() != ConfigurablePanelConstants.STATE_INACTIVE) {
                var elementValue = elementObject.getValue();
                if(elementValue !== undefined) {
                    //we return the values differently for multilists and non-multitype lists
                    if(this.isMultitypeList) {
                        let valueEntry = {};
                        valueEntry.key = elementObject.getKey();
                        valueEntry.value = elementValue;
                        listValue.push(valueEntry);
                    }
                    else {
                        listValue.push(elementValue);
                    }
                }
            }
        });
        return listValue;
    }   

    /** This overrides the get meta element to calculate it on the fly. Because of list elements,
     * the meta value depends on the content. */
    getMeta() {
        if(this.meta) {
            //handle an empty list
            if(this.listEntries.length === 0) return null;

            let fullMeta = apogeeutil.jsonCopy(this.meta);
            if(this.isMultiTypeList) {
                let childMeta = {};
                this.listEntries.forEach( listEntryInfo => {
                    let childEntryMeta = listEntryInfo.elementObject.getMeta();
                    let childKey = listEntryInfo.elementObject.getKey();
                    if((childEntryMeta)&&(childKey)) {
                        childMeta[childKey] = childEntryMeta;
                    }
                });
                fullMeta.childMeta = childMeta;
            }
            else {
                let listEntryInfo = this.listEntries[0];
                let childEntryMeta = listEntryInfo.elementObject.getMeta();
                if(childEntryMeta) {
                    fullMeta.entryMeta = childEntryMeta;
                }
            }

            return fullMeta;
        }
        else {
            return null;
        }
    }

    /** We override the standard giveFocus method to pass it on to a child element. */
    giveFocus() {
        for(let i = 0; i < this.listEntries.length; i++) {
            let listEntry = this.listEntries[i];
            if((listEntry.elementObject)&&(listEntry.elementObject.giveFocus())) return true;
        }
        return false;
    }
    
    //===================================
    // protected Methods
    //==================================

    /** This method updates the value for a given element. See the specific element
     * to see if this method is applicable. */
    setValueImpl(listValue) {
        if(Array.isArray(listValue)) {
            let currentValue = this.getValue();
            //update values if the list changes
            //first change event either way (we may later change the general policy on this)
            if(!apogeeutil.jsonEquals(currentValue,listValue)) {

                //remove the old list entries
                while(this.listEntries.length > 0 ) {
                    this._removeListEntry(this.listEntries[0]);
                }

                //create a new entry for each value
                listValue.forEach( (valueEntry,index) => {
                    if(this.isMultitypeList) {
                        if((valueEntry.key !== undefined)&&(valueEntry.value != undefined)) {
                            let entryTypeJson = this._lookupEntryTypeJson(valueEntry.key);
                            if(entryTypeJson) {
                                this._insertElement(entryTypeJson,valueEntry.value);
                            }
                            else {
                                console.log("List Entry key not found: " + valueEntry.key);
                            }
                        }
                        else {
                            console.log("Improperly formatted list value for multitypelist!");
                        }
                    }
                    else {
                        let entryTypeJson = this.entryTypes[0];
                        if(entryTypeJson) {
                            this._insertElement(entryTypeJson,valueEntry);
                        }
                        else {
                            console.log("NO entry type set!");
                        }
                    }
                });
            }
        }
        else {
            console.log("Value being set for list is not an array!");
        }
    }

    /** This function is used to inherit a child value from a parent value.
     * It passes all values to any contained list element that has an inherit method. */
    inherit(childKey,parentValue) {
        //pass to any child entries applicable
        this.listEntries.forEach( listEntry => {
            let childElement = listEntry.elementObject;
            if(childElement.inherit) {
                childElement.inherit(childKey,parentValue);
            }
        }); 

        //store the inherit value for when other entries created
        this.inheritValueMap[childKey] = parentValue;
    }

    destroy() {
        super.destroy();

        this.entryTypes = [];
        this.listEntries.forEach( listEntry => {
            listEntry.elementObject.destroy();
        });
        this.listEntries = [];
    }

    //===================================
    // internal Methods
    //==================================

    /** This looks up the entry type for a given key, based on the layout key. */
    _lookupEntryTypeJson(key) {
        return this.entryTypes.find( entryTypeJson => entryTypeJson.layout.key == key);
    }
    
    //---------------------
    // List Management Functions
    //---------------------

    _createListContainer() {
        var listContainer = document.createElement("div");
        listContainer.className = "listElement_listContainer";

        //element container - houses elements
        let elementContainerWrapper = document.createElement("div");
        elementContainerWrapper.className = "listElement_elementContainerWrapper";
        listContainer.appendChild(elementContainerWrapper);

        this.elementContainer = document.createElement("div");
        this.elementContainer.className = "listElement_elementContainer";
        elementContainerWrapper.appendChild(this.elementContainer);

        //control bar = has "add" buttons
        let controlBar = document.createElement("div");
        controlBar.className = "listElement_listControlBar";
        this.entryTypes.forEach(entryTypeJson => {
            let addButton= document.createElement("button");
            addButton.className = "listElement_addButton apogee_configurableElement_hideSelection";
            let labelText = entryTypeJson.label ? "+ "+ entryTypeJson.label : "+";
            addButton.innerHTML = labelText;
            addButton.onclick = () => {
                this._insertElement(entryTypeJson);
                this.inputDone();
            };
            controlBar.appendChild(addButton);
            let lineBreak = document.createElement("br");
            lineBreak.className = "apogee_configurableElement_hideSelection";
            controlBar.appendChild(lineBreak);
        });
        listContainer.appendChild(controlBar);

        return listContainer;
    }

    _insertElement(entryTypeJson,optionalValue) {
        let listEntryData = this._createListEntryData(entryTypeJson);
        this.listEntries.push(listEntryData);
        this.elementContainer.appendChild(listEntryData.element);

        //set value if set in config
        if(optionalValue !== undefined) {
            listEntryData.elementObject.setValue(optionalValue);
        }

        //set value if set from inherit
        for(let key in this.inheritValueMap) {
            let childElement = listEntryData.elementObject;
            if(childElement.inherit) {
                childElement.inherit(key,this.inheritValueMap[key]);
            }
        }

        //add the change listener for this element
        listEntryData.elementObject.addOnChange( () => this.valueChanged());
        listEntryData.elementObject.addOnInput( () => this.inputDone());
        
        //nofityof value change
        this.valueChanged();
        
    }

    _createListEntryData(entryTypeJson) {

        let listEntry = {};

        //create element object

        let elementInitData = entryTypeJson.layout;
        if(!elementInitData) {
            throw new Error("Layout not found for list entry!");
        }

        var elementObject = ConfigurablePanel.instantiateConfigurableType(this.getForm(),elementInitData);

        if(elementObject instanceof ConfigurableElement) {
            elementObject.populateSelectors();
            
            listEntry.elementObject = elementObject;
            listEntry.element = this._createListDomElement(listEntry);
        }
        else {
            throw new Error("Only configurable elements cah be set as entry types for a list.");
        }

        return listEntry;
    }

    _createListDomElement(listEntry) {
        let contentElement = listEntry.elementObject.getElement();

        //list element
        let listElement = document.createElement("div");
        listElement.className = "listElement_itemElement";

        //content
        this.contentContainer = document.createElement("div");
        this.contentContainer.className = "listElement_itemContent";
        listElement.appendChild(this.contentContainer);

        //control bar
        let controlBar = document.createElement("div");
        controlBar.className = "listElement_itemControlBar";
        let upButton = document.createElement("img");
        upButton.src = this.upUrl;
        upButton.className = "listElement_itemButton apogee_configurableElement_hideSelection";
        upButton.style.position = "absolute";
        upButton.style.top = "2px";
        upButton.style.left = "2px";
        upButton.onclick = () => {
            this._moveListEntryUp(listEntry);
            this.inputDone();
        };
        controlBar.appendChild(upButton);
   
        let downButton = document.createElement("img");
        downButton.src = this.downUrl;
        downButton.className = "listElement_itemButton apogee_configurableElement_hideSelection";
        downButton.style.position = "absolute";
        downButton.style.top = "15px";
        downButton.style.left = "2px";
        downButton.onclick = () => {
            this._moveListEntryDown(listEntry);
            this.inputDone();
        };
        controlBar.appendChild(downButton);
   
        let deleteButton = document.createElement("img");
        deleteButton.src = this.closeUrl;
        deleteButton.className = "listElement_itemButton apogee_configurableElement_hideSelection";
        deleteButton.style.position = "absolute";
        deleteButton.style.top = "2px";
        deleteButton.style.left = "20px";
        deleteButton.onclick = () => {
            this._removeListEntry(listEntry);
            this.inputDone();
        };
        controlBar.appendChild(deleteButton);
        
        this.contentContainer.appendChild(contentElement);
        listElement.appendChild(controlBar);
   
        return listElement;
    }

    //---------------------
    // List Element Action Functions
    //---------------------
    
    _moveListEntryUp(entry) {
        let index = this.listEntries.indexOf(entry);
        if(index > 0) {
            //update list position
            let previousEntry = this.listEntries[index-1];
            this.listEntries.splice(index-1,2,entry,previousEntry);
            //update dom positions 1 - using dom functions
            this.elementContainer.insertBefore(entry.element,entry.element.previousSibling);
            
            //update dom positions 2 - reinsert all (maybe this is safer?)
            //while(this.elementContainer.hasChildNodes()) this.elementContainer.removeChild(this.elementContainer.firstChild);
            //listEntries.forEach( childEntry => this.elementContainer.appendChild(childEntry.element));

            //nofity change
            this.valueChanged();
        }
    }

    _moveListEntryDown(entry) {
        let index = this.listEntries.indexOf(entry);
        if(index < this.listEntries.length - 1) {
            //update list position
            let nextEntry = this.listEntries[index+1];
            this.listEntries.splice(index,2,nextEntry,entry);
            //update dom positions
            this.elementContainer.insertBefore(entry.element.nextSibling,entry.element);

            //nofity change
            this.valueChanged();
        }
    }

    _removeListEntry(entry) {
        let index = this.listEntries.indexOf(entry);
        //remove from listEntries
        this.listEntries.splice(index,1);
        //remove from DOM
        this.elementContainer.removeChild(entry.element);

        //nofity change
        this.valueChanged();
    }
}

ListElement.TYPE_NAME = "list";

/** This is an text field element configurable element.
 * 
 * @class 
 */
class PanelElement extends ConfigurableElement {
    constructor(form,elementInitData) {
        super(form,elementInitData);
        
        var containerElement = this.getElement();
        //udpate padding and margin to 0
        containerElement.style.margin = ConfigurableElement.ELEMENT_MARGIN_NONE;
        containerElement.style.padding = ConfigurableElement.ELEMENT_PADDING_NONE;
        
        var formInitData = elementInitData.formData;
        this.panel = new ConfigurablePanel();
        this.panel.setParentForm(form);
        this.panel.createForm(formInitData);
        var panelElement = this.panel.getElement();
        containerElement.appendChild(panelElement);

        //add event listeners
        this.panel.addOnInput( () => this.inputDone() );
        this.panel.addOnChange( () => this.valueChanged() );
        
        this._postInstantiateInit(elementInitData);
    }
    
    /** This method returns value for this given element, if applicable. If not applicable
     * this method returns undefined. */
    getValue() {
        return this.panel.getValue();
    }   

    /** This overrides the get meta element to calculate it on the fly. Because of list elements,
     * the meta value depends on the content. */
    getMeta() {
        if(this.meta) {
            let fullMeta = apogeeutil.jsonCopy(this.meta);
            fullMeta.childMeta = this.panel.getMeta();
            return fullMeta;
        }
        else {
            return null;
        }
    }

    /** We override the standard giveFocus method to pass it on to a child element. */
    giveFocus() {
        return this.panel.giveFocus();
    }

    //------------------
    // Entry interface
    //------------------

    /** This gets an entry from the given path, where the path is an array of keys. */
    getEntryFromPath(path,startIndex) {
        return this.panel.getEntryFromPath(path,startIndex);
    }

    populateSelectors() {
        //element selector
        super.populateSelectors();
        //panel child element selectors
        this.panel.populateSelectors();
    }

    //===================================
    // protected Methods
    //==================================

    /** This method updates the value for a given element. See the specific element
     * to see if this method is applicable. */
    setValueImpl(value) {
        this.panel.setValue(value);
    }

    /** This function is used to inherit a child value from a parent value */
    inherit(childKey,parentValue) {
        let childElement = this.panel.getEntry(childKey);
        if((childElement)&&(childElement.getValue() != parentValue)) {
            childElement.setValue(parentValue);
        }    
    }

    destroy() {
        super.destroy();
        this.panel.destroy();
        this.panel = null;
    }
    
    //===================================
    // internal Methods
    //==================================
    
    _setDisabled(isDisabled) { 
        this.panel.setDisabled(isDisabled);
    }
}

PanelElement.TYPE_NAME = "panel";

/** This is an text field element configurable element.
 * 
 * @class 
 */
class RadioGroupElement extends ConfigurableElement {
    constructor(form,elementInitData) {
        super(form,elementInitData);
        
        var containerElement = this.getElement();
        
        //label
        let labelElement = this.getLabelElement(elementInitData);
        if(labelElement) {
            containerElement.appendChild(labelElement);
        }

        //horizonal - defaults to true. Is false if vetical flag is set to true or horizontal is set to false
        //the prefered flag is "vertical". We keep horizontal for legacy purposes, though I doubt anyone has yet said
        //horizontal: false instead of just leaving he flag off.
        let doHorizontal = !((elementInitData.horizontal === false)||(elementInitData.vertical === true));

        //hint
        //if not horizontal, put the hint and help after the label
        if(!doHorizontal) {
            let hintElement = this.getHintElement(elementInitData);
            if(hintElement) {
                containerElement.appendChild(hintElement);
            }

            //help element
            let helpElement = this.getHelpElement(elementInitData);
            if(helpElement) {
                containerElement.appendChild(helpElement);
            }
        }

        //add dom listeners for events
        this.changeListener = () => {
            this.inputDone();
            this.valueChanged();
        };
        
        //radio buttons
        this.buttonList = [];
        this.valueMap = {};
        let focusElementSet = false;
        var groupName = elementInitData.groupName;
        if(!groupName) groupName = getRandomString();
        var addButton = (buttonInfo,index) => {
            var buttonContainer = uiutil.createElement("div");
            buttonContainer.style.display = doHorizontal ? "inline-block" : "block";
            containerElement.appendChild(buttonContainer);

            var radio = uiutil.createElement("input");
            radio.type = "radio";
            radio.name = groupName;

            if(!focusElementSet) {
                this.setFocusElement(radio);
                focusElementSet = true;
            }
            
            var label;
            var value;
            if(Array.isArray(buttonInfo)) {
                label = buttonInfo[0];
                value = buttonInfo[1];     
            }
            else {
                label = buttonInfo;
                value = buttonInfo; 
            }

            //radiobutton only holds string values. We will store the user set value externally
            let standinValue = String(index);
            this.valueMap[standinValue] = value;
            radio.value = standinValue;

            this.buttonList.push(radio);
            buttonContainer.appendChild(radio);
            let buttonLabel = document.createElement("span");
            buttonLabel.innerHTML = label;
            buttonLabel.className = "apogee_configurableElement_hideSelection";
            buttonContainer.appendChild(buttonLabel);
            
            if(doHorizontal) {
                let spacer = document.createElement("span");
                spacer.innerHTML = "\u00A0\u00A0\u00A0\u00A0";
                spacer.className = "apogee_configurableElement_hideSelection";
                buttonContainer.appendChild(spacer);
            }

            //add dom listeners
            radio.addEventListener("change",this.changeListener);
        };
        elementInitData.entries.forEach(addButton);

        //hint
        //if  horizontal, put the hint and help at the end
        if(doHorizontal) {
            let hintElement = this.getHintElement(elementInitData);
            if(hintElement) {
                containerElement.appendChild(hintElement);
            }

            //help element
            let helpElement = this.getHelpElement(elementInitData);
            if(helpElement) {
                containerElement.appendChild(helpElement);
            }

        }
        
        this._postInstantiateInit(elementInitData);
    }
    
    /** This method returns value for this given element, if applicable. If not applicable
     * this method returns undefined. */
    getValue() {
        var checkedRadio = this.buttonList.find(radio => radio.checked);
        if(checkedRadio) {
            return this.valueMap[checkedRadio.value];
        }
        else {
            return undefined;
        }
    }  
    
    //===================================
    // protectd Methods
    //==================================

    /** This method updates the list of checked entries. */
    setValueImpl(value) {
        var checkedButton = this.buttonList.find(radioButton => {
            let standinValue = radioButton.value;
            let properButtonValue = this.valueMap[standinValue];
            return (properButtonValue === value);
        });

        if(checkedButton) {
            checkedButton.checked = true;
        }
    }

    destroy() {
        super.destroy();
        
        this.buttonList.forEach(radioButton => {
            radioButton.removeEventListener("change",this.changeListener);
        });
        this.buttonList = [];
        this.changeListener = null;
    }

    //===================================
    // internal Methods
    //==================================
    
    _setDisabled(isDisabled) { 
        this.buttonList.forEach(radioButton => radioButton.disabled = isDisabled);
    }
}

RadioGroupElement.TYPE_NAME = "radioButtonGroup";

function getRandomString() {
    return Math.random().toString(36).substring(2, 15);
}

/** This is an text field element configurable element.
 * 
 * @class 
 */
class SliderElement extends ConfigurableElement {
    constructor(form,elementInitData) {
        super(form,elementInitData);
        
        var containerElement = this.getElement();
        
        //label
        let labelElement = this.getLabelElement(elementInitData);
        if(labelElement) {
            containerElement.appendChild(labelElement);
        }
        
        //slider
        this.sliderElement = uiutil.createElement("input",{"type":"range"});
        containerElement.appendChild(this.sliderElement); 

        this.setFocusElement(this.sliderElement);

        this.changeListener = () => {
            this.inputDone();
            this.valueChanged();
        };

        this.sliderElement.addEventListener("change",this.changeListener);

        if(elementInitData.min !== undefined) {
            this.sliderElement.min = elementInitData.min;
        }
        if(elementInitData.max !== undefined) {
            this.sliderElement.max = elementInitData.max;
        }
        if(elementInitData.step !== undefined) {
            this.sliderElement.step = elementInitData.step;
        }

        //hint
        let hintElement = this.getHintElement(elementInitData);
        if(hintElement) {
            containerElement.appendChild(hintElement);
        }

        //help element
        let helpElement = this.getHelpElement(elementInitData);
        if(helpElement) {
            containerElement.appendChild(helpElement);
        }

        this._postInstantiateInit(elementInitData);
    }
    
    /** This method returns value for this given element, if applicable. If not applicable
     * this method returns undefined. */
    getValue() {
        let stringValue = this.sliderElement.value;
        return parseFloat(stringValue);
    }  
    
    //===================================
    // protectd Methods
    //==================================

    /** This method updates the list of checked entries. */
    setValueImpl(value) {
        this.sliderElement.value = value;
    }

    destroy() {
        super.destroy();
        
        this.sliderElement.removeEventListener("change",this.changeListener);
        this.changeListener = null;
        this.sliderElement = null;
    }

    //===================================
    // internal Methods
    //==================================
    
    _setDisabled(isDisabled) { 
        this.sliderElement.disabled = isDisabled;
    }
}

SliderElement.TYPE_NAME = "slider";

/** This is an text field element configurable element.
 * 
 * @class 
 */
class SpacerElement extends ConfigurableElement {
    constructor(form,elementInitData) {
        //we will hide this element by setting display none. Someone can go ahead 
        //and show it, in which case they will get an empty element with margins.
        //maybe we should have a way to not create the element in the first place.
        super(form,elementInitData);
        
        var containerElement = this.getElement();
        //udpate padding and margin to 0
        containerElement.style.margin = ConfigurableElement.ELEMENT_MARGIN_NONE;
        containerElement.style.padding = ConfigurableElement.ELEMENT_PADDING_NONE;
        
        let spacerElement = document.createElement("div");
        var spacerHeight;
        if(elementInitData.height !== undefined) {
            spacerHeight = elementInitData.height;
        }
        else {
            spacerHeight = SpacerElement.DEFAULT_HEIGHT;
        }
        //this.spacerElement.style.display = "table";
        spacerElement.style.height = spacerHeight + "px";
        
        containerElement.appendChild(spacerElement);
        
        this._postInstantiateInit(elementInitData);
    }
}

//adding this includes the extra space of two margins rather than one,
//so just one pixel has a large effect
SpacerElement.DEFAULT_HEIGHT = 15;

SpacerElement.TYPE_NAME = "spacer";

/** This is an submit element configurable element.
 * 
 * @class 
 */
class SubmitElement extends ConfigurableElement {
    
    constructor(form,elementInitData) {
        super(form,elementInitData);
        
        var containerElement = this.getElement();

        this.submitDisabled = elementInitData.submitDisabled;
        this.cancelDisabled = elementInitData.cancelDisabled;

        let focusElementSet = false;
        
        //create the submit button
        if(elementInitData.onSubmit) {
            
            var onSubmit = () => {
                var formValue = form.getValue();
                elementInitData.onSubmit(formValue,form);
            };
            
            var submitLabel;
            if(elementInitData.submitLabel) { 
                submitLabel = elementInitData.submitLabel;
            }
            else {
                submitLabel = ConfigurablePanelConstants.DEFAULT_SUBMIT_LABEL;
            }
            
            this.submitButton = uiutil.createElement("button",{"className":"apogee_configurablePanelButton","innerHTML":submitLabel,"onclick":onSubmit});
            containerElement.appendChild(this.submitButton);

            this.setFocusElement(this.submitButton);
            focusElementSet = true;
        }
        else {
            this.submitButton = null;
        }
        
        //create the cancel button
        if(elementInitData.onCancel) {
            
            var onCancel = () => {
                elementInitData.onCancel(form);
            };
            
            var cancelLabel;
            if(elementInitData.cancelLabel) { 
                cancelLabel = elementInitData.cancelLabel;
            }
            else {
                cancelLabel = ConfigurablePanelConstants.DEFAULT_CANCEL_LABEL;
            }
            
            this.cancelButton = uiutil.createElement("button",{"className":"apogee_configurablePanelButton","innerHTML":cancelLabel,"onclick":onCancel});
            containerElement.appendChild(this.cancelButton);

            if(!focusElementSet) {
                this.setFocusElement(this.cancelButton);
                focusElementSet = true;
            }
        }
        else {
            this.cancelButton = null;
        }  

        this._setButtonState(); 
        
        //hint
        let hintElement = this.getHintElement(elementInitData);
        if(hintElement) {
            containerElement.appendChild(hintElement);
        }

        //help element
        let helpElement = this.getHelpElement(elementInitData);
        if(helpElement) {
            containerElement.appendChild(helpElement);
        }
        
        this._postInstantiateInit(elementInitData);
    }
    
    submitDisable(isDisabled) {
        this.submitDisabled = isDisabled;
        this._setButtonState();
    }
    
    cancelDisable(isDisabled) {
        this.cancelDisabled = isDisabled;
        this._setButtonState();
    }

    destroy() {
        super.destroy();

        if(this.submitButton) {
            this.submitButton.onclick = null;
            this.submitButton = null;
        }

        if(this.cancelButton) {
            this.cancelButton.onclick = null;
            this.cancelButton = null;
        }
    }

    //===================================
    // internal Methods
    //==================================
    
    _setDisabled(isDisabled) { 
        this.overallDisabled = isDisabled;
        this._setButtonState();
    }

    _setButtonState() {
        if(this.submitButton) this.submitButton.disabled = this.overallDisabled || this.submitDisabled;
        if(this.cancelButton) this.cancelButton.disabled = this.overallDisabled || this.cancelDisabled;
    }
}

SubmitElement.TYPE_NAME = "submit";

/** This is an text field element configurable element.
 * 
 * @class 
 */
class TextareaElement extends ConfigurableElement {
    constructor(form,elementInitData) {
        super(form,elementInitData);
        
        var containerElement = this.getElement();
        
        //label
        let labelElement = this.getLabelElement(elementInitData);
        if(labelElement) {
            containerElement.appendChild(labelElement);
        }
        
        //text field
        this.inputElement = uiutil.createElement("textarea");
        this.inputElement.style.verticalAlign = "top";
        if(elementInitData.rows) {
            this.inputElement.rows = elementInitData.rows;
        }
        if(elementInitData.cols) {
            this.inputElement.cols = elementInitData.cols;
        }
        containerElement.appendChild(this.inputElement); 

        this.setFocusElement(this.inputElement);

        //add dom listeners
        this.inputListener = () => this.inputDone();
        this.changeListener = () => this.valueChanged();
        this.inputElement.addEventListener("input",this.inputListener);
        this.inputElement.addEventListener("change",this.changeListener);

        //hint
        let hintElement = this.getHintElement(elementInitData);
        if(hintElement) {
            containerElement.appendChild(hintElement);
        }

        //help element
        let helpElement = this.getHelpElement(elementInitData);
        if(helpElement) {
            containerElement.appendChild(helpElement);
        }
        
        this._postInstantiateInit(elementInitData);
    }
    
    /** This method returns value for this given element, if applicable. If not applicable
     * this method returns undefined. */
    getValue() {
        return this.inputElement.value.trim();
    }   

    //==================================
    // protected methods
    //==================================

    /** This method updates the UI value for a given element. */
    setValueImpl(value) {
        this.inputElement.value = value;
    }

    destroy() {
        super.destroy();
        this.inputElement.removeEventListener("input",this.inputListener);
        this.inputElement.removeEventListener("change",this.changeListener);
        this.inputListener = null;
        this.changeListener = null;
        this.inputElement = null;
    }
    
    //===================================
    // internal Methods
    //==================================
    
    _setDisabled(isDisabled) { 
        this.inputElement.disabled = isDisabled;
    }
}

TextareaElement.TYPE_NAME = "textarea";

/** This is an text field element configurable element.
 * 
 * @class 
 */
class TextFieldElement extends ConfigurableElement {
    constructor(form,elementInitData) {
        super(form,elementInitData);
        
        var containerElement = this.getElement();
        
        //label
        let labelElement = this.getLabelElement(elementInitData);
        if(labelElement) {
            containerElement.appendChild(labelElement);
        }
        
        //text field (maight had password flag)
        var type = (elementInitData.password === true) ? "password" : "text";
        this.inputElement = uiutil.createElement("input",{"type":type});
        containerElement.appendChild(this.inputElement); 
        this.setFocusElement(this.inputElement);
        
        if(elementInitData.size !== undefined) {
            this.inputElement.size = elementInitData.size;
        }

        //add dom listeners
        this.inputListener = () => this.inputDone();
        this.changeListener = () => this.valueChanged();
        this.inputElement.addEventListener("input",this.inputListener);
        this.inputElement.addEventListener("change",this.changeListener);

        //hint
        let hintElement = this.getHintElement(elementInitData);
        if(hintElement) {
            containerElement.appendChild(hintElement);
        }

        //help element
        let helpElement = this.getHelpElement(elementInitData);
        if(helpElement) {
            containerElement.appendChild(helpElement);
        }
        
        this._postInstantiateInit(elementInitData);
    }

    getValue() {
        return this.inputElement.value;
    }  
    
    //===================================
    // protected Methods
    //==================================

    /** This method updates the UI value for a given element. */
    setValueImpl(value) {
        this.inputElement.value = value;
    }

    destroy() {
        super.destroy();
        this.inputElement.removeEventListener("input",this.inputListener);
        this.inputElement.removeEventListener("change",this.changeListener);
        this.inputListener = null;
        this.changeListener = null;
        this.inputElement = null;
    }

    //===================================
    // internal Methods
    //==================================
    
    _setDisabled(isDisabled) { 
        this.inputElement.disabled = isDisabled;
    }
}

TextFieldElement.TYPE_NAME = "textField";

/** This is a item that can be placed inside a panel container. In the initialization config it has child
 * configurable elements (and configurable layout containers), however any child configurable element is included as a
 * value in the parent panel. The configurable layout containers just holds to organize the DOM elements from its 
 * children.
 * 
 * @class 
 */
class ConfigurableLayoutContainer {
    constructor(form) {
        this.form = form;
        this.domElement = uiutil.createElement("div",{"className":ConfigurableElement.CONTAINER_CLASS});
        //udpate padding and margin to 0
        this.domElement.style.margin = ConfigurableElement.ELEMENT_MARGIN_NONE;
        this.domElement.style.padding = ConfigurableElement.ELEMENT_PADDING_NONE;

        this.childLayouts = [];
    }

    /** This method returns the DOM element for this layout container. */
    getElement() {
        return this.domElement;
    }
    
    /** This method returns the parent form for this configurable element. */
    getForm() {
        return this.form;
    }

    /** This is used to determine what type of child element this is for a panel. */
    get elementType() {
        return "ConfigurableLayoutContainer";
    }

    /** This function should be used to set the display state for the element, since that variable
     * is also used to control visibility. */
    setVisibleDisplayStyle(visibleDisplayStyle) {
        this.visibleDisplayStyle = visibleDisplayStyle;
        if(this.domElement.style.display != "none") {
            this.domElement.style.display = this.visibleDisplayStyle;
        }
    }

    //==================================
    //protected methods
    //==================================

    /** This method intializes the container */
    //initializeContainer(containerInitData);

    /** This method adds the element to the container. */
    //insertElement(elementObject,elementInitData));

    /** this is called internally to add an element to the panel. */
    addToContainer(elementInitData) {
        var elementObject = ConfigurablePanel.instantiateConfigurableType(this.form,elementInitData);

        //add the dom element for the child element
        this.insertElement(elementObject,elementInitData);

        //add the child configurable elements to the list
        if(elementObject instanceof ConfigurableElement) {
            //pass the element object to the form
            this.form.insertChildElement(elementObject);
        }
        else if(elementObject instanceof ConfigurableLayoutContainer) {
            this.childLayouts.push(elementObject);
        }
    }

    destroy() {
        this.childLayouts.forEach(childLayout => {
            childLayout.destroy();
        });
        this.childLayouts = [];
        this.form = null;
        this.domElement = null;
    }
      
}

/** This is a item that can be placed inside a panel container. In the initialization config it has child
 * configurable elements (and configurable layout containers), however any child configurable element is included as a
 * value in the parent panel. The configurable layout containers just holds to organize the DOM elements from its 
 * children.
 * 
 * @class 
 */
class HoriontalLayout extends ConfigurableLayoutContainer {
    constructor(form,containerInitData) {
        super(form);

        this._initializeContainer(containerInitData);
    }


    //==================================
    //protected methods
    //==================================

    /** This method adds the element to the container. */
    insertElement(elementObject,elementInitData) {
        //explicitly set child to display multiple on a line.
        elementObject.setVisibleDisplayStyle(ConfigurableElement.ELEMENT_DISPLAY_PARTIAL_LINE);

        //add the dom element
        let domElement = this.getElement();
        domElement.appendChild(elementObject.getElement());
    }

    //nothing to destroy
    
    //===================================
    // internal Methods
    //==================================

    /** This method intializes the container */
    _initializeContainer(containerInitData) {
        if(!Array.isArray(containerInitData.formData)) {
            throw new Error("Improper format for Horizontal layout config. It should have a array named 'formData'");
        }
        //add each child to the layout
        containerInitData.formData.forEach(elementInitData => this.addToContainer(elementInitData));
    }
 
}

HoriontalLayout.TYPE_NAME = "horizontalLayout";

/** This is a item that can be placed inside a panel container. In the initialization config it has child
 * configurable elements (and configurable layout containers), however any child configurable element is included as a
 * value in the parent panel. The configurable layout containers just holds to organize the DOM elements from its 
 * children.
 * 
 * @class 
 */
class ShowHideLayout extends ConfigurableLayoutContainer {
    constructor(form,containerInitData) {
        super(form);

        this.titleElement = null;
        this.bodyElement = null;
        this.control = null;
        this.headingElement = null;

        this.initialized = false;

        this.openedUrl = uiutil.getResourcePath("/opened_bluish.png");
        this.closedUrl = uiutil.getResourcePath("/closed_bluish.png");

        this._initializeContainer(containerInitData);
    }


    //==================================
    //protected methods
    //==================================

    /** This method adds the element to the container. */
    insertElement(elementObject,elementInitData) {
        //add the dom element
        this.bodyElement.appendChild(elementObject.getElement());
    }

    destroy() {
        super.destroy();
        
        this.titleElement = null;
        this.bodyElement = null;
        this.control = null;
        this.headingElement = null;

        this.initialized = false;
    }
    
    //===================================
    // internal Methods
    //==================================

    /** This method intializes the container */
    _initializeContainer(containerInitData) {
        let mainElement = this.getElement();
        
        //heading
        this.headingElement = document.createElement("div");
        this.headingElement.className = "apogee_configurableShowHideHeadingLine";
        mainElement.appendChild(this.headingElement);
        if(containerInitData.heading !== undefined) {
            this.titleElement = document.createElement("span");
            this.titleElement.innerHTML = containerInitData.heading;
            let level;
            if(containerInitData.level !== undefined) {
                level = containerInitData.level;
            }
            else {
                level = 4; //this is should be the level that is the same size as a label
            }
            let titleCssClass = "apogee_configurablePanelHeading_" + level;
            this.titleElement.className = titleCssClass;
            this.headingElement.appendChild(this.titleElement);
        }
        this.control = document.createElement("img");
        this.control.className = "apogee_configurableShowHideControl apogee_configurableElement_hideSelection";
        this.headingElement.appendChild(this.control);
        this.headingElement.onclick = () => this._toggleState();

        //body
        this.bodyElement = document.createElement("div");
        this.bodyElement.className = "apogee_configurableShowHideBody";
        mainElement.appendChild(this.bodyElement); 

        //set the initial open closed state
        let initialIsClosed = (containerInitData.closed === true);
        this._setState(initialIsClosed);

        //add each child to the layout
        if(!Array.isArray(containerInitData.formData)) {
            throw new Error("Improper format for Horizontal layout config. It should have a array named 'formData'");
        }
        containerInitData.formData.forEach(elementInitData => this.addToContainer(elementInitData));

        this.initialized = true;
    }

    _toggleState() {
        if(!this.initialized) return;

        this._setState(!this.isClosed);
    }

    _setState(isClosed) {
        this.isClosed = isClosed;
        if(this.isClosed) {
            this.bodyElement.style.display = "none";
            this.control.src = this.closedUrl;
        }
        else {
            this.bodyElement.style.display = "";
            this.control.src = this.openedUrl;
        }
    }
 
}

ShowHideLayout.TYPE_NAME = "showHideLayout";

ConfigurablePanel.addConfigurableElement(CheckboxElement);
ConfigurablePanel.addConfigurableElement(CheckboxGroupElement);
ConfigurablePanel.addConfigurableElement(ColorPickerElement);
ConfigurablePanel.addConfigurableElement(CustomElement);
ConfigurablePanel.addConfigurableElement(DropdownElement);
//ConfigurablePanel.addConfigurableElement(ExtendedDropdownElement);
ConfigurablePanel.addConfigurableElement(HeadingElement);
ConfigurablePanel.addConfigurableElement(HTMLDisplayElement);
ConfigurablePanel.addConfigurableElement(InvisibleElement);
ConfigurablePanel.addConfigurableElement(ListElement);
ConfigurablePanel.addConfigurableElement(PanelElement);
ConfigurablePanel.addConfigurableElement(RadioGroupElement);
ConfigurablePanel.addConfigurableElement(SliderElement);
ConfigurablePanel.addConfigurableElement(SpacerElement);
ConfigurablePanel.addConfigurableElement(SubmitElement);
ConfigurablePanel.addConfigurableElement(TextareaElement);
ConfigurablePanel.addConfigurableElement(TextFieldElement);

ConfigurablePanel.addConfigurableElement(HoriontalLayout);
ConfigurablePanel.addConfigurableElement(ShowHideLayout);



var apogeeui = /*#__PURE__*/Object.freeze({
    __proto__: null,
    uiutil: uiutil,
    dialogMgr: dialogMgr,
    bannerConstants: bannerConstants,
    getBanner: getBanner,
    getIconOverlay: getIconOverlay,
    Tab: Tab,
    TabFrame: TabFrame,
    Menu: Menu,
    SplitPane: SplitPane,
    TreeControl: TreeControl,
    TreeEntry: TreeEntry,
    DisplayAndHeader: DisplayAndHeader,
    ConfigurablePanel: ConfigurablePanel,
    getFormResultFunctionBody: getFormResultFunctionBody,
    wrapWithTooltip: wrapWithTooltip,
    getHelpElement: getHelpElement,
    showLegacyConfigurableDialog: showLegacyConfigurableDialog,
    showConfigurableDialog: showConfigurableDialog,
    showSimpleActionDialog: showSimpleActionDialog
});

//=====================================
// UI Entry Point
//=====================================

/** This method gets a callback to update the properties of a component. */
function updateComponent(componentView) {

    var app = componentView.getApp();
    var modelManager = app.getModelManager(); 
    var component = componentView.getComponent();
    
    var componentClass = component.constructor;
    var componentViewClass = componentView.constructor;

    var displayName = componentClass.displayName;
    var additionalLines = apogeeutil$1.jsonCopy(componentViewClass.propertyDialogLines); 

    var initialValues = component.getPropertyValues(modelManager.getModel()); 

    // add the folders to which we can move this (it can move to root only if it is a parent)
    let includeRootFolder = componentViewClass.hasTabEntry;
    var parentList = modelManager.getParentList(includeRootFolder);

    //create the dialog layout - do on the fly because folder list changes
    var dialogLayout = getPropertiesDialogLayout(displayName,parentList,additionalLines,false,initialValues);

    //create on submit callback
    var onSubmitFunction = function(submittedValues) {
        
        //get the changed values
        var newValues = {};
        for(var key in initialValues) {
            if(initialValues[key] !== submittedValues[key]) {
                newValues[key] = submittedValues[key];
            }
        }
        
        let commandsDeleteComponent = false;
        let deleteMsg;
        var commands = [];
        
        //--------------
        // Update Properties
        //--------------
        
        var memberUpdateJson = {};
        if(componentClass.transferMemberProperties) {
            componentClass.transferMemberProperties(newValues,memberUpdateJson);
        }
        var numMemberProps = apogeeutil$1.jsonObjectLength(memberUpdateJson);
        
        var componentUpdateJson = {};
        if(componentClass.transferComponentProperties) {
            componentClass.transferComponentProperties(newValues,componentUpdateJson);
        }
        var numComponentProps = apogeeutil$1.jsonObjectLength(componentUpdateJson);
        
        if((numMemberProps > 0)||(numComponentProps > 0)) {
            let updateCommand = {};
            updateCommand.type = "updateComponent";
            updateCommand.memberId = component.getMemberId();
            if(numMemberProps > 0) updateCommand.updatedMemberProperties = memberUpdateJson;
            if(numComponentProps > 0) updateCommand.updatedComponentProperties = componentUpdateJson;
            commands.push(updateCommand);
        }
        
        //--------------
        // Move
        //--------------
        
        if((newValues.name)||(newValues.parentId)) {
            
            //validate the name
            if(newValues.name) {
                var nameResult = validateTableName(newValues.name);
                if(!nameResult.valid) {
                    apogeeUserAlert(nameResult.errorMessage);
                    return false;
                }
            }

            let oldName = component.getName();

            let renameEditorCommands;

            //do the first stage of editor commands
            if(componentViewClass.hasChildEntry) {
                //load model view, will be used for old parent and new parent
                let appViewInterface = componentView.getAppViewInterface();

                if(appViewInterface.hasParentDisplays()) {
                    //look up the old parent component
                    let oldParentComponent = component.getParentComponent(modelManager);
                    //remove the component from the parent component document.
                    //if there is no parent component, we wil assume this was in the root folder
                    if(oldParentComponent) {
                        let oldParentComponentView = appViewInterface.getComponentViewByComponentId(oldParentComponent.getId());

                        if(newValues.parentId) {
                            //----------------------------
                            //move case
                            //delete old node
                            //----------------------------
                            let oldParentEditorCommand = oldParentComponentView.getRemoveApogeeNodeFromPageCommand(oldName);
                            commands.push(oldParentEditorCommand);
                        }
                        else if(newValues.name) {
                            //---------------------------
                            //rename case
                            //get the rename editr comamnds, then apply the one to clear the component node name
                            //----------------------------
                            renameEditorCommands = oldParentComponentView.getRenameApogeeNodeCommands(component.getMemberId(),oldName,newValues.name);
                            commands.push(renameEditorCommands.setupCommand);
                        }
                    }
                }
            }
            
            //update the component name
            let moveCommand = {};
            moveCommand.type = "moveComponent";
            moveCommand.memberId = component.getMemberId();
            moveCommand.newMemberName = submittedValues.name;
            moveCommand.newParentId = newValues.parentId;
            commands.push(moveCommand);

            //do the second stage of editor commands
            if(componentViewClass.hasChildEntry) {

                //-----------------------------------
                // move case
                // add the compone nodes to the new page after the component has been moved there
                //----------------------------------------------
                if(newValues.parentId) {
                    let newParentComponentId = modelManager.getComponentIdByMemberId(newValues.parentId);
                    //there will be no component id if we are putting this in the root folder
                    if(newParentComponentId) {
                        let appViewInterface = componentView.getAppViewInterface();
                        if(appViewInterface.hasParentDisplays()) {
                            let newParentComponentView = appViewInterface.getComponentViewByComponentId(newParentComponentId);

                            if(newParentComponentView) {
                                let newName = newValues.name ? newValues.name : oldName;

                                //insert node add at end of new page
                                let newParentCommands = newParentComponentView.getInsertApogeeNodeOnPageCommands(newName,true);
                                //added the editor setup command
                                if(newParentCommands.editorSetupCommand) commands.push(newParentCommands.editorSetupCommand);
                                //check if we need to add any delete component commands  - we shouldn't have any since we are not overwriting data here
                                if(newParentCommands.deletedComponentCommands) {
                                    //flag a delete will be done
                                    commandsDeleteComponent = true;
                                    deleteMsg = "This action deletes cells on the new page. Are you sure you want to do that? Deleted cells: " + deletedComponentNames;
                                    
                                    //return if user rejects
                                    if(!doDelete) return;
                                    
                                    commands.push(...newParentCommands.deletedComponentCommands);
                                }

                                //add the editor insert command
                                if(newParentCommands.editorAddCommand) commands.push(newParentCommands.editorAddCommand);
                            }
                        }
                    }
                    else {
                        if(!componentViewClass.hasTabEntry) {
                            //TBR if we want to enforce this condition...
                            throw new Error("This component can not be placed in the root folder.");
                        }
                    }

                }

                //----------------------------
                //rename case
                //set the new node name, after the compnoent rename is done
                //-------------------------------------------
                if(renameEditorCommands) {
                    //update apogee node name
                    commands.push(renameEditorCommands.setNameCommand);
                }
            }

        }
        
        //---------------
        // combine commands (as needed)
        //---------------

        var command;
        
        if(commands.length > 1) {
            //make a compound command
            command = {};
            command.type = "compoundCommand";
            command.childCommands = commands;
        }
        else if(commands.length === 1) {
            command = commands[0];
        }
        
        //command action
        let doAction = () => {
            if(command) {   
                app.executeCommand(command);
            }

            returnToEditor(componentView,submittedValues.name);
        };

        if(commandsDeleteComponent) {
            //if there is a delete, verify the user wants to do this
            let cancelAction = () => {
                returnToEditor(componentView,submittedValues.name);
            };
            apogeeUserConfirm(deleteMsg,"Delete","Cancel",doAction,cancelAction);
        }
        else {
            //otherwise just take the action
            doAction();
        }

        //return true to close the dialog
        return true;
    };

    //return focus to editor on cancel
    let onCancelFunction = () => returnToEditor(componentView);

    //show dialog
    showConfigurableDialog(dialogLayout,onSubmitFunction,onCancelFunction);
}

function returnToEditor(componentView) {
    let componentViewClass = componentView.constructor;
    if(componentViewClass.hasChildDisplay) {
        let parentComponentView = componentView.getParentComponentView();
        if(parentComponentView) {
            parentComponentView.giveEditorFocusIfShowing();
        }
    }
}

//========================
// dialog setup - this is shared with add component since it is the same basic action
//========================

//this is for a create or update dialog
//omit folder names (null) and folder initial value to omit the parent selection
function getPropertiesDialogLayout(displayName,folderNames,additionalLines,doCreate,initialValues) { 
    
    //create the dialog layout - do on the fly because folder list changes
    var dialogLayout = {};
    var lines = [];
    dialogLayout.layout = lines;

    var titleLine = {};
    titleLine.type = "heading";
    if(doCreate) {
        titleLine.text = "New " + displayName;
    }
    else {
        titleLine.text = "Update " + displayName; 
    }
    titleLine.level = 3;
    lines.push(titleLine);

    if(folderNames) {
        var parentLine = {};
        parentLine.type = "dropdown";
        parentLine.label = "Parent Page: ";
        parentLine.entries = folderNames;
        parentLine.key = "parentId"; 
        if(doCreate) {
            parentLine.state = "disabled";
        }
        lines.push(parentLine);
    }

    var nameLine = {};
    nameLine.type = "textField";
    nameLine.label = "Name: ";
    nameLine.size = 40,
    nameLine.key = "name";
    nameLine.focus = true;
    lines.push(nameLine);
    
    //add additioanl lines, if applicable
    if(additionalLines) {
        for(var i = 0; i < additionalLines.length; i++) {
            lines.push(additionalLines[i]);
        }
    }

    //submit
    // var submitLine = {};
    // submitLine.type = "submit";
    // if(doCreate) {
    //     submitLine.submit = "Create";
    // }
    // else {
    //     submitLine.submit = "Update";
    // }
    // submitLine.cancel = "Cancel";
    // lines.push(submitLine);
    
    //set the initial values
    if(initialValues) {
        for(var i = 0; i < lines.length; i++) {
            var line = lines[i];
            if(line.key) {
                line.value = initialValues[line.key];
            }
        }
    }
    
    return dialogLayout;
}

function deleteComponent(componentView) {

    let doDelete = () => {
        deleteComponentImpl(componentView);
        returnToEditor$1(componentView);
    };

    let doCancel = () => {
        returnToEditor$1(componentView);
    };
    let deleteMsg = "Are you sure you want to delete this object:" + componentView.getName() + "?";
    apogeeUserConfirm(deleteMsg,"Delete","Cancel",doDelete,doCancel);
}

function returnToEditor$1(componentView) {
    let parentComponentView = componentView.getParentComponentView();
    if(parentComponentView) {
        parentComponentView.giveEditorFocusIfShowing();
    }
}

function deleteComponentImpl(componentView) {

    var app = componentView.getApp(); 
    var component = componentView.getComponent();

    var member = component.getMember();
    var commands = [];

    if(componentView.constructor.hasChildEntry) {
        let parentComponentView = componentView.getParentComponentView();
        if(parentComponentView) {
            let editorCommand = parentComponentView.getRemoveApogeeNodeFromPageCommand(component.getName());
            commands.push(editorCommand);
        }
    }

    //model command
    var modelCommand = {};
    modelCommand.type = "deleteComponent";
    modelCommand.memberId = member.getId();
    commands.push(modelCommand);
    
    //combined command
    let commandData;
    if(commands.length > 1) {
        commandData = {};
        commandData.type = "compoundCommand";
        commandData.childCommands = commands;
    }
    else if(commands.length === 1) {
        commandData = commands[0];
    }
    else {
        return;
    }

    app.executeCommand(commandData);
}

/** This method shows a dialog to select from additional components. */
function showSelectComponentDialog(componentInfoList,onSelectFunction) {

    var dialog = dialogMgr.createDialog({"movable":true});
    
    //add a scroll container
    var contentContainer = uiutil.createElement("div",null,
        {
			"display":"block",
            "position":"relative",
            "top":"0px",
            "height":"100%",
            "overflow": "auto"
        });
	dialog.setContent(contentContainer,uiutil.SIZE_WINDOW_TO_CONTENT);
    
    var line;
    
	var content = uiutil.createElement("div",null,
			{
				"display":"table",
				"overflow":"hidden"
			});
	contentContainer.appendChild(content);
    
    var line;
  
    //title
    line = uiutil.createElement("div",{"className":"dialogLine"});
    line.appendChild(uiutil.createElement("div",{"className":"dialogTitle","innerHTML":"Select Component Type"}));
    content.appendChild(line);
    
    //folder selection
    line = uiutil.createElement("div",{"className":"dialogLine"});
    line.appendChild(document.createTextNode("Component:"));
    var select = uiutil.createElement("select");
    line.appendChild(select);
    componentInfoList.forEach( componentInfo => {
		select.add(uiutil.createElement("option",{"text":componentInfo.displayName,"value":componentInfo.uniqueName}));
    });
    content.appendChild(line);
    
    //buttons
    line = uiutil.createElement("div",{"className":"dialogLine"});
    var onCancel = function() {
        dialogMgr.closeDialog(dialog);
    };
    
    var onCreate = function() {
		var componentClass = select.value;
        onSelectFunction(componentClass);
        dialogMgr.closeDialog(dialog);
    };
    line.appendChild(uiutil.createElement("button",{"className":"dialogButton","innerHTML":"Create","onclick":onCreate}));
    line.appendChild(uiutil.createElement("button",{"className":"dialogButton","innerHTML":"Cancel","onclick":onCancel}));
    content.appendChild(line);
    
    dialog.setContent(content,uiutil.SIZE_WINDOW_TO_CONTENT);  
    
    //show dialog
    dialogMgr.showDialog(dialog);
}

/** This module initializes the default component view classes. */
let componentViewClassMap = {};

let ERROR_COMPONENT_VIEW_CLASS;

/** This method is used to register a new component view class for the user interface. */
function registerComponentView(viewClass) {
    componentViewClassMap[viewClass.componentName] = viewClass;
}

/** This method retrieves a component view class using the component unique name. */
function getComponentViewClass(componentName) {
    return componentViewClassMap[componentName];
}

function setErrorComponentView(errorComponentViewClass) {
    ERROR_COMPONENT_VIEW_CLASS = errorComponentViewClass;
}

//=====================================
// UI Entry Point
//=====================================

/** This functions initiates the add component action. It will create a dialog for the user to enter the relevent 
 * properties, with the values optionalInitialProperties preset. The created componenent will also use the 
 * property values in optionalBaseComponentValues, overridden by the user input properties where applicable. The member
 * created will be made using the optionalBaseMemberValues, agagin overidden by any user input values.  */   
//piggybackCommand is a temporary test!!!
function addComponent(appViewInterface,app,componentClass,optionalInitialProperties,optionalBaseMemberValues,optionalBaseComponentValues) {

        let componentViewClass = getComponentViewClass(componentClass.uniqueName);

        //get the active workspace
        var workspaceManager = app.getWorkspaceManager();
        if(!workspaceManager) {
            apogeeUserAlert("There is no open workspace.");
            return;
        }     

        var modelManager = workspaceManager.getModelManager();
        if(!modelManager) {
            apogeeUserAlert("The workspace has not been loaded yet.");
            return;
        }    

        //this is not a true test - the workspace and model can be presenet ith out the model loaded.

        
        //get the tyep display name
        var displayName = componentClass.displayName;
        
        //get any additional property content for dialog beyond basic properties
        var additionalLines = apogeeutil$1.jsonCopy(componentViewClass.propertyDialogLines); 
        
        //get the folder list
        let includeRootFolder = componentViewClass.hasTabEntry;
        var parentList = modelManager.getParentList(includeRootFolder);
        
        //create the dialog layout - do on the fly because folder list changes
        var dialogLayout = getPropertiesDialogLayout(displayName,parentList,additionalLines,true,optionalInitialProperties);

        //we will populate the parent if we need to insert thenew component as a child in the parent document. 
        
        
        //create on submit callback
        var onSubmitFunction = function(userInputProperties) {
            
            //validate the name
            var nameResult = validateTableName(userInputProperties.name);
            if(!nameResult.valid) {
                apogeeUserAlert(nameResult.errorMessage);
                return false;
            }

            //other validation of inputs?

//we should do this cleaner - by storing parent id in the submit input
            let parentMemberId = userInputProperties.parentId;

            let commandsDeleteComponent = false;
            let deleteMsg;
            let commands = [];
            
            //create the model command
            let createCommandData = {};
            createCommandData.type = "addComponent";
            createCommandData.parentId = parentMemberId;
            createCommandData.memberJson = Component.createMemberJson(componentClass,userInputProperties,optionalBaseMemberValues);
            createCommandData.componentJson = Component.createComponentJson(componentClass,userInputProperties,optionalBaseComponentValues);

            //editor related commands
            let additionalCommandInfo;
            let parentComponentView;
            if(componentViewClass.hasChildEntry) {
                let parentComponentId = modelManager.getComponentIdByMemberId(parentMemberId);
                if((parentComponentId)&&(appViewInterface.hasParentDisplays())) {
                    parentComponentView = appViewInterface.getComponentViewByComponentId(parentComponentId);
                    if(!parentComponentView) throw new Error("Parent component not found!");

                    additionalCommandInfo = getAdditionalCommands(parentComponentView,userInputProperties.name);

                    //added the editor setup command
                    if(additionalCommandInfo.editorSetupCommand) commands.push(additionalCommandInfo.editorSetupCommand);

                    //add any delete commands
                    //NOTE - currently we do not overwiret, so this will not be triggered
                    if(additionalCommandInfo.deletedComponentCommands){
                        //flag a delete will be done
                        commandsDeleteComponent = true;
                        deleteMsg = "This action will delete the selected cells. Are you sure you want to do that? Cells to delete: " + additionalCommandInfo.deletedComponentShortNames;

                        commands.push(...additionalCommandInfo.deletedComponentCommands);
                    } 
                }
            }

            //store create command
            commands.push(createCommandData);

            //add the editor insert command
            if((additionalCommandInfo)&&(additionalCommandInfo.editorAddCommand)) {
                commands.push(additionalCommandInfo.editorAddCommand);
            }
            
            let commandData;
            if(commands.length > 1) {
                commandData = {};
                commandData.type = "compoundCommand";
                commandData.childCommands = commands;
            }
            else if(commands.length === 1) {
                commandData = commands[0];
            }
            else {
                //this shouldn't happen
                return;
            }
            
            //execute command
            let doAction = () => {
                app.executeCommand(commandData);

                //give focus back to editor
                if(parentComponentView) {
                    parentComponentView.giveEditorFocusIfShowing();
                }
            };

            if(commandsDeleteComponent) {
                //if there is a delete, verify the user wants to do this
                let cancelAction = () => {
                    //give focus back to editor
                    if(parentComponentView) {
                        parentComponentView.giveEditorFocusIfShowing();
                    }
                };
                apogeeUserConfirm(deleteMsg,"OK","Cancel",doAction,cancelAction);
            }
            else {
                //otherwise just take the action
                doAction();
            }

            //return true to close the dialog
            return true;

        };

        //give foxus back to editor
        let onCancelFunction = () => null;        
        //show dialog
        showConfigurableDialog(dialogLayout,onSubmitFunction,onCancelFunction);
}


/** This gets a callback to add an "additional" component, menaing one that is not
 * in the main component menu. */
function addAdditionalComponent(appViewInterface,app,optionalInitialProperties,optionalBaseMemberValues,optionalBaseComponentValues) {
        
    var onSelect = function(componentUniqueName) {
        let componentClass = componentInfo.getComponentClass(componentUniqueName);
        if(componentClass) {
            addComponent(appViewInterface,app,componentClass,optionalInitialProperties,optionalBaseMemberValues,optionalBaseComponentValues);
        }
        else {
            apogeeUserAlert("Unknown component type: " + componentType);
        }
    };
    //get the display names
    let additionalComponents = componentInfo.getAdditionalComponentNames();
    let componentInfoList = additionalComponents.map( componentName => {
        let componentClass = componentInfo.getComponentClass(componentName); 
        return {displayName: componentClass.displayName, uniqueName: componentName};
    });
    //open select component dialog
    showSelectComponentDialog(componentInfoList,onSelect);
}

/** This is to get an commands needed to add the a child node onto a parent page. */
function getAdditionalCommands(parentComponentView,childName) {
    //check selection
    let useParentSelection = getUseParentSelection(parentComponentView);
    
    let insertAtEnd = !useParentSelection;

    return parentComponentView.getInsertApogeeNodeOnPageCommands(childName,insertAtEnd);
}

function getUseParentSelection(parentComponentView) {
    //use the parent selection only if the tab is the active tab
    //otherwise the component should be placed at the end

    let tabDisplay = parentComponentView.getTabDisplay();
    if(!tabDisplay) return false;

    let tab = tabDisplay.getTab();
    if(!tab) return false;
    
    return tabDisplay.getIsShowing();
}

/** This component represents a json table object. */
class TreeComponentDisplay {

    constructor(componentView) {
        this.componentView = componentView;
        
        this.treeEntry = this._createTreeEntry();
        this._setBannerState();

        //opnly needed for parents...
        this.treeEntry.setSortFunction(TreeComponentDisplay.treeSortFunction);
        //this should be overwritten in component
        this.treeEntry.setExtraSortParam(0);
    };

    getTreeEntry() {
        return this.treeEntry;
    }

    getState() {
        return this.treeEntry.getState();
    }

    setState(state) {
        this.treeEntry.setState(state);
    }

    setComponentTypeSortOrder(typeSortOrder) {
        this.treeEntry.setExtraSortParam(typeSortOrder);
    }

    // changeParent(newParentComponent,oldParentComponent) {
    //     var oldParentTreeEntry = oldParentComponent.getTreeEntry();
    //     oldParentTreeEntry.removeChild(this.treeEntry);
        
    //     var newParentTreeEntry = newParentComponent.getTreeEntry();
    //     newParentTreeEntry.addChild(this.treeEntry);
    // }

    deleteDisplay() {
        apogeeUserAlert("Delete tree component display not implemneted");
    }

    componentUpdated(component) {

        if(component.isMemberFieldUpdated("member","name")) {
            this._setLabel();
        }

        if(component.isStateUpdated()) {
            this._setBannerState();
        }
    }
    //===============================
    // Private Functions
    //===============================

    /** @private */
    _createTreeEntry() {
        //TREE_ENTRY
        //FIX THIS CODE!!!
        //open doesn't work and the context menu is duplicated code (that shouldn't be)
        
        //menu item callback
        var menuItemCallback = () => {
            //open menu item
            var menuItemList = [];
            var openMenuItem = this.componentView.getOpenMenuItem();
            if(openMenuItem) {
                menuItemList.push(openMenuItem);
            }

            var component = this.componentView.getComponent();

            //add child folder menu item
            if(this.componentView.usesTabDisplay()) {
                let app = this.componentView.getApp();
                var appViewInterface = this.componentView.getAppViewInterface();
                let initialValues = {parentId: component.getMemberId()};
                let pageComponents = componentInfo.getPageComponentNames();
                pageComponents.forEach(pageComponentName => {
                    let childMenuItem = {};
                    let pageComponentClass = componentInfo.getComponentClass(pageComponentName);
                    childMenuItem.title = "Add Child " + pageComponentClass.displayName;
                    childMenuItem.callback = () => addComponent(appViewInterface,app,pageComponentClass,initialValues);
                    menuItemList.push(childMenuItem);
                });
            }

            return this.componentView.getMenuItems(menuItemList);
        };
        
        //double click callback
        var openCallback = this.componentView.createOpenCallback();
        
        var component = this.componentView.getComponent();
        var modelManager = this.componentView.getApp().getModelManager();
        var labelText = this.componentView.getName();
        var iconUrl = this.componentView.getIconUrl();
        var isRoot = component.getParentComponent(modelManager) ? true : false;
        return new TreeEntry(labelText, iconUrl, openCallback, menuItemCallback,isRoot);
    }

    _setLabel() {
        let displayName = this.componentView.getName();
        this.treeEntry.setLabel(displayName);
    }

    _setBannerState() {
        this.treeEntry.setBannerState(this.componentView.getBannerState(),this.componentView.getBannerMessage());
    }

    /** This is used to sort the child tree entries. 
     * We allow for a different ordering for different types by using the extrar sort parameter.
     * (for now, we put folers first. Other component type parameters can be set too) */
    static treeSortFunction(entry1,entry2) {
        var typeOrderDiff = (entry1.getExtraSortParam() - entry2.getExtraSortParam());
        if(typeOrderDiff) {
            return typeOrderDiff;
        }
        else {
            return entry1.getLabel().localeCompare(entry2.getLabel());
        }
    }
}

/** This is the base functionality for a component. */
class ComponentView {

    /** This takes the appViewInterface and the componnet view's assoicated component.
     * In the full UI the appViewInterface is nominally the modelView. However, this 
     * abstraction was added to allow use embedded in a web page as an alternate UI. 
     */
    constructor(appViewInterface,component) {
        
        this.app = appViewInterface.getApp();
        this.appViewInterface = appViewInterface;
        this.component = component;
        //this is to record the latest parent view to which this was added
        this.lastAssignedParentComponentView = null;
        
        //ui elements
        this.childComponentDisplay = null; //this is the main display, inside the parent tab
        this.childDisplayState = null;
        
        this.tabDisplay = null; //only valid on parents, which open into a tab
        
        this.treeDisplay = null; //this is shown in the tree view
        this.treeState = null;

        this.component.setViewStateCallback(() => this.getViewState());

        //state info
        this.stateUpdated = false;
        this.state = null;
        this.bannerMessage = null;
        this.errorInfoList = null;
    }

    //==============================
    // Public Instance Methods
    //==============================

    /** This method returns the base member for this component. */
    getComponent() {
        return this.component;
    }

    getApp() {
        return this.app;
    }

    getName() {
        return this.component.getName();
    }

    getFullName(model) {
        return this.component.getFullName(model);
    }

    /** This method returns a display name for the member object. */
    getDisplayName(useFullPath,modelForFullPathOnly) {
        return this.component.getDisplayName(useFullPath,modelForFullPathOnly);
    }

    /** This method returns true if the display name field is updated. It is only applicable if 
     * the full path is NOT used. */
    isDisplayNameUpdated() {
        return this.component.isDisplayNameUpdated();
    }

    /** This method returns true if the component state was updated in the last component update. */
    isStateUpdated() {
        return this.isStateUpdated;
    }

    /** This gets the state for the component. */
    getBannerState() {
        if(this.state == null) this._createMemberStateInfo();
        return this.state;
    }

    /** This gets the state message for the component. */
    getBannerMessage() {
        if(this.state == null) this._createMemberStateInfo();
        return this.bannerMessage;
    }

    /** This gets the error info for the component. */
    getErrorInfoList() {
        if(this.state == null) this._createMemberStateInfo();
        return this.errorInfoList;
    }

    /** This method gets the parent component view of the current component view. 
     * This method does not depends only on the relation between the components, 
     * rather than any relationship established between the component views. This should give the
     * same result getLastAssignedParentComponentView except during a delete or move operation. 
     * This may return null if there is no parent component view. */
    getParentComponentView() {
        if(this.appViewInterface.hasParentDisplays()) {
            let parentComponent = this.component.getParentComponent(this.appViewInterface.getModelManager());
            if(parentComponent) {
                return this.appViewInterface.getComponentViewByComponentId(parentComponent.getId());
            }
        }
        //if we get here, no parent component view looked up
        return null;
    }

    /** This sets the assigned parent component view. This should be done for
     * bookkeeping so it can be removed suring a move or delete operation. */
    setLastAssignedParentComponentView(parentComponentView) {
        this.lastAssignedParentComponentView = parentComponentView;

    }

    /** This method gets the assigned parent component view, which may not
     * be the view corresponding to the current parent component. This should differ 
     * only during move or delete operations. */
    getLastAssignedParentComponentView() {
        return this.lastAssignedParentComponentView;

    }

    /** This method returns the icon url for the component. */
    getIconUrl() {
        if(this.constructor.ICON_URL) {
            return this.constructor.ICON_URL;
        }
        else {
            var resPath = this.constructor.ICON_RES_PATH;
            if(!resPath) {
                if(this.usesTabDisplay()) {
                    resPath = ComponentView.DEFAULT_PAGE_ICON;
                }
                else {
                    resPath = ComponentView.DEFAULT_CELL_ICON;
                }
            }
            return uiutil.getResourcePath(resPath);
        }
    }

    /** The appViewInterface connects the component with the rest of the UI. THis is a base class
     * for ModelView and has been pulled out to allow replacement of the UI by embedding component output
     * in a web page. */
    getAppViewInterface() {
        return this.appViewInterface;
    }

    /** This returns the appViewInterface, which replaces and is a base class for the model view 
     * @deprecated */
    getModelView() {
        return this.appViewInterface;
    }

    /** This method is called when the workspace is closing */
    closeWorkspace() {
        this.onDelete();
    }

    //-----------------------------------
    // Save methods
    //-----------------------------------

    
    /** This method reads the current UI state and saves it to the component. */
    getViewState() {
        let json = {};
        let statePresent = false;

        //get the child display state
        let activeChildDisplayState;
        if(this.childComponentDisplay) {
            activeChildDisplayState = this.childComponentDisplay.getStateJson();
        }
        else {
            activeChildDisplayState = this.childDisplayState;
        }

        if(activeChildDisplayState !== undefined) {
            json.childDisplayState = activeChildDisplayState;
            statePresent = true;
        }
    
        //get the tree display state
        let activeTreeState;
        if(this.treeDisplay) {
            activeTreeState = this.treeDisplay.getState();
        }
        else {
            activeTreeState = this.treeState; 
        }

        if((activeTreeState !== undefined)&&(activeTreeState != TreeEntry.NO_CONTROL)) {
            json.treeState = activeTreeState;
            statePresent = true;
        }

        //allow the specific component implementation to write to the json
        if(this.writeToJson) {
            statePresent = this.writeToJson(json);
        }

        if(this.tabDisplay) {
            json.tabOpened = true;
            var tab = this.tabDisplay.getTab();
            if(tab.getIsShowing()) {
                json.tabShowing = true;
            }
            statePresent = true;
        }

        //return the state
        if(statePresent) {
            return json;
        }
        else {
            return undefined;
        }
    }

    /** This method reads the UI state from the component. */
    loadViewStateFromComponent() {
        let json = this.component.getCachedViewState();
        if(!json) return;

        //set the tree state
        if((json.treeState !== undefined)&&(json.treeState !== null)) {
            if(this.treeDisplay) {
                this.treeDisplay.setState(json.treeState);
                this.treeState = null;
            }
            else {
                this.treeState = json.treeState;
            }
        }
        
        //set window options
        if((json.childDisplayState !== undefined)||(json.childDisplayState !== null)) {
            if(this.childComponentDisplay) {
                this.childComponentDisplay.setStateJson(json.childDisplayState);
                this.childDisplayState = null;
            }
            else {
                this.childDisplayState = json.childDisplayState;
            }
        }
        
        //allow the component implemnetation ro read from the json
        if(this.readFromJson) {
            this.readFromJson(json);
        }

        //check the tab display state (where tabs are used)
        if(json.tabOpened) {
            let setShowing = json.tabShowing;
            this.createTabDisplay(setShowing);
        }
    }

    /** This method can be implemented if the component view has additional state to save.
     * It should return true if state was added, and false otherwise. */
    //writeToJson(json) { return false;}

    /** This method can be implemented if the component view has additional state saved. */
    //readFromJson(json) {}

    //-------------------
    // tree entry methods - this is the element in the tree view
    //-------------------
    getTreeEntry() {
        if(!this.treeDisplay) {
            this.treeDisplay = this.createTreeDisplay();
        }
        return this.treeDisplay.getTreeEntry();
    }

    /** @protected */
    createTreeDisplay() {
        var treeDisplay = new TreeComponentDisplay(this);

        if((this.treeState !== undefined)&&(this.treeState !== null)) {
            treeDisplay.setState(this.treeState);
        }
        
        //default sort order within parent
        var treeEntrySortOrder = (this.constructor.TREE_ENTRY_SORT_ORDER !== undefined) ? this.constructor.TREE_ENTRY_SORT_ORDER : ComponentView.DEFAULT_COMPONENT_TYPE_SORT_ORDER;
        treeDisplay.setComponentTypeSortOrder(treeEntrySortOrder);
        
        return treeDisplay;
    }

    //-------------------
    // component display methods - this is the element in the parent tab (main display)
    //-------------------

    setComponentDisplay(childComponentDisplay) {
        this.childComponentDisplay = childComponentDisplay; 
        if(this.childDisplayState) {
            this.childComponentDisplay.setStateJson(this.childDisplayState);
            this.childDisplayState = null;
        }
    }

    getComponentDisplay() {
        return this.childComponentDisplay;
    }

    /** This gets the data display instance that is currently loaded in the display. It returns null 
     * if the data display is not loaded. */
    getCurrentDataDisplayInstance(viewType) {
        if(this.childComponentDisplay) {
            return this.childComponentDisplay.getDataDisplay(viewType);
        }
        else {
            return null;
        }
    }

    closeComponentDisplay() {
        if(this.childComponentDisplay) {
            //first store the window state
            this.childDisplayState = this.childComponentDisplay.getStateJson();
            
            //delete the display
            this.childComponentDisplay.deleteDisplay();
            this.childComponentDisplay = null;
        }
    }

    //-------------------
    // tab display methods - this is the tab element, only used for parent members
    //-------------------

    /** This indicates if the component has a tab display. */
    usesTabDisplay() {
        return this.constructor.hasTabEntry;
    }
    //Implement in extending class:
    ///** This creates the tab display for the component. */
    //instantiateTabDisplay();

    createTabDisplay(makeActive) {
        if((this.usesTabDisplay())&&(!this.tabDisplay)) {
            var tabFrame = this.appViewInterface.getTabFrame();
            if(tabFrame) {

                this.tabDisplay = this.instantiateTabDisplay();

                //add the tab display to the tab frame
                let tab = this.tabDisplay.getTab();
                tabFrame.addTab(tab,makeActive);
            }
        }
    }

    getTabDisplay() {
        return this.tabDisplay;
    }

    /** This closes the tab display for the component. */
    closeTabDisplay() {
        if(this.tabDisplay) {
            var tabDisplay = this.tabDisplay;
            this.tabDisplay = null;
            tabDisplay.closeTab();
            tabDisplay.destroy();    
        }
    }

    //-------------------
    // Menu methods
    //-------------------

    getMenuItems(optionalMenuItemList) {
        //menu items
        var menuItemList = optionalMenuItemList ? optionalMenuItemList : [];
            
        //add the standard entries
        var itemInfo = {};
        itemInfo.title = "Edit Properties";
        itemInfo.callback = () => updateComponent(this);
        menuItemList.push(itemInfo);

        var itemInfo = {};
        itemInfo.title = "Delete";
        itemInfo.callback = () => deleteComponent(this);
        menuItemList.push(itemInfo);
        
        return menuItemList;
    }

    getOpenMenuItem () {
        var openCallback = this.createOpenCallback();
        if(openCallback) {
            var itemInfo = {};
            itemInfo.title = "Open";
            itemInfo.callback = openCallback;
            return itemInfo;
        }
        else {
            return null;
        }
    }

    //==============================
    // Protected Instance Methods
    //==============================

    /** This method cleans up after a delete. Any extending object that has delete
     * actions should pass a callback function to the method "addClenaupAction" */
    onDelete() {
        if(this.tabDisplay) {
            this.closeTabDisplay();
        }
    }

    /** This method extends the member udpated function from the base.
     * @protected */    
    componentUpdated(component) {
        //set the new component
        this.component = component;
        this.component.setViewStateCallback(() => this.getViewState());

        //clear the locally stored member state info, It will be reconstructed on demand
        this.stateUpdated = this.component.isStateUpdated();
        if(this.stateUpdated) {
            this._clearMemberStateInfo();
        }

        //check for parent change
        if(component.isFieldUpdated("member")) {
            let member = component.getMember();
            if((member.isFieldUpdated("parentId"))&&(this.appViewInterface.hasParentDisplays())) {
                var oldParentComponentView = this.getLastAssignedParentComponentView();
                var newParentComponentView = this.getParentComponentView();

                if(oldParentComponentView != newParentComponentView) {
                    //remove from old parent component
                    if(oldParentComponentView) {
                        oldParentComponentView.removeChild(this);
                        //delete all the window display
                        if(this.childComponentDisplay) {
                            this.childComponentDisplay.deleteDisplay();
                            this.childComponentDisplay = null;
                        }
                    }
                    else {
                        //this was in the root folder
                        this.appViewInterface.removeChildFromRoot(this);
                    }

                    //add to the new parent component
                    if(newParentComponentView) {
                        newParentComponentView.addChild(this);
                        this.setLastAssignedParentComponentView(newParentComponentView);
                    }
                    else {
                        //this is placed in the root folder
                        this.appViewInterface.addChildToRoot(this);
                        this.setLastAssignedParentComponentView(null);
                    }
                }
            }  
        }
        
        //update for new data
        if(this.treeDisplay) {
            this.treeDisplay.componentUpdated(component);
        }
        if(this.childComponentDisplay != null) {
            this.childComponentDisplay.componentUpdated(component);
        }
        if(this.tabDisplay != null) {
            this.tabDisplay.componentUpdated(component);
        }
    }

    //=============================
    // Action UI Entry Points
    //=============================

    /** This method creates a callback for opening the component. 
     *  @private */
    createOpenCallback() {
        var openCallback;
        
        var makeTabActive = function(tabComponent) {
            var tabDisplay = tabComponent.getTabDisplay();
            if(tabDisplay) {
                var tab = tabDisplay.getTab();
                tab.makeActive();
            }
            else {
                //create the tab display - this automaticaly puts it in the tab frame
                tabComponent.createTabDisplay(true);
            }
        };
        
        if(this.usesTabDisplay()) {
            openCallback = () => {
                makeTabActive(this);

                // //allow time for UI to be created and then select start fo doc
                // //this will also give the doc focus
                // setTimeout(() => {
                //     let tabDisplay = this.getTabDisplay();
                //     if(tabDisplay.selectStartOfDocument) {
                //         tabDisplay.selectStartOfDocument();
                //     }
                // },0);
            };
        }
        else {
            //remove the tree from the parent
            openCallback = () => {
                var parentComponentView = this.getParentComponentView();
                if((parentComponentView)&&(parentComponentView.constructor.hasTabEntry)) {

                    //execute command to select child
                    let command = parentComponentView.getSelectApogeeNodeCommand(this.getName());
                    this.getApp().executeCommand(command);

                    //open the parent and bring this child to the front
                    makeTabActive(parentComponentView);

                }
            };
        }
        
        return openCallback;
    }

    //---------------------------
    // Member (model) state
    //---------------------------


    /** THis clears the member state info */
    _clearMemberStateInfo() {
        this.state = null;
        this.bannerMessage = null;
        this.errorInfoList = null;
    }

    _createMemberStateInfo() {
        //state matches state of main member
        let member = this.component.getMember();
        this.state = member.getState();

        switch(this.state) {
            case apogeeutil$1.STATE_NORMAL:
                this.bannerMessage = "";
                this.errorInfoList = null;
                break;

            case apogeeutil$1.STATE_PENDING:
                this.bannerMessage = bannerConstants.PENDING_MESSAGE;
                this.errorInfoList = null;
                break;

            case apogeeutil$1.STATE_INVALID:
                this.bannerMessage = bannerConstants.INVALID_MESSAGE;
                this.errorInfoList = null;
                break;

            case apogeeutil$1.STATE_ERROR:
                this._constructErrorInfo();
                break;

            default:
                this.bannerMessage = "Unknown state: " + state;
                this.errorInfoList = null;
                break; 
        }
    }

    /** This constructs the error info for the component. It should be called when 
     * the component is in the error state. */
    _constructErrorInfo() {
        let memberFieldMap = this.component.getMemberFieldMap();
        let memberDataList = [];
        let memberCount = 0;
        //get the error info for the member(s) for their component
        for(let id in memberFieldMap) {
            let lookupName = memberFieldMap[id];
            let member = this.component.getField(lookupName);
            memberCount++;
            let memberError = member.getError();
            if(memberError) {
                let memberData = {};
                let saveError;
                memberData.name = member.getName();
                if(memberError.isDependsOnError) {
                    //for a dependency error, we remove mention of depends on error that are internal
                    //to the component, keeping only depends on errors from external member
                    let {hasError, msg, errorInfoList} = this._processDependencyError(memberError, memberFieldMap);
                    saveError = hasError;
                    memberData.msg = msg;
                    if(errorInfoList) memberData.errorInfoList = errorInfoList;
                }
                else {
                    memberData.msg = memberError.toString();
                    if(memberError.errorInfoList) memberData.errorInfoList = memberError.errorInfoList;
                    saveError = true;
                }
                
                if(saveError) memberDataList.push(memberData);
            }   
        }

        if(memberDataList.length > 0) {
            if(memberCount == 1) {
                //single member component
                let memberData = memberDataList[0];
                this.bannerMessage = memberData.msg;
                this.errorInfoList = memberData.errorInfoList ? memberData.errorInfoList : [];
            }
            else {
                //compond component (multi member)
                this.bannerMessage = memberDataList.map( memberData => memberData.name + ": " + memberData.msg).join("; ");
                let multiMemberErrorInfo = {};
                multiMemberErrorInfo.type = "multiMember";
                multiMemberErrorInfo.memberEntries = [];
                //collect existing error info lists
                memberDataList.forEach( memberData => {
                    if((memberData.errorInfoList)&&(memberData.errorInfoList.length > 0)) {
                        multiMemberErrorInfo.memberEntries.push({
                            name: memberData.name,
                            errorInfoList: memberData.errorInfoList
                        });
                    }
                });
                if(multiMemberErrorInfo.memberEntries.length > 0) this.errorInfoList = [multiMemberErrorInfo];
                else this.errorInfoList = [];
            }
        }
        else {
            this.bannerMessage = "Unknown Error";
        }

    }

    /** For dependency errors, we will get rid of an error reference where the dependency is on another
     * member that is in this same component. We want our error display to only show external errors */
    _processDependencyError(memberError, memberFieldMap) {
        let msg, errorInfoList;
        let hasError = false;
        if(memberError.errorInfoList){
            let dependencyErrorInfo = memberError.errorInfoList.find(entry => entry.type == "dependency");
            if(dependencyErrorInfo) {
                //dependency error info - keep any member reference that is not an internal member
                let newDependsOnErrorList = dependencyErrorInfo.dependsOnErrorList.filter( dependsOnEntry => (memberFieldMap[dependsOnEntry.id] === undefined) );
                if(newDependsOnErrorList.length > 0) {
                    hasError = true;
                    //update message to give depends on members in error
                    let msgPrefix = (newDependsOnErrorList.length === 1) ? "Error in dependency: " : "Error in dependencies: ";
                    msg = msgPrefix + newDependsOnErrorList.map(dependsOnEntry => dependsOnEntry.name).join(", ");
                }
            }
        }
        //we do not keep the error info list. All data is shown in the message.
        errorInfoList = [];
        return {hasError, msg, errorInfoList};
    }
}

//These parameters are used to order the components in the tree entry.
ComponentView.DEFAULT_COMPONENT_TYPE_SORT_ORDER = 5;
ComponentView.FOLDER_COMPONENT_TYPE_SORT_ORDER = 0;

ComponentView.DEFAULT_CELL_ICON = "/icons3/genericCellIcon.png";
ComponentView.DEFAULT_CELL_ICON = "/icons3/pageIcon.png";

ComponentView.MENU_ITEM_OPEN = 0x01;

/** this is the name for the info data view, a standard data view for components. */
ComponentView.VIEW_INFO = "Info";

ComponentView.VIEW_INFO_MODE_ENTRY = {name: ComponentView.VIEW_INFO, label: "Info", isActive: true, isTransient: true, isInfoView: true};
//ComponentView.VIEW_INFO_MODE_ENTRY = {name: ComponentView.VIEW_INFO, label: "<span style='background-color: rgba(255,0,0,.7); color: white; border:2px solid rgba(255,0,0,.7);'>Info</span>", isActive: true, isTransient: true, isInfoView: true}
//ComponentView.VIEW_INFO_MODE_ENTRY = {name: ComponentView.VIEW_INFO, label: "<span style='color: red;'>Info</span>", isActive: true, isTransient: true, isInfoView: true}

/** 
 * This namespace includes some data display constants.
 * @namespace
 */
let DATA_DISPLAY_CONSTANTS = {};

//these are responses to hide request and close request
DATA_DISPLAY_CONSTANTS.UNSAVED_DATA = -1;
DATA_DISPLAY_CONSTANTS.CLOSE_OK = 1;

//this should probably go somewhere else
DATA_DISPLAY_CONSTANTS.NO_EDIT_BACKGROUND_COLOR = "#f4f4f4";

//display view size constants
DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MODE_SOME = "resize_height_mode_some";
DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MODE_MAX = "resize_height_mode_max";

DATA_DISPLAY_CONSTANTS.RESIZE_SHOW_FLAG = 1;
DATA_DISPLAY_CONSTANTS.RESIZE_MODE_MAX_FLAG = 2;
DATA_DISPLAY_CONSTANTS.RESIZE_DISABLE_LESS_FLAG = 4;
DATA_DISPLAY_CONSTANTS.RESIZE_DISABLE_MORE_FLAG = 8;
DATA_DISPLAY_CONSTANTS.RESIZE_DISABLE_MAX_FLAG = 16;

//These are the typesof messages that can be posted to the display container
DATA_DISPLAY_CONSTANTS.MESSAGE_TYPE_NONE = "none";
DATA_DISPLAY_CONSTANTS.MESSAGE_TYPE_ERROR = "error";
DATA_DISPLAY_CONSTANTS.MESSAGE_TYPE_WARNING = "warning";
DATA_DISPLAY_CONSTANTS.MESSAGE_TYPE_INFO = "info";

//The data source should return data with this key and value to signify the return data is encapsulated
//in addition to the key and value below. The following fields are allowed:
// - data - this is the data to display (optional)
// - messageType - this is the message type (optional)
// - message - this is the message (optional)
// - removed - this is set to true if we want to display removed, or false otherwise (optional) 
DATA_DISPLAY_CONSTANTS.WRAPPED_DATA_KEY = "wrapped_data";
DATA_DISPLAY_CONSTANTS.WRAPPED_DATA_VALUE = {}; //must use this exactly, not a copy

//These are used in ata view definition settings
DATA_DISPLAY_CONSTANTS.VIEW_SOURCE_TYPE_FUNCTION = "function";
DATA_DISPLAY_CONSTANTS.VIEW_SOURCE_TYPE_DATA = "data";
DATA_DISPLAY_CONSTANTS.VIEW_SOURCE_TYPE_PRIVATE_CODE = "private code";
DATA_DISPLAY_CONSTANTS.VIEW_SOURCE_TYPE_OTHER_CODE = "other code";

//These are used in ata view definition settings
DATA_DISPLAY_CONSTANTS.VIEW_SOURCE_LAYER_MODEL = "model";
DATA_DISPLAY_CONSTANTS.VIEW_SOURCE_LAYER_APP = "app";

let dataDisplayHelper = {};


/** This function creates the data display data source  for the data of the given member. The
 * member field should be the field name used to access the data source from the associated component. */
dataDisplayHelper.getMemberDataJsonDataSource = function(app,componentView,memberFieldName,doReadOnly) {

    //this is used internally to lookup the data member used here
    let _getDataMember = function() {
        let component = componentView.getComponent();
        let member = component.getField(memberFieldName);
        return member;
    };
    
    return {

        doUpdate: function() {
            //return value is whether or not the data display needs to be udpated
            let component = componentView.getComponent();
            let reloadData = component.isMemberDataUpdated(memberFieldName);
            let reloadDataDisplay = false;
            return {reloadData,reloadDataDisplay};
        },

        getData: function() {
            let member = _getDataMember();
            return dataDisplayHelper.getStandardWrappedMemberData(member);
        },

        getEditOk: doReadOnly ? 
            function () { return false; }  : 
            function () {
                return !_getDataMember().hasCode();
            },

        saveData: doReadOnly ? undefined :
            function(data) {
                var commandData = {};
                commandData.type = "saveMemberData";
                commandData.memberId = _getDataMember().getId();
                commandData.data = data;
                
                app.executeCommand(commandData);
                return true;
            }
    }
};

/** This function creates editor callbacks or member data where the editor takes text format. */
dataDisplayHelper.getMemberDataTextDataSource = function(app,componentView,memberFieldName,doReadOnly) {

    //this is used internally to lookup the data member used here
    let _getDataMember = function() {
        let component = componentView.getComponent();
        let member = component.getField(memberFieldName);
        return member;
    };
    
    return {

        doUpdate: function() {
            //return value is whether or not the data display needs to be udpated
            let component = componentView.getComponent();
            let reloadData = component.isMemberDataUpdated(memberFieldName);
            let reloadDataDisplay = false;
            return {reloadData,reloadDataDisplay};
        },

        getData: function() {
            let member = _getDataMember();
            let wrappedData = dataDisplayHelper.getEmptyWrappedData();
            if(member.getState() != apogeeutil.STATE_NORMAL) {
                wrappedData.hideDisplay = true;
                wrappedData.data = apogeeutil.INVALID_VALUE;
                switch(member.getState()) {
                    case apogeeutil.STATE_ERROR: 
                        wrappedData.messageType = DATA_DISPLAY_CONSTANTS.MESSAGE_TYPE_ERROR;
                        wrappedData.message = "Error in value: " + member.getErrorMsg();
                        break;

                    case apogeeutil.STATE_PENDING:
                        wrappedData.messageType = DATA_DISPLAY_CONSTANTS.MESSAGE_TYPE_INFO;
                        wrappedData.message = "Value pending!";
                        break;

                    case apogeeutil.STATE_INVALID:
                        wrappedData.messageType = DATA_DISPLAY_CONSTANTS.MESSAGE_TYPE_INFO;
                        wrappedData.message = "Value invalid!";
                        break;

                    default:
                        throw new Error("Unknown display data value state!")
                }
            }
            else {
                //convert data to a string, as is appropriate
                let textData;
                let data = member.getData();
                if(data == apogeeutil.INVALID_VALUE) {
                    textData = apogeeutil.INVALID_VALUE;
                }
                else if(data === undefined) {
                    textData = "undefined";
                }
                else {
                    textData = JSON.stringify(data);
                }
                wrappedData.data = textData;
            }

            return wrappedData;
        },

        getEditOk: doReadOnly ? 
            function () { return false; }  : 
            function () {
                return !_getDataMember().hasCode();
            },

        saveData: doReadOnly ? undefined :
            function(text) {
                var data;
                if(text === "undefined") {
                    data = undefined;
                }
                else {
                    try {
                        data = JSON.parse(text);
                    }
                    catch(error) {
                        if(error.stack) console.error(error.stack);
                        
                        //parsing error
                        apogeeUserAlert("There was an error parsing the JSON input: " +  error.message);
                        return false;
                    }
                }

                var commandData = {};
                commandData.type = "saveMemberData";
                commandData.memberId = _getDataMember().getId();
                commandData.data = data;
                
                app.executeCommand(commandData);
                return true;
            }
    }
};


/** This function creates editor callbacks or the member function body. 
 * The argument optionalClearCodeValue can optionally be set. If so, the member data will be 
 * set with this value if the function body and supplemental code are empty. 
 * The optionalDefaultDataValue will be used to clear the function and save the data value if the formula and
 * private code are empty strings. */
dataDisplayHelper.getMemberFunctionBodyDataSource = function(app,componentView,memberFieldName,optionalDefaultDataValue) {

    //this is used internally to lookup the data member used here
    let _getFunctionMember = function() {
        let component = componentView.getComponent();
        let member = component.getField(memberFieldName);
        return member;
    };

    return {

        doUpdate: function() {
            //return value is whether or not the data display needs to be udpated
            let component = componentView.getComponent();
            let reloadData = component.isMemberFieldUpdated(memberFieldName,"functionBody");
            let reloadDataDisplay = false;
            return {reloadData,reloadDataDisplay};
        },

        getData: function() {
            return _getFunctionMember().getFunctionBody();
        },

        getEditOk: function() {
            return true;
        },

        saveData: function(text) {
            let functionMember = _getFunctionMember();

            var commandData = {};
            commandData.type = "saveMemberCode";
            commandData.memberId = functionMember.getId();
            commandData.argList = functionMember.getArgList();
            commandData.functionBody = text;
            commandData.supplementalCode = functionMember.getSupplementalCode();
            if(optionalDefaultDataValue !== undefined) commandData.clearCodeDataValue = optionalDefaultDataValue;
            
            app.executeCommand(commandData);
            return true;
        }
    }
};

/** This function creates editor callbacks or the member supplemental code. 
 * The optionalDefaultDataValue will be used to clear the function and save the data value if the formula and
 * private code are empty strings. 
*/
dataDisplayHelper.getMemberSupplementalDataSource = function(app,componentView,memberFieldName,optionalDefaultDataValue) {

    //this is used internally to lookup the data member used here
    let _getFunctionMember = function() {
        let component = componentView.getComponent();
        let member = component.getField(memberFieldName);
        return member;
    };

    return {

        doUpdate: function() {
            //return value is whether or not the data display needs to be udpated
            let component = componentView.getComponent();
            let reloadData = component.isMemberFieldUpdated(memberFieldName,"supplementalCode");
            let reloadDataDisplay = false;
            return {reloadData,reloadDataDisplay};
        },

        getData: function() {
            return _getFunctionMember().getSupplementalCode();
        },

        getEditOk: function() {
            return true;
        },

        saveData: function(text) {
            let functionMember = _getFunctionMember();

            var commandData = {};
            commandData.type = "saveMemberCode";
            commandData.memberId = functionMember.getId();
            commandData.argList = functionMember.getArgList();
            commandData.functionBody = functionMember.getFunctionBody();
            commandData.supplementalCode = text;
            if(optionalDefaultDataValue !== undefined) commandData.clearCodeDataValue = optionalDefaultDataValue;
            
            app.executeCommand(commandData);
            return true;
        }
    }
};


/** This function creates the data display data source  for the data of the given member. The
 * member field should be the field name used to access the data source from the associated component. */
dataDisplayHelper.getStandardErrorDataSource = function(app,componentView) {
    
    return {
        doUpdate: function() {
            //return value is whether or not the data display needs to be udpated
            //the overall state is taken from the main memberm which will encompass any changes to 
            //the child members.
            let component = componentView.getComponent();
            let reloadData = component.isMemberDataUpdated("member");
            let reloadDataDisplay = false;
            return {reloadData,reloadDataDisplay};
        },

        getData: function() {
            if(componentView.getBannerState() == apogeeutil.STATE_ERROR) {
                let errorInfoList = componentView.getErrorInfoList();
                if((errorInfoList)&&(errorInfoList.length > 0)) {
                    //show data view, this is our data
                    return errorInfoList;
                }
            }

            //no error or error info; remove the data view
            let wrappedData = dataDisplayHelper.getEmptyWrappedData();
            wrappedData.removeView = true;
            return wrappedData;
            
        }
    }
};

/** This method reads the data from the given member and wraps it, including
 * handling error/pending/invalid data. This is appropriate for the 
 * getData function in a data source (not getDataDisplay though) 
 * There is one option - if optionalShowDispalyForInvalidData = true
 * the display will not be hidden if the data value is INVALID_VALUE. */
dataDisplayHelper.getStandardWrappedMemberData = function(member,optionalShowDispalyForInvalidData) {
    let wrappedData = dataDisplayHelper.getEmptyWrappedData();
    if(member.getState() != apogeeutil.STATE_NORMAL) {
        wrappedData.data = apogeeutil.INVALID_VALUE;
        switch(member.getState()) {
            case apogeeutil.STATE_ERROR: 
                wrappedData.hideDisplay = true;
                wrappedData.messageType = DATA_DISPLAY_CONSTANTS.MESSAGE_TYPE_ERROR;
                wrappedData.message = "Error in value: " + member.getErrorMsg();
                break;

            case apogeeutil.STATE_PENDING:
                wrappedData.hideDisplay = true;
                wrappedData.messageType = DATA_DISPLAY_CONSTANTS.MESSAGE_TYPE_INFO;
                wrappedData.message = "Value pending!";
                break;

            case apogeeutil.STATE_INVALID:
                wrappedData.hideDisplay = optionalShowDispalyForInvalidData ? false : true;
                wrappedData.messageType = DATA_DISPLAY_CONSTANTS.MESSAGE_TYPE_INFO;
                wrappedData.message = "Value invalid!";
                break;

            default:
                throw new Error("Unknown display data value state!")
        }
    }
    else {
        wrappedData.data = member.getData();
    }

    return wrappedData;
};

/** This method wraps "abnormal" member data when read as part of
 * getDisplayData. The return value is {abnormalWrappedData,data} 
 * If the member state is normal, the data will be returned and abnomrlaWrappedData 
 * will be undefined. If the state is not normal, abnormalWrappedData will be
 * defined and data will be undefined. */
dataDisplayHelper.getProcessedMemberDisplayData = function(member) {
    let abnormalWrappedData,inputData;

    if(member.getState() != apogeeutil.STATE_NORMAL) {
        abnormalWrappedData = dataDisplayHelper.getEmptyWrappedData();
        abnormalWrappedData.displayInvalid = true;

        switch(member.getState()) {
            case apogeeutil.STATE_ERROR: 
                abnormalWrappedData.messageType = DATA_DISPLAY_CONSTANTS.MESSAGE_TYPE_ERROR;
                abnormalWrappedData.message = "Error in layout input value: " + member.getErrorMsg();
                break;

            case apogeeutil.STATE_PENDING:
                abnormalWrappedData.messageType = DATA_DISPLAY_CONSTANTS.MESSAGE_TYPE_INFO;
                abnormalWrappedData.message = "Display layout input value pending!";
                break;

            case apogeeutil.STATE_INVALID:
                abnormalWrappedData.messageType = DATA_DISPLAY_CONSTANTS.MESSAGE_TYPE_INFO;
                abnormalWrappedData.message = "Display layout input value invalid!";
                break;

            default:
                throw new Error("Unknown display data value state!")
        }
    }
    else {
        inputData = member.getData();
    }

    return {abnormalWrappedData,inputData};
};


/** This function returns true if the passed in data is wrapped data. */
dataDisplayHelper.isWrappedData = function(data) {
    if(!data) return false;
    return (data[DATA_DISPLAY_CONSTANTS.WRAPPED_DATA_KEY] == DATA_DISPLAY_CONSTANTS.WRAPPED_DATA_VALUE);
};

/** This function returns empty wrapped data, since it can be cumbersome to construct. The return
 * value can be modified by adding additional fields. */
dataDisplayHelper.getEmptyWrappedData = function() {
    let wrappedData = {};
    wrappedData[DATA_DISPLAY_CONSTANTS.WRAPPED_DATA_KEY] = DATA_DISPLAY_CONSTANTS.WRAPPED_DATA_VALUE;
    return wrappedData;
};

/** This function reads data, handling wrapped or unwrapped data.
 * Wrapped Data Options:
 * - data - This is the data to pass return
 * - messageType - This is the type of message to show. The option are none, error, warning and info. The message can be shown
 *      even if the display is not hidden (which is not true for display data).
 * - message - This is the message to show.
 * - hideDisplay - If this is true, the main display element will not be shown.
 * - removeView - If this is true, the entire data view will be removed, as if it were not there.
 * 
 * Unwrapped Data:
 * If the data is not wrapped, the return value is the data. If this value is apogeeutil.INVALID_VALUE, hideDisplay
 * will be set to true and a default message will be shown.
 * 
 * The return values is:
 *  {data,messageType,message,hideDisplay,removeView}
 */
dataDisplayHelper.readWrappedData = function(getDataFunction,errorPrefix) {
    
    let data;
    let messageType;
    let message;
    let hideDisplay;
    let removeView;

    try {
        //load data from data source
        let dataReturn;
        if(getDataFunction) {
            dataReturn = getDataFunction();
        }
        else {
            dataReturn = apogeeutil.INVALID_VALUE;
        }

        //load data display values
        if((dataReturn)&&(dataDisplayHelper.isWrappedData(dataReturn))) {
            //handle a wrapped return value
            data = dataReturn.data;
            messageType = dataReturn.messageType;
            message = dataReturn.message;
            removeView = dataReturn.removeView;
            hideDisplay = dataReturn.hideDisplay;
        }
        else {
            //straight data was returned
            data = dataReturn;
            hideDisplay = (data === apogeeutil.INVALID_VALUE);
        }
    }
    catch(error) {
        //hide dispay and show error message
        messageType = DATA_DISPLAY_CONSTANTS.MESSAGE_TYPE_ERROR;
        message = errorPrefix + error.toString();
        removeView = false;
        hideDisplay = true;
        data = apogeeutil.INVALID_VALUE;

        if(error.stack) console.error(error.stack);
    }

    //set values that have not be set
    if(messageType === undefined) {
        messageType = DATA_DISPLAY_CONSTANTS.MESSAGE_TYPE_NONE;
        message = "";
    }
    hideDisplay = hideDisplay ? true : false;
    removeView = removeView ? true : false;

    return {data,messageType,message,hideDisplay,removeView};
};

/** This function reads display data, handling wrapped or unwrapped data.
 * Wrapped Data Options:
 * - data - this is the data to pass to the dispaly
 * - displayInvalid - if this is true the display is hidden and a message is shown. 
 * - messageType - This is the type of message to show. This is valid only if the display is invalid and ignored otherwise.
 *      If a message will be shown and this is not set, the message type wil be error.
 * - message - This is the message to show.
 * 
 * Unwrapped Data:
 * If the data is not wrapped, the return value is the data. If this value is apogeeutil.INVALID_VALUE, displayInvalid
 * will be set to true and a default message will be shown.
 * 
 * The return values is:
 *  {data,displayInvalid,messageType,message}
 */
dataDisplayHelper.readWrappedDisplayData = function(getDataFunction,errorPrefix) {
    
    let data;
    let messageType;
    let message;
    let displayInvalid;

    try {
        //load data from data source
        let dataReturn;
        if(getDataFunction) {
            dataReturn = getDataFunction();
        }
        else {
            dataReturn = apogeeutil.INVALID_VALUE;
        }

        //load data display values
        if((dataReturn)&&(dataDisplayHelper.isWrappedData(dataReturn))) {
            //handle a wrapped return value
            data = dataReturn.data;
            displayInvalid = dataReturn.displayInvalid;
            messageType = dataReturn.messageType;
            message = dataReturn.message;
        }
        else {
            //straight data was returned
            data = dataReturn;
            displayInvalid = (data === apogeeutil.INVALID_VALUE);
        }
    }
    catch(error) {
        //hide dispay and show error message
        messageType = DATA_DISPLAY_CONSTANTS.MESSAGE_TYPE_ERROR;
        message = errorPrefix + error.toString();
        displayInvalid = true;
        data = apogeeutil.INVALID_VALUE;

        if(error.stack) console.error(error.stack);
    }

    //fill in the message type and message if they are not set
    //by default, set message type to error
    if(displayInvalid) {
        if(messageType === undefined) messageType = DATA_DISPLAY_CONSTANTS.MESSAGE_TYPE_ERROR;
        if(message === undefined) message = "Data unavailable";
    }

    return {data,displayInvalid,messageType,message};
};

/** This is the base class for data displays, which show individual edit/display fields for a component. For example, a standard JSON
 * data component has three data displays, for the component value, the function body and the supplemental code.
 * 
 * @param {type} displayContainer - this is the ui container that will show the display
 * @param {type} dataSource - the dataSource for the editor. It is an object with the following functions:
 *  - {reloadDataDisplay, reloadData} = doUpdate() - Required - This function updates the component instance
 *      held by the data source and it returns to boolean values, "reloadDataDisplay", which indicates is the data display should 
 *      be reloaded (such as if it is replaced with a new data display or if the UI elements for it have been updated) and
 *      "reloadData" which indicates the data value displayed in the data display should be reloaded.  
 *  - data = getData() - Required - This returns model data that should be displayed. The format of the data depends on the 
 *      data display. If the data is not valid, then the value apogeeutil.INVALID_VALUE should be returned.
 *  - editOk = getEditOk() - Optional - If present, this indicates if the data display edit mode should be used. If it is not present
 *      it is assumed to be false.
 *  - closeDialog = saveData(data) - Optional This is used if the data display edit mode is used. It should save the data. The return value
 *      should be true if the edit operation should be concluded. It should return false if there is a save failure such that you want to 
 *      stay in edit mode.
 *  - (other) - Optional - Data displays may define additional functions as needed for their implmentations. Examples where this is done in in the custom
 *      components to pass non-model data (like the HTML or the UI generator code) into the data display.
 */ 
class DataDisplay {
    constructor(displayContainer,dataSource) {
        this.displayContainer = displayContainer;
        this.dataSource = dataSource ? dataSource : {};
        this.editOk = false;
        this.displayValid = true; //default this to true, so simple displays don't need to use it

        //defaults for container sizing logic
        this.useContainerHeightUi = false;
    }

    /** This method updates the internal component instance and also returns
     * true if the data display needs to be refreshed. */
    doUpdate() {
        if(this.dataSource) {
            return this.dataSource.doUpdate();
        }
        else {
            return false;
        }
    }
    
    save() {
        var data;
        var dataValid = false;
        try {
            data = this.getData();
            dataValid = true;
        }
        catch(error) {
            if(error.stack) console.error(error.stack);
            apogeeUserAlert("Error loading data from data display: " + error.message);
        }

        //save data if we read it out
        if(dataValid) {
            var saveComplete;

            //figure out if there is a problem with this - we hav to end edit mode before
            //we save because in edit mode it will not overwrite the data in the display
            //if we fail, we restart edit mode below
            this.endEditMode();

            if(this.dataSource.saveData) {
                try {
                    saveComplete = this.dataSource.saveData(data);
                }
                catch(error) {
                    if(error.stack) console.error(error.stack);
                    apogeeUserAlert("Error saving data: " + error.message);
                    saveComplete = false;
                }
            }
            else {
                apogeeUserAlert("Error: Data not saved: save callback not set!");
                saveComplete = false;
            }

            //end edit mode if we entered it
            if(!saveComplete) {
                this.startEditMode();
            }
        }
    }

    cancel() {
        //reset the original data
        var cancelComplete = this.displayContainer.onCancel();

        if(cancelComplete) {
            this.endEditMode();
        }
    }

    getDisplayContainer() {
        return this.displayContainer;
    }

    getDataSource() {
        return this.dataSource;
    }

    getComponentView() {
        return this.displayContainer.getComponentView();
    }
    
    //=============================
    // Implemement in extending class
    //=============================
    
    //This method gets the data from the editor. OPTIONAL. Required if editing is enabled.
    //getData() {}
    
    //this sets the data into the editor display. REQUIRED if edit mode or save is used
    //setData(data) {}
    
    //this method is called on loading the display. OPTIONAL
    //onLoad() {}
    
    //this method is called on unloading the display. OPTIONAL
    //onUnLoad() {}

    //this method is called when the display will be destroyed. OPTIONAL
    //destroy() {}
    
    //This method returns the content element for the data display REQUIRED
    //getContent() {}

    //---------------------------
    // UI State Management
    //---------------------------
    
    /** This method adds any data display state info to the view state json. 
     * By default there is none. Note that this modifies the json state of the view,
     * rather than providing a data object that will by added to it.. */
    addUiStateData(json) {

    }

    /** This method reads an data display state info from the view state json. */
    readUiStateData(json) {

    }

    //----------------------------
    // This is the View resize API
    // The display has controls for the user to resize the display. These use the 
    // following API to interact with the display
    //----------------------------

    /** This function is called to see if the container should provide a view height UI, if the container supports it. */
    getUseContainerHeightUi() {
        return this.useContainerHeightUi;
    }

    /** This sets the variable that determines if the container will provide a height adjustment UI. The default value is false. */
    setUseContainerHeightUi(useContainerHeightUi) {
        this.useContainerHeightUi = useContainerHeightUi;
    }

    /** This is called if the show less button is pressed, if container height UI is in use */
    //showLess();

    /** This is called if the show more button is pressed, if container height UI is in use */
    //showMore();

    /** This is called if the show max button is pressed, if container height UI is in use */
    //showMax();

    /** This method controlsthe visibility options for the resize buttons. These will only be called if 
     * resize is enabled for this data display (if container height UI is in use)
     * Flags:
     * - DATA_DISPLAY_CONSTANTS.RESIZE_SHOW_FLAG = 1; (if not set this hides all buttons)
     * - DATA_DISPLAY_CONSTANTS.RESIZE_MODE_MAX_FLAG = 2; (if not set the mode is SOME, if set the mode is MAX)
     * - DATA_DISPLAY_CONSTANTS.RESIZE_DISABLE_LESS_FLAG = 4; (disables the less button, if it is showing)
     * - DATA_DISPLAY_CONSTANTS.RESIZE_DISABLE_MORE_FLAG = 8; (disables the more button, if it is showing)
     * - DATA_DISPLAY_CONSTANTS.RESIZE_DISABLE_MAX_FLAG = 16; (disables the max button, if it is showing)
     * These flags should be or'ed togethder to give the allowed options.
    */
    //getHeightAdjustFlags();

    //=============================
    // protected, package and private Methods
    //=============================

    /** This method should be called when the underlying display is loaded, indicating if it is 
     * valid or if it should not be used. */
    setDisplayValid(displayValid) {
        this.displayValid = displayValid;
    }
	
    showData() {
        if(!this.displayValid) return;

        //get edit ok
        if(this.dataSource.getEditOk) {
            this.editOk = this.dataSource.getEditOk();
        }
        else {
            this.editOk = false;
        }

        //get data
        let dataResult = dataDisplayHelper.readWrappedData(this.dataSource.getData,"Error loading display data: ");

        //configure view
        this.displayContainer.setRemoveView(dataResult.removeView);
        if(!dataResult.removeView) {
            //only hide view and show message if view is not removed
            //we will set data either way to clear old date
            this.displayContainer.setHideDisplay(dataResult.hideDisplay);
            this.displayContainer.setMessage(dataResult.messageType,dataResult.message);
        }
        this.setData(dataResult.data);
    }

    /** @protected */
    endEditMode() {
        this.displayContainer.endEditMode();

    }
    
    /** @protected */
    startEditMode() {
        var onSave = () => this.save();
        var onCancel = () => this.cancel();

        this.displayContainer.startEditMode(onSave,onCancel);
    }

    /** @protected */
    onTriggerEditMode() {
        if(this.editOk) {
            this.startEditMode();
        }
    }
}

/** This is an editor that displays a customized form for data input. */
class ConfigurableFormEditor extends DataDisplay {
    
    /** This allows for a static or dynamic layout setting
     * @param {type} displayContainer - the displayContainer
     * @param {type} dataSource - {
     *  - doUpdate - this should return reloadDataDisplay = true if the form should be reconfigured. 
     *          otherwise it should return reloadData if the form data should be reloaded.
     *  - getData - returns the desired form value,
     *  - getEditOk - gets if form is editable (optional)
     *  - setData - called when data is saved, with the form value (optional)
     *  - getDisplayData - This returns the layout for the configurable form.
     *  }
     */
    constructor(displayContainer,dataSource) {
        super(displayContainer,dataSource);

        //TEMP - to raise the z index
        let domElement = this.displayContainer.getDisplayElement();
        if(domElement) {
            domElement.style.zIndex = 2;
        }
        
        //construct the display
        this.panel = new ConfigurablePanel();

        //get data and handle invalid display
        if(this.dataSource.getDisplayData) {
            let dataResult = dataDisplayHelper.readWrappedDisplayData(this.dataSource.getDisplayData,"Error loading form layout: ");
            if(dataResult.displayInvalid) {
                //display invalid! hide display and show message
                this.displayContainer.setHideDisplay(dataResult.hideDisplay);
                this.displayContainer.setMessage(dataResult.messageType,dataResult.message);
                this.setDisplayValid(false);
            }
            else {
                //display display valid
                this.panel.configureForm(dataResult.data);
                this.panel.addOnInput( formValue => this.onFormInput(formValue));
                this.setDisplayValid(true);
            }
        }
    }

    /** This method will return undefined until showData is called. */
    getContent() {
        return this.panel.getElement();
    }
    
    /** This returns the form value (not the layout too) */
    getData() {
        if(!this.panel) {
            //why is this happening? DEBUG!!!
            console.log("Doh!");
            return this.changeReferenceValue;
        }
        //get the form value, and set it to the refernece for changes to the form 
        this.changeReferenceValue = this.panel.getValue();
        return this.changeReferenceValue;
    }

    /** This returns the form meta value. */
    getFormMeta() {
        return this.panel.getMeta();
    }
    
    /** This is passed the data form the data callback, which should be the extended data  - including layout + value */
    setData(data) {
        //we need a better error case
        if(data == apogeeutil$1.INVALID_VALUE) {
            data = {};
        }

        this.changeReferenceFormValue = data;

        //input data is the layout and the value
        this.panel.setValue(data);
    }

    onFormInput(formValue) {
        //set change to enable save bar if form value differs from initial data
        let dataSource = this.getDataSource();
        let editOk = (dataSource.getEditOk)&&(dataSource.getEditOk()); 
        if(editOk) {
            if(!apogeeutil$1.jsonEquals(formValue,this.changeReferenceFormValue)) {
                
                this.startEditMode();
            }
        }
    }

    /** This does some cleanup */
    destroy() {
        this.panel.destroy();
        this.panel = null;
    }

    //===========================
    // Utilities for forms
    //===========================

    static getErrorLayout(errorMsg) {
        return ConfigurablePanel.getErrorMessageLayoutInfo(errorMsg);
    }

    static getEmptyLayout() {
        return ConfigurablePanel.EMPTY_LAYOUT;
    }
}

/** This is a graphing component using ChartJS. It consists of a single data table that is set to
 * hold the generated chart data. The input is configured with a form, which gives multiple options
 * for how to set the data. */
class FormInputBaseComponentView extends ComponentView {

    constructor(appViewInterface,component) {
        super(appViewInterface,component);
    }

    getFormDataDisplay(displayContainer) {
        let dataDisplaySource = this._getInputFormDataSource();
        return new ConfigurableFormEditor(displayContainer,dataDisplaySource);
    }

    //=====================================
    // Private Methods
    //=====================================

    /** This is the data source for the input form data display */
    _getInputFormDataSource() {
        return {
            doUpdate: () => {
                //data updates should only be triggered by the form itself
                let reloadData = this.getComponent().isMemberDataUpdated("member.formData");
                //form layout constant
                let reloadDataDisplay = false;
                return {reloadData,reloadDataDisplay};
            }, 
            getDisplayData: () => this.getFormLayout(),
            getData: () => {
                let formMember = this.getComponent().getField("member.formData");
                return dataDisplayHelper.getStandardWrappedMemberData(formMember);
            },
            getEditOk: () => true,
            saveData: (formData) => this._onSubmit(formData)
        }
    }

    /** This method saves the form result converted to a function body that handles expression inputs.
     * This is saved to the formula for the member object. */
    _onSubmit(formData) {
        //load the form meta - we have to look it up from the data display (this is a little clumsy)
        let formMeta;
        let formEditor = this.getCurrentDataDisplayInstance(FormInputBaseComponentView.VIEW_INPUT);
        if(formEditor) {
            formMeta = formEditor.getFormMeta();
        }

        if(!formMeta) {
            //data display should be present if the person submitted the form
            console.error("Unknown error loading the form meta value.");
            //return true indicates the submit is completed
            return true;
        }
        
        //get the function body
        let functionBody = getFormResultFunctionBody(formData,formMeta);

        //set the code
        var dataMember = this.getComponent().getField("member.formData");
        var resultMember = this.getComponent().getField("member.formResult");

        var dataCommand = {};
        dataCommand.type = "saveMemberData";
        dataCommand.memberId = dataMember.getId();
        dataCommand.data = formData;

        var resultCommand = {};
        resultCommand.type = "saveMemberCode";
        resultCommand.memberId = resultMember.getId();
        resultCommand.argList = [];
        resultCommand.functionBody = functionBody;
        resultCommand.supplementalCode = "";

        let command = {
            type: "compoundCommand",
            childCommands: [dataCommand,resultCommand]
        };
        
        let app = this.getApp();
        app.executeCommand(command);

        //if we got this far the form save should be accepted
        return true;
    }       

}

//This is the standard formview mode info
FormInputBaseComponentView.VIEW_INPUT = "Input";

FormInputBaseComponentView.INPUT_VIEW_MODE_INFO = {name: FormInputBaseComponentView.VIEW_INPUT, label: "Configuration", isActive: true};

/** Editor that uses the Ace text editor.
 * 
 * @param {type} displayContainer - the display container
 * @param {type} dataSource - {updateComponent,getData,getEditOk,setData}; format for data is text
 * @param {type} aceMode - the display format, such as "ace/mode/json"
 */
class AceTextEditor extends DataDisplay {
    
    constructor(displayContainer,dataSource,aceMode,options) {
        super(displayContainer,dataSource);

        this.destroyed = false;

        this.editorDiv = uiutil.createElement("div");

        //========================
        //this is for consistency of lines to pixels
        this.editorDiv.style.fontSize = "12px";
        this.editorDiv.style.lineHeight = "1.2";
        this.pixelsPerLine = 14;
        //=========================

        this.aceMode = aceMode;

        this.inputData = null;
        this.cachedDisplayData = null;
        this.dataError = false;

        //configure the options
        if(!options) options = {};

        this.editorOptions = {};
        this.showSomeMaxLines = DEFAULT_MAX_LINES;
        if(options.displayMax) {
            this.resizeHeightMode = DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MODE_MAX;
            this.editorOptions.maxLines = MAX_MAX_LINES;
        }
        else {
            this.resizeHeightMode = DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MODE_SOME;
            this.editorOptions.maxLines = this.showSomeMaxLines;
        }

        this.editorOptions.minLines = DEFAULT_MIN_LINES;

        //set variables for internal display view sizing
        this.setUseContainerHeightUi(true);
    }
    
    createEditor() {
        if(this.destroyed) return;

        this.editor = ace.edit(this.editorDiv);
        this.editor.setOptions(this.editorOptions);
        this.editor.setHighlightActiveLine(false);
        this.editor.setAutoScrollEditorIntoView(true);
        this.editor.setTheme("ace/theme/eclipse");
        this.editor.getSession().setMode(this.aceMode); 
        this.editor.$blockScrolling = Infinity;
        this.editor.renderer.attachToShadowRoot(); 
        
        this.editor.commands.addCommand({
            name: "Save",
            exec: () => this.save(),
            bindKey: {mac: "cmd-s", win: "ctrl-s"}
        });

        this.editor.commands.addCommand({
            name: "Revert",
            exec: () => this.cancel(),
            bindKey: {mac: "esc", win: "esc"}
        });
        

        //handle focus change
        this.editor.on("blur",() => this.onEditorBlur());
        this.editor.on("focus",() => this.onEditorFocus());
        if(this.editor.isFocused()) {
            this.onEditorFocus();
        }
        else {
            this.onEditorBlur();
        }
        
        if(this.cachedDisplayData) {
            this.setData(this.cachedDisplayData);
        }
        
        //enter edit mode on change to the data
        this.editor.addEventListener("input",() => this.checkStartEditMode());
    }
    
    getContent() {
        return this.editorDiv;
    }

    /** We override the save function to clear any error if there was one and the
     * user saves - meaning we want to keep the editor data. */
    save() {
        if(this.destroyed) return;

        //clear error flag since the user wants to save what is displayed
        if(this.dataError) this.dataError = false;

        super.save();
    }

    getData() {
        if(this.destroyed) return null;

        if((this.editor)&&(!this.dataError)) {
            this.cachedDisplayData = this.editor.getSession().getValue();
            this.inputData = this.cachedDisplayData;
        }
        return this.inputData; 
    }
    
    setData(text) {
        if(this.destroyed) return;

        this.inputData = text;
        this.cachedDisplayData = text;
        this.dataError = false;

        //The data source should give a text value "" if the data in invalid rather than sending
        //in a json, but we will do this check anyway.
        if(text == apogeeutil$1.INVALID_VALUE) {
            //clear the display
            this.cachedDisplayData = "";
            //the dispaly shoudl be hidden, but do it again anyway
            let displayContainer = this.getDisplayContainer();
            displayContainer.setHideDisplay(true);
            this.dataError = true;
        }
        else if(!apogeeutil$1.isString(text)) {
            let displayContainer = this.getDisplayContainer();
            displayContainer.setMessage(DATA_DISPLAY_CONSTANTS.MESSAGE_TYPE_INFO, "Data cannot be shown in editor: value is not text");
            displayContainer.setHideDisplay(true);
            //clear the display
            this.cachedDisplayData = "";
            this.dataError = true;
        }
        
        //place ineditor, if it is present
        if(this.editor) {
            this.editor.getSession().setValue(this.cachedDisplayData);

            //set the edit mode and background color
            if(this.editOk) {
                this.editorDiv.style.backgroundColor = "";
                this.editor.setReadOnly(false);
            }
            else {
                this.editorDiv.style.backgroundColor = DATA_DISPLAY_CONSTANTS.NO_EDIT_BACKGROUND_COLOR;
                this.editor.setReadOnly(true);
            }
        }
    }
    
    onLoad() {
        if(this.destroyed) return;

        if(!this.editor) {
            this.createEditor();
        }
        this.editor.resize();
    }

    destroy() {
        this.destroyed = true;

        if(this.editor) {
            this.editor.destroy();
            this.editor = null;
        }
        this.editorDiv = null;
        this.inputData = null;
        this.cachedDisplayData = null;
        this.editorOptions = null;
    }
    
    checkStartEditMode() {
        if(this.destroyed) return;

        if((!this.displayContainer.isInEditMode())&&(this.editor)) {
            var activeData = this.editor.getSession().getValue();
            if(activeData != this.cachedDisplayData) {
                this.onTriggerEditMode();
            }
        }
    }

    onEditorBlur() {
        if(this.editor) {
            this.editor.renderer.$cursorLayer.element.style.display = "none";
            this.editor.renderer.$markerBack.element.style.display = "none";
        }
    }

    onEditorFocus() {
        if(this.editor) {
            this.editor.renderer.$cursorLayer.element.style.display = "";
            this.editor.renderer.$markerBack.element.style.display = "";
        }
    }

    //---------------------------
    // UI State Management
    //---------------------------
    
    /** This method adds any data display state info to the view state json. 
     * By default there is none. Note that this modifies the json state of the view,
     * rather than providing a data object that will by added to it.. */
    addUiStateData(json) {
        if(this.destroyed) return;

        if(this.editorOptions.maxLines) {
            json.height = this.editorOptions.maxLines * this.pixelsPerLine;
        }
    }

    /** This method reads an data display state info from the view state json. */
    readUiStateData(json) {
        if(this.destroyed) return;

        if(json.height) {
            let maxLines = Math.round(json.height / this.pixelsPerLine);
            if(maxLines >= MAX_MAX_LINES) {
                this.resizeHeightMode = DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MODE_MAX;
                maxLines = MAX_MAX_LINES;
            }
            else {
                this.resizeHeightMode = DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MODE_SOME;
                if(maxLines < DEFAULT_MIN_LINES) {
                    maxLines = DEFAULT_MIN_LINES;
                }
                this.showSomeMaxLines = maxLines;
            }

            this.editorOptions.maxLines = maxLines;

            if(this.editor) {
                this.editor.setOptions(this.editorOptions);
            }
        }
    }

    //----------------------------
    // This is the View resize API
    // The display has controls for the user to resize the display. These use the 
    // following API to interact with the display
    //----------------------------

    /** This is called if the show less button is pressed */
    showLess() {
        if((this.destroyed)||(!this.editor)) return;

        let newMaxLines;
        if(this.resizeHeightMode == DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MODE_SOME) {
            //decrease size by 1 line - except if our size is 
            //larger than the current doc, then shrink it to 
            //one line smaller than current doc.
            let docLines = this.editor.getSession().getLength();
            if(docLines < this.showSomeMaxLines) {
                this.showSomeMaxLines = docLines;
            }
            newMaxLines = this.showSomeMaxLines - 1;
            if(newMaxLines <  DEFAULT_MIN_LINES) {
                newMaxLines = DEFAULT_MIN_LINES;
            }
        }
        else {
            //set lines to the most recent "some" mode size
            this.resizeHeightMode = DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MODE_SOME;
            newMaxLines = this.showSomeMaxLines;
        }

        this._setSomeMaxLines(newMaxLines);

    }

    /** This is called if the show more button is pressed */
    showMore() {
        if((this.destroyed)||(!this.editor)) return;

        let newMaxLines;
        if(this.resizeHeightMode == DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MODE_SOME) {
            //just grow size by 1 line
            newMaxLines = this.showSomeMaxLines + 1;
            if(newMaxLines >  MAX_MAX_LINES) {
                newMaxLines = MAX_MAX_LINES;
            }
        }
        else {
            //put in some mode and keep max lines the same (the UI probably won't allow this command though)
            this.resizeHeightMode = DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MODE_SOME;
            newMaxLines = MAX_MAX_LINES;
        }

        this._setSomeMaxLines(newMaxLines);
    }

    /** This is called if the show max button is pressed */
    showMax() {
        if((this.destroyed)||(!this.editor)) return;

        if(this.resizeHeightMode == DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MODE_SOME) {
            //set the max number of lines
            this.resizeHeightMode = DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MODE_MAX;
            this.editorOptions.maxLines = MAX_MAX_LINES;
            this.editor.setOptions(this.editorOptions);
        }

    }

    /** This sets the number of lines to display (if the display is this big) */
    _setSomeMaxLines(maxLines) {
        //update the lines options
        this.showSomeMaxLines = maxLines;
        this.editorOptions.maxLines = this.showSomeMaxLines;
        this.editor.setOptions(this.editorOptions);
    }

    /** This method controlsthe visibility options for the resize buttons. These will only work if 
     * resize is enabled for this data display. */
    getHeightAdjustFlags() {
        let flags = 0;
        flags |= DATA_DISPLAY_CONSTANTS.RESIZE_SHOW_FLAG;
        if(this.resizeHeightMode == DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MODE_MAX) {
            flags |= DATA_DISPLAY_CONSTANTS.RESIZE_MODE_MAX_FLAG;
        }

        //for now we won't disable any buttons - pressing them will just do nothing
        return flags;
    }
}

//options for displaying all or some lines
AceTextEditor.OPTION_SET_DISPLAY_MAX = { "displayMax":true};
AceTextEditor.OPTION_SET_DISPLAY_SOME = { "displayMax":false};

//configuration constants
let MAX_MAX_LINES = 500;
let DEFAULT_MAX_LINES = 20;
let DEFAULT_MIN_LINES = 2;

/** JsDataDisplay
 * This is the data display for a custom control where the control is generated
 * from javascript code. Is should be passed a 
 * resource (javascript object) which has the following methods optionally defined: 
 * 
 * init(outputElement,outputMode);
 * setData(data,outputElement,outputMode);
 * requestInactive(outputElement,outputMode);
 * onHide(outputElement,outputMode);
 * destroy(outputElement,outputMode);
 */

/** This is the display/editor for the custom control output. */
class ErrorDisplay extends DataDisplay {
    constructor(displayContainer) {
        var dataSource = {
            doUpdate: () => false,
            getData: () => null
        };
        super(displayContainer,dataSource);
        
        var msg = "ERROR - Component not loaded!";
        var msgDiv = uiutil.createElement("div");
        msgDiv.style = "color:red; font-weight:bold";
        msgDiv.innerHTML = msg;
        
        this.displayElement = msgDiv;
    }
    
    /** This method will return undefined until showData is called. */
    getContent() {
        return this.displayElement;
    }

    setData(data) {
        //no action
    }
}

/** This is a grid editor using hands on table*/
class HandsonGridEditor extends DataDisplay {
    
    constructor(displayContainer,dataSource) {
        super(displayContainer,dataSource);

        this.resizeHeightMode = DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MODE_SOME;
        this.savedPixelHeight = DEFAULT_PIXEL_HEIGHT;
        this.cachedSomeModePixelHeight = this.savedPixelHeight;

        this.gridDiv = uiutil.createElement("div",null,{
            "width": "100%",
            "height":this.savedPixelHeight + "px",
            "overflow":"hidden",
        });

        this.inputData = null;
        this.cachedDisplayData = null;
        this.dataCached = false;
        this.dataError = false;

        this.updatesPaused = false;

        this.activeEditOk = undefined;

       //we have to make sure the element is loaded before initailizing for handsontable to work properly
       this.loaded = false;

        //set variables for internal display view sizing
        this.setUseContainerHeightUi(true);

        //we will use a listener to see when the page is resized
        let app = this.displayContainer.getComponentView().getApp();
        this.frameWidthListener = () => this.onFrameWidthResize();
        app.addListener("frameWidthResize",this.frameWidthListener);

    }

//=============================
// "Package" Methods
//=============================

    getContent() {
        return this.gridDiv;
    }
    
    getData() {
        if(this.dataError) return this.inputData;

        //update "input" data before calling update
        if(this.gridControl) {
            this.inputData = apogeeutil$1.jsonCopy(this.gridControl.getData());
            //data should not be cached, but if it is update the value.
            if(this.dataCached) {
                this.cachedDisplayData = this.inputData;
            }
        }
        return this.inputData;
    }
    
    setData(json) {

        if((this.inputData === json)&&(this.editOk)) return;

        this.inputData = json;
        this.cachedDisplayData = json;
        this.dataCached = true;
        this.dataError = false;

        if(json == apogeeutil$1.INVALID_VALUE) {
            //clear the display
            this.cachedDisplayData = [[]];
            //the displaly shoudl be hidden, but do it again anyway
            let displayContainer = this.getDisplayContainer();
            displayContainer.setHideDisplay(true);
            this.dataError = true;
        }
        else if(!this.dataIsValidFormat(json)) {
            let displayContainer = this.getDisplayContainer();
            displayContainer.setMessage(DATA_DISPLAY_CONSTANTS.MESSAGE_TYPE_INFO, "Data cannot be shown in grid: value is not an array of arrays");
            displayContainer.setHideDisplay(true);
            //clear the display
            this.cachedDisplayData = [[]];
            this.dataError = true;
        }

        if(this.loaded) {
            this.displayData();
        }
    }

    onLoad() {
        this.loaded = true;
        if(this.dataCached) {
            this.displayData();
        }
    }

    onUnload() {
        this.loaded = false;
    }

    onFrameWidthResize() {
        this.updateWidth();
    }

    destroy() {
        //tear down the grid control
        if(this.gridControl) {
            this.gridControl.destroy();
            this.gridControl = null;
        }
        //remove the frame width listener
        if(this.frameWidthListener) {
            let app = this.displayContainer.getComponentView().getApp();
            app.removeListener("frameWidthResize",this.frameWidthListener);
            this.frameWidthListener = null;
        }
    }

    /** This updates the width to the current container width. */
    updateWidth() {
        if(this.gridControl) {
            this.gridControl.render();
        }
    }

    /** This updates the height to the specified pixel height. */
    updateHeight(pixelHeight) {
        this.savedPixelHeight = pixelHeight;
        if(this.gridControl) {
            this.gridControl.updateSettings({height: pixelHeight});
        }
        else {
            this.gridDiv.style.height = this.savedPixelHeight + "px";
        }
    }

    //---------------------------
    // UI State Management
    //---------------------------
    
    /** This method adds any data display state info to the view state json. 
     * By default there is none. Note that this modifies the json state of the view,
     * rather than providing a data object that will by added to it.. */
    addUiStateData(json) {
        if(this.savedPixelHeight) {
            json.height = this.savedPixelHeight;
        }
    }

    /** This method reads an data display state info from the view state json. */
    readUiStateData(json) {
        if(json.height) {
            let newPixelHeight = json.height;
            if(newPixelHeight >= MAX_PIXEL_HEIGHT) {
                this.resizeHeightMode = DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MODE_MAX;
                newPixelHeight = MAX_PIXEL_HEIGHT;
            }
            else {
                this.resizeHeightMode = DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MODE_SOME;
                if(newPixelHeight < MIN_PIXEL_HEIGHT) {
                    newPixelHeight = MIN_PIXEL_HEIGHT;
                }
            }

            this.updateHeight(newPixelHeight);
        }
    }

    //----------------------------
    // This is the View resize API
    // The display has controls for the user to resize the display. These use the 
    // following API to interact with the display
    //----------------------------

    /** This is called if the show less button is pressed */
    showLess() {
        if((this.destroyed)||(!this.gridControl)) return;

        let newPixelHeight;
        if(this.resizeHeightMode == DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MODE_SOME) {
            //decrease up to the min size
            newPixelHeight = this.savedPixelHeight - DELTA_PIXEL_HEIGHT;
            if(newPixelHeight < MIN_PIXEL_HEIGHT) newPixelHeight = MIN_PIXEL_HEIGHT;   
        }
        else {
            this.resizeHeightMode = DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MODE_SOME;
            newPixelHeight = this.cachedSomeModePixelHeight;
        }

        this.cachedSomeModePixelHeight = newPixelHeight;
        this.updateHeight(newPixelHeight);
    }

    /** This is called if the show more button is pressed */
    showMore() {
        if((this.destroyed)||(!this.gridControl)) return;

        let newPixelHeight;
        if(this.resizeHeightMode == DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MODE_SOME) {
            ///decrease up to the min size
            newPixelHeight = this.savedPixelHeight + DELTA_PIXEL_HEIGHT;
            if(newPixelHeight > MAX_PIXEL_HEIGHT) newPixelHeight = MAX_PIXEL_HEIGHT;
        }
        else {
            //put in some mode and keep max lines the same (the UI probably won't allow this command though)
            this.resizeHeightMode = DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MODE_SOME;
            newPixelHeight = MAX_PIXEL_HEIGHT;
        }

        this.cachedSomeModePixelHeight = newPixelHeight;
        this.updateHeight(newPixelHeight);
    }

    /** This is called if the show max button is pressed */
    showMax() {
        if((this.destroyed)||(!this.gridControl)) return;

        if(this.resizeHeightMode == DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MODE_SOME) {
            this.resizeHeightMode = DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MODE_MAX;
            this.updateHeight(MAX_PIXEL_HEIGHT);
        }
    }

    /** This method controlsthe visibility options for the resize buttons. These will only work if 
     * resize is enabled for this data display. */
    getHeightAdjustFlags() {
        let flags = 0;
        flags |= DATA_DISPLAY_CONSTANTS.RESIZE_SHOW_FLAG;
        if(this.resizeHeightMode == DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MODE_MAX) {
            flags |= DATA_DISPLAY_CONSTANTS.RESIZE_MODE_MAX_FLAG;
        }

        //for now we won't disable any buttons - pressing them will just do nothing
        return flags;
    }

//==============================
// Private Methods
//==============================

    /** This method creates a new grid. 
     * @private */
    createNewGrid(initialData) {
        if(this.gridControl) {
            this.gridControl.destroy();
            this.gridControl = null;
        }

        var gridOptions = {
            data: initialData,
            readOnly: !this.editOk,
            contextMenu: this.editOk,
            rowHeaders: true,
            colHeaders: true,
            width:"100%",
            height: this.savedPixelHeight + "px"
        };

        this.gridControl = new Handsontable(this.gridDiv,gridOptions); 

        if(this.editOk) {
        //edit callbacks - I am using a delay on the grid edited because the table fires too many updates - one for 
            //each row (soemthing like that I forget) on a big paste
            Handsontable.hooks.add("afterChange",() => this.gridEdited(),this.gridControl);
            Handsontable.hooks.add("beforePaste",() => this.pauseUpdates(),this.gridControl);
            Handsontable.hooks.add("afterPaste",() => this.unpauseUpdates(true),this.gridControl);
            Handsontable.hooks.add("afterCreateCol",() => this.gridEdited(),this.gridControl);
            Handsontable.hooks.add("afterCreateRow",() => this.gridEdited(),this.gridControl);
            Handsontable.hooks.add("afterRemoveCol",() => this.gridEdited(),this.gridControl);
            Handsontable.hooks.add("afterRemoveRow",() => this.gridEdited(),this.gridControl);

            Handsontable.hooks.add("afterRender",() => {
                //this is when the control is finished
                let x = this.gridControl;
            },this.gridControl);
        }

        this.updateWidth();
    }

    //grid edited function
    gridEdited() {
        if(!this.gridControl) return;
        if(this.updatesPaused) return;
        
        //if the grid was edited, clear any data error so we can take the new data.
        this.dataError = false;

        this.save();
    }

    afterChange() {
        this.gridEdited();
    }

    pauseUpdates() {
        this.updatesPaused = true;
    }

    unpauseUpdates(doUpdate) {
        this.updatesPaused = false;
        if(doUpdate) {
            this.gridEdited();
        }
    } 
    
    
    //we must be loaded before creating objects
    displayData() {

        //pause change updates
        this.pauseUpdates();

        //clear the cached data flag, if it is present
        this.dataCached = false;

        var editData = apogeeutil$1.jsonCopy(this.cachedDisplayData);
        if(!editData) {
            editData = [[]];
        }

        if((!this.gridControl)||(this.activeEditOk !== this.editOk)) {
            this.createNewGrid(editData);
            this.activeEditOk = this.editOk;
        }
        else {
            this.gridControl.loadData(editData);
        }

        //set the background color
        if(this.editOk) {
            this.gridDiv.style.backgroundColor = "";
        }
        else {
            this.gridDiv.style.backgroundColor = DATA_DISPLAY_CONSTANTS.NO_EDIT_BACKGROUND_COLOR;
        }

        //restart change updates
        this.unpauseUpdates(false);
    }
    
    //this merifies the data is an array of arrays
    dataIsValidFormat(json) {
        if(Array.isArray(json)) {
            return json.every(Array.isArray);
        }
        else {
            return false;
        }
    }

}

//configuration constants
let MAX_PIXEL_HEIGHT = 1000;
let DEFAULT_PIXEL_HEIGHT = 300;
let MIN_PIXEL_HEIGHT = 30;
let DELTA_PIXEL_HEIGHT = 20;

/** This class is used to provide user-code user interface access to 
 * modifying the model using commands. */
class UiCommandMessenger {
    
    constructor(componentView,fromMemberId) {
        this.componentView = componentView;
        this.fromMemberId = fromMemberId;
        this.app = componentView.getApp();
    }
    
    /** This method sents a command to update the given member, as specified by the
     * variable name updateMemberName, with the value data. UpdateMemberName should
     * be the name as it would be specified in a formula from the given member. Data may
     * get a JSON or a Promise (for asynch data), Error (to set an error state) 
     * or apogeeutil.INVALID_VALUE.*/
    dataCommand(updateMemberName,data,optionalCommandDescription,optionalSetsWorkspaceDirty) { 
        let command  = {};
        command.type = "saveMemberData";
        command.memberId = this._getLocalMemberId(updateMemberName);
        command.data = data;

        //if the member is not found we will error out with this command
        return this.app.executeCommand(command);
    }
    
    /** This is similar to getDataUpdateCommand but it allows setting multiple values.
     * UpdateInfo is an array with each element being a array of two values with the first
     * being the member name and the second being the value to set. */
    compoundDataCommand(updateInfo,optionalCommandDescription,optionalSetsWorkspaceDirty) {

        let command  = {};
        command.type = "saveMemberCompound";
        command.updateList = updateInfo.map( updateInfo => {
            let updateListEntry = {};
            updateListEntry.memberId = this._getLocalMemberId(updateInfo[0]);
            updateListEntry.data = updateInfo[1];
            return updateListEntry;
        });
        return this.app.executeCommand(command);
    }
    
    //=============================
    // Private Functions
    //=============================

    /** This method returns the member instance for a given local member name,
     * as defined from the source object context. */
    _getLocalMemberId(localMemberName) { 
        let model = this.app.getModel();
        let fromMember = model.lookupMemberById(this.fromMemberId);
        let contextManager = fromMember.getContextManager();

        var pathArray = localMemberName.split(".");
        var member = contextManager.getMember(model,pathArray);
        if(member) {
            return member.getId();
        }
        else {
            console.error("Member not found: " + pathArray.join("."));
            return null;
        }
    }

    
}

/** HtmlJsDataDisplay
 * This is the data display for a custom control where the display is generated from
 * HTML and javascript code. The datasrouce for this data display has some additional 
 * fields defined for it: 
 * 
 * - html = dataSource.getHtml(); REQUIRED - This retrieves the HTML for the display
 * - resource = dataSource.getResource(); REQUIRED - This retrieves the "resource" object to run the display (This is similar to
 *              getDisplayData listed below in that it is used during the construction of the display, however this returns an 
 *              object generated at the app layer for constructing the UI.)
 * - member = dataSource.getContextMember(); REQUIRED - This retrieves a member to use as a context reference
 * - displayData = dataSource.getDisplayData(); OPTIONAL - This returns model data to _construct_ the form
 *              whereas the standard getData() method returns data to _populate_ the form. If the display data is
 *              not valid then the value INVALID_VALUE should be passed.
 * 
 * The resource object can have the following methods. All of these are optional. The areguments include the outputElement
 * whcih is the DOM element for the window and the "admin" object, which is provides some facilities to these methods. The admin
 * is described below.
 * 
 * - init(outputElement,admin) - This is called when the data display is first created.
 * - setData(data,outputElement,admin) - This is called to set model data in the display, whenever the model data
 *                is updated. This will be called _after_ the onLoad method below.
 * - getData(outputElement,admin) - This is called to retrieve data from the display, during a save in edit mode.
 * - isCloseOk(outputElement,admin) - This is called before the data display is closed. Returning false will cancel the close, at
 *                the users option.
 * - destroy(outputElement,admin) - This is called after the display is closed.
 * - onLoad(outputElement,admin) - This is called when the HTML of the data display is loaded.
 * - onUnload(outputElement,admin) - This is called after the HTML for the data display is unloaded from the window.
 * 
 * The admin object includes the following functions on it:
 * getMessenger()
 * startEditMode()
 * endEditMode()
 */

/** This is the display/editor for the custom control output. */
class HtmlJsDataDisplay extends DataDisplay {
    constructor(displayContainer,dataSource) {
        
        super(displayContainer,dataSource);
        
        this.isLoaded = false;
        this.cachedData = undefined;

        this.outputElement = uiutil.createElement("div",null,{
            "position":"relative"
        });

        this._constructDisplay(displayContainer,dataSource);
    }

    getContent() {
        return this.outputElement;
    }

    /** This method implements the methods needed for the display interface from the data source */
    _constructDisplay() {
        let displayContainer = this.getDisplayContainer();
        let dataSource = this.getDataSource();

        let displayValid;
        try {
            let componentView = this.getComponentView();
            let contextMember = dataSource.getContextMember ? dataSource.getContextMember() : componentView.getComponent().getMember();
            let contextMemberId = contextMember.getId();

            //get html
            let html = dataSource.getHtml ? dataSource.getHtml() : "";
            
            //get resource and handle invalid resource
            let resource = dataSource.getResource();
            if(resource.displayInvalid) {
                let messageType = (resource.messageType !== undefined) ? resource.messageType : DATA_DISPLAY_CONSTANTS.MESSAGE_TYPE_ERROR;
                let message = (resource.message !== undefined) ? resource.message : "Display unavailable";
                this.displayContainer.setHideDisplay(true);
                this.displayContainer.setMessage(messageType,message);
                this.setDisplayValid(false);
                return;
            }

            //get display data and handle invalid display data
            let displayData;
            if(dataSource.getDisplayData) {
                let dataResult = dataDisplayHelper.readWrappedDisplayData(dataSource.getDisplayData,"Error loading display input data: ");
                if(dataResult.displayInvalid) {
                    //display invalid! hide display and show message
                    this.displayContainer.setHideDisplay(dataResult.hideDisplay);
                    this.displayContainer.setMessage(dataResult.messageType,dataResult.message);
                    this.setDisplayValid(false);
                    return
                }
                else {
                    //display display valid
                    displayData = dataResult.data;
                    this.setDisplayValid(true);
                }
            }

            //content
            if(html) {
                this.outputElement.innerHTML = html;
            }
            
            //this gives the ui code access to some data display functions
            var admin = {
                getCommandMessenger: () => new UiCommandMessenger(componentView,contextMemberId),
                startEditMode: () => this.startEditMode(),
                endEditMode: () => this.endEditMode()
            };

            if(resource.onLoad) {
                this.onLoad = () => {
                    let progress = 0;
                    try {
                        resource.onLoad.call(resource,this.outputElement,admin);
                        this.isLoaded = true;
                        progress = 1;

                        //set the display data if we have any
                        if((displayData !== undefined)&&(resource.setDisplayData)) {
                            resource.setDisplayData(displayData);
                        }
                        progress = 2;
                        
                        //handle the case the data loaded before the html (which we don't want)
                        if(this.cachedData != undefined) {
                            this.setData(this.cachedData);
                            this.cachedData = undefined;
                        }
                    }
                    catch(error) {
                        //hide dispay and show error message
                        //use "progress" to figure uot where the error occurred to set the message
                        let errorPrefix;
                        switch(progress) {
                            case 0:
                                errorPrefix = "Error in onLoad of display: ";
                                break;

                            case 1:
                                errorPrefix = "Error in setDisplayData of display: ";
                                break;

                            case 2:
                                errorPrefix = "Error in setData: ";
                                break;

                            default:
                                errorPrefix = "Unknown error in loading display: ";
                                break;
                        }


                        let errorMsg = errorPrefix + error.toString();
                        displayContainer.setHideDisplay(true);
                        displayContainer.setMessage(DATA_DISPLAY_CONSTANTS.MESSAGE_TYPE_ERROR,errorMsg);
                        //set display invalid because this is part of creating the display
                        this.setDisplayValid(false);

                        if(error.stack) console.error(error.stack);
                    }
                };
            }
            else {
                this.isLoaded = true;
            }

            if(resource.onUnload) {   
                this.onUnload = () => {
                    try {
                        
                        this.isLoaded = false;
                        this.cachedData = undefined;
                        
                        resource.onUnload.call(resource,this.outputElement,admin);
                    }
                    catch(error) {
                        if(error.stack) console.error(error.stack);
                        
                        //display message for user
                        let member = componentView.getComponent().getMember();
                        apogeeUserAlert("Error in '" + member.getName() + "' onUnload function: " + error.message);
                    }
                };
            }

            this.setData = (data) => {
                try {
                    if(resource.setData) {
                        if(!this.isLoaded) {
                            this.cachedData = data;
                            return;
                        }
                        
                        resource.setData.call(resource,data,this.outputElement,admin);
                    }
                    else {
                        //we must include a function here
                        this.setData = () => {};
                    }
                }
                catch(error) {
                    //hide dispay and show error message
                    let errorMsg = "Error in setData in display: " + error.toString();
                    displayContainer.setHideDisplay(true);
                    displayContainer.setMessage(DATA_DISPLAY_CONSTANTS.MESSAGE_TYPE_ERROR,errorMsg);
                    //note - do not set display invalid here because this is part of data loading, not display loading

                    if(error.stack) console.error(error.stack);
                }
            };
            
            if(resource.getData) {
                this.getData = () => {
                    //here we let data display handle any failure to get data.
                    return resource.getData.call(resource,this.outputElement,admin);
                };
            }
            else {
                //we must include a function here
                //WHY RETURN A DUMMY OBJECT? WHY NOT NULL? OR INVALID?
                this.getData = () => {};
            }

            if(resource.isCloseOk) {     
                this.isCloseOk = () => {
                    try {
                        return resource.isCloseOk.call(resource,this.outputElement,admin);
                    }
                    catch(error) {
                        //allow close if we have an error
                        if(error.stack) console.error(error.stack);

                        let member = componentView.getComponent().getMember();
                        apogeeUserAlert("Error in '" + member.getName()+ "' isCloseOk function: " + error.message);
                        return true;
                    }
                };
            }

            if(resource.destroy) {
                this.destroy = () => {
                    try {
                        resource.destroy.call(resource,this.outputElement,admin);
                    }
                    catch(error) {
                        if(error.stack) console.error(error.stack);
                        
                        //display message for user
                        let member = componentView.getComponent().getMember();
                        apogeeUserAlert("Error in '" + member.getName() + "' destroy function: " + error.message);
                    }
                };
            }

            //-------------------
            //initialization
            //-------------------

            if(resource.init) {
                try {
                    resource.init.call(resource,this.outputElement,admin);
                }
                catch(error) {
                    let errorMsg = "Error in init of display: " + error.toString();
                    displayContainer.setHideDisplay(true);
                    displayContainer.setMessage(DATA_DISPLAY_CONSTANTS.MESSAGE_TYPE_ERROR,errorMsg);
                    //set display invalid because this is part of creating the display
                    this.setDisplayValid(false);

                    if(error.stack) console.error(error.stack);
                    return;
                }
            }

            displayValid = true;
        }
        catch(error) {
            let errorMsg = "Error loading display: " + error.toString();
            displayContainer.setHideDisplay(true);
            displayContainer.setMessage(DATA_DISPLAY_CONSTANTS.MESSAGE_TYPE_ERROR,errorMsg);

            if(error.stack) console.error(error.stack);

            displayValid = false;
        }

        this.setDisplayValid(displayValid);
    }
}

/** Standard Error display.
 * 
 * @param {type} displayContainer - the display container
 * @param {type} dataSource - {updateComponent,getData,getEditOk,setData}; format for data is text
 */
class StandardErrorDisplay extends DataDisplay {
    
    constructor(displayContainer,dataSource) {
        super(displayContainer,dataSource);

        this.destroyed = false;

        this.editorDiv = document.createElement("div");
        this.editorDiv.className = "errorDisplay_main";
    }
    
    getContent() {
        return this.editorDiv;
    }

    setData(json) {
        uiutil.removeAllChildren(this.editorDiv);

        if(Array.isArray(json)) {
            let errorInfoDiv = _createErrorInfoDiv();
            this.editorDiv.appendChild(errorInfoDiv);
            _processList(errorInfoDiv,json);
        }
    }
    
    onLoad() {
    }

    destroy() {
    }

}

//===================================
// Error Info Elements
//===================================

function _processList(errorInfoDiv,errorInfoList) {
    errorInfoList.forEach(errorInfo => {
        switch(errorInfo.type) {
            case "esprimaParseError":
                _addEsprimseParseError(errorInfoDiv,errorInfo);
                break;

            case "javascriptParseError":
                _addJavascriptParseError(errorInfoDiv,errorInfo);
                break;

            case "runtimeError":
                _addRuntimeError(errorInfoDiv,errorInfo);
                break;

            case "multiMember":
                _addMultiMemberError(errorInfoDiv,errorInfo);
                break;

            case "dependency":
                _addDependencyError(errorInfoDiv,errorInfo);
                break;
            

            default:
                //for now we will print other errors too
                _addOtherError(errorInfoDiv,errorInfo);
        }
    });
}

function _addEsprimseParseError(errorInfoDiv,errorInfo) {
    if(errorInfo.description) _addMainDescription(errorInfoDiv,errorInfo.description);
    if(errorInfo.errors) _addEsprimaErrorSection(errorInfoDiv,errorInfo.errors);
    if(errorInfo.code)  _addSimpleCodeSection(errorInfoDiv,"Parsed Code",errorInfo.code);
}

function _addJavascriptParseError(errorInfoDiv,errorInfo) {
    if(errorInfo.description) _addMainDescription(errorInfoDiv,errorInfo.description);
    if(errorInfo.stack) _addStackTraceSection(errorInfoDiv,errorInfo.stack);
    if(errorInfo.code) _addSimpleCodeSection(errorInfoDiv,"Parsed Code",errorInfo.code);
}

function _addRuntimeError(errorInfoDiv,errorInfo) {
    if(errorInfo.description) _addMainDescription(errorInfoDiv,errorInfo.description);
    if(errorInfo.stack) _addStackTraceSection(errorInfoDiv,errorInfo.stack);
    if(errorInfo.memberTrace) _addMemberCodeSection(errorInfoDiv,errorInfo.memberTrace);
}

function _addMultiMemberError(errorInfoDiv,errorInfo) {
    if(errorInfo.memberEntries) errorInfo.memberEntries.forEach( memberData => {
        if((memberData.name)&&(memberData.errorInfoList)&&(memberData.errorInfoList.length > 0)) {
            _addMemberTitle(errorInfoDiv,memberData.name);
            _processList(errorInfoDiv,memberData.errorInfoList);
        } 
    });
}

function _addDependencyError(errorInfoDiv,errorInfo) {
    if((errorInfo.dependsOnErrorList)&&(errorInfo.dependsOnErrorList.length > 0)) {
        let msgPrefix = (errorInfo.dependsOnErrorList.length === 1) ? "Error in dependency: " : "Error in dependencies: ";
        let dependencyNameString = errorInfo.dependsOnErrorList.map( dependsOnEntry => dependsOnEntry.name).join(", "); 
        _addSectionHeading(errorInfoDiv,msgPrefix + dependencyNameString,1);
    }
}

function _addOtherError(errorInfoDiv,errorInfo) {
    //this is jsut for dev, for now at least
    //so we will use inline style parameters
    let headingDiv = document.createElement("div");
    headingDiv.innerHTML = "Error info:";
    errorInfoDiv.appendChild(headingDiv);
    let bodyDiv = document.createElement("div");
    bodyDiv.innerHTML = JSON.stringify(errorInfo);
    bodyDiv.style.color = "red";
    errorInfoDiv.appendChild(bodyDiv);
}

//===========================================
// These are combination elements 
//===========================================

function _addStackTraceSection(errorInfoDiv,stackTrace) {
    let sectionDiv = _createSectionDiv();
    errorInfoDiv.appendChild(sectionDiv);

    _addSectionHeading(sectionDiv,"Stack Trace",1);
    let containerDiv = document.createElement("div");
    containerDiv.innerHTML = stackTrace;
    containerDiv.className = "errorDisplay_stackTraceDiv";
    sectionDiv.appendChild(containerDiv);
}

function _addSimpleCodeSection(errorInfoDiv,title,code) {
    let sectionDiv = _createSectionDiv();
    errorInfoDiv.appendChild(sectionDiv);

    _addSectionHeading(sectionDiv,title,1);
    _addCode(sectionDiv,code);
}

function _addMemberCodeSection(errorInfoDiv,memberTrace) {
    if(Array.isArray(memberTrace)) {
        let sectionDiv = _createSectionDiv();
        errorInfoDiv.appendChild(sectionDiv);

        _addSectionHeading(sectionDiv,"Member Code",1);
        memberTrace.forEach(memberEntry => _addMemberCodeEntry(sectionDiv,memberEntry));
    }
}

function _addMemberCodeEntry(sectionDiv,memberCodeEntry) {
    if(memberCodeEntry.name) _addSectionHeading(sectionDiv,memberCodeEntry.name,2);
    _addCode(sectionDiv,memberCodeEntry.code);
}

function _addEsprimaErrorSection(errorInfoDiv,esprimaErrorArray) {
    if(Array.isArray(esprimaErrorArray)) {
        let sectionDiv = _createSectionDiv();
        errorInfoDiv.appendChild(sectionDiv);

        _addSectionHeading(sectionDiv,"Parse Errors",1);
        esprimaErrorArray.forEach(esprimaError => _addEsprimaError(sectionDiv,esprimaError));
    }
}

function _addEsprimaError(sectionDiv,esprimaError) {

    if(esprimaError.description) _addSectionHeading(sectionDiv,esprimaError.description,2);

    if(esprimaError.lineNumber) {
        _addSectionLabelLine(sectionDiv,"Line Number: ",esprimaError.lineNumber);
    }
    if(esprimaError.column) {
        _addSectionLabelLine(sectionDiv,"Column: ",esprimaError.column);
    }
    if(esprimaError.index) {
        _addSectionLabelLine(sectionDiv,"Index: ",esprimaError.index);
    }
}


//===========================================
// These are standard individual elements 
//===========================================

/** This is a wrapper for a single error info object */
function _createErrorInfoDiv() {
    let errorInfoDiv = document.createElement("div");
    errorInfoDiv.className = "errorDisplay_errorInfoDiv";
    return errorInfoDiv;
}

function _addMemberTitle(errorInfoDiv,memberName) {
    let containerDiv = document.createElement("div");
    containerDiv.innerHTML = memberName + ":";
    containerDiv.className = "errorDisplay_memberTitleDiv";
    errorInfoDiv.appendChild(containerDiv);
}

/** This is the main description for a error info. It should be 
 * placed directly in the error info div, at the top. */
function _addMainDescription(errorInfoDiv,description) {
    let containerDiv = document.createElement("div");
    containerDiv.innerHTML = description;
    containerDiv.className = "errorDisplay_descriptionSectionDiv";
    errorInfoDiv.appendChild(containerDiv);
}

/** This is a wrapper for a section within an error info */
function _createSectionDiv() {
    let sectionDiv = document.createElement("div");
    sectionDiv.className = "errorDisplay_sectionDiv";
    return sectionDiv;
}

/** This adds a heading line to a section. See supported levels below. */
function _addSectionHeading(sectionDiv,text,level) {
    let headingDiv = document.createElement("div");
    headingDiv.className = HEAD_CLASS_LEVEL_MAP[level];
    headingDiv.innerHTML = text;
    sectionDiv.appendChild(headingDiv);
}

const HEAD_CLASS_LEVEL_MAP = {
    1: "errorDisplay_sectionHeadingDiv1",
    2: "errorDisplay_sectionHeadingDiv2",
    3: "errorDisplay_sectionHeadingDiv3",
};

/** This adds single line with a label and text to an entry. 
 * If should be placed in a section. */
function _addSectionLabelLine(sectionDiv,label,text) {
    let lineDiv = document.createElement("div");
    lineDiv.className = "errorDisplay_sectionLabelLineDiv";
    let labelSpan = document.createElement("span");
    labelSpan.className = "errorDisplay_sectionLineLabelSpan";
    labelSpan.innerHTML = label;
    lineDiv.appendChild(labelSpan);
    let textSpan = document.createElement("span");
    textSpan.classname = "errorDisplay_sectionLineTextSpan";
    textSpan.innerHTML = text;
    lineDiv.appendChild(textSpan);
    sectionDiv.appendChild(lineDiv);
}

/** This is code. It should be placed in a section. */
function _addCode(sectionDiv,code) {
    let container = document.createElement("pre");
    container.className = "errorDisplay_codeSection";
    //split code into lines, each will be numbered
    let lineArray = code.split("\n");
    lineArray.forEach(line => {
        let codeLine = document.createElement("code");
        codeLine.innerHTML = line + "\n";
        container.appendChild(codeLine);
    });
    //-------------------
    //this is a clumsy way of adjusting the number line gutter for longer code
    //but I am not sure how I should do this.
    //if the code is longer then 10000 then they have to deal with the line numbers going outside the gutter for now.
    if((lineArray.length > 99)&&(lineArray.length < 1000)) {
        container.classList.add("errorDisplay_longCode");
    }
    else if(lineArray.length > 1000) {
        container.classList.add("errorDisplay_veryLongCode");
    }
    //-------------------
    sectionDiv.appendChild(container);
}

/** This namespace provides methods to create a standard save bar and other toolbars. */

function getSaveBar(onSave,onCancel) {
    var saveDiv = uiutil.createElement("div",null,
        {
            //"display":"block",
            //"position":"relative",
            //"top":"0px",
            "backgroundColor":"white",
            "border":"solid 1px gray",
            "padding":"3px"
        });

    saveDiv.appendChild(document.createTextNode("Edit: "));
    saveDiv.className = "visiui_hideSelection";

    var saveBarSaveButton = document.createElement("button");
    saveBarSaveButton.innerHTML = "Save";
    saveBarSaveButton.onclick = onSave;
    saveBarSaveButton.className = "visiui_hideSelection";
    saveDiv.appendChild(saveBarSaveButton);

    saveDiv.appendChild(document.createTextNode(" "));

    var saveBarCancelButton = document.createElement("button");
    saveBarCancelButton.innerHTML = "Cancel";
    saveBarCancelButton.onclick = onCancel;
    saveBarCancelButton.className = "visiui_hideSelection";
    saveDiv.appendChild(saveBarCancelButton);
    
    return saveDiv;
}

//=====================================
// UI Entry Point
//=====================================

/** This closes the workspace. The postCloseAction is optional. If this is included it will be executed if and after the
 * workspace is closed. */
function closeWorkspace(app,postCloseAction) {
    
    var activeWorkspaceManager = app.getWorkspaceManager();
    if(activeWorkspaceManager === null) {
        apogeeUserAlert("There is no workspace close.");
        return;
    }
    
    var commandData = {};
    commandData.type = "closeWorkspace";

    let doClose = () => {
        let success = app.executeCommand(commandData);
        //add an optional action for after close - this is meant for opening a workspace, for one
        if((success)&&(postCloseAction)) {
            postCloseAction();
        }
    };

    //if the workspace is not saved give the user a warning and chance to cancel
    if(activeWorkspaceManager.getIsDirty()) {
        let cancelAction = () => true;
        let deleteMsg = "There is unsaved data. Are you sure you want to close the workspace?";
        apogeeUserConfirm(deleteMsg,"Close","Cancel",doClose,cancelAction);
    }
    else {
        doClose();
    }
}

//=====================================
// UI Entry Point
//=====================================

function createWorkspace(app) {
    //make sure there is not an open workspace
    if(app.getWorkspaceManager()) {
        apogeeUserAlert("There is already an open workspace. You must close the workspace first.");
        return;
    }      
    
    var commandData = {};
    commandData.type = "openWorkspace";
    
    app.executeCommand(commandData);
}

//=====================================
// UI Entry Point
//=====================================

/** This is the UI sequence to open a workspace */
function openWorkspace(app,fileAccessObject) {
    let onOpen = (err,workspaceData,fileMetadata) => onWorkspaceOpen(err,app,workspaceData,fileMetadata);

    let doOpen = () => fileAccessObject.openFile(onOpen);

    //If there is an open workspace, close first
    if(app.getWorkspaceManager()) {
        closeWorkspace(app,doOpen);
    }    
    else {
        doOpen();
    }
}

//=====================================
// Internal functions
//=====================================

/** This method should be called when workspace data is opened, to create the workspace. */
function onWorkspaceOpen(err,app,workspaceData,fileMetadata) {

    if(err) {
        var errorMessage = "There was an error opening the file";
        if(err.message)errorMessage += ": " + err.message;
        apogeeUserAlert(errorMessage);
        return;
    }
    else if(workspaceData) {
        if(app.getWorkspaceManager()) {
            apogeeUserAlert("There is already an open workspace");
            return;
        }
        
        var workspaceJson;
        try {
            workspaceJson = JSON.parse(workspaceData);
        }
        catch(error) {
            if(error.stack) console.error(error.stack);
            
            apogeeUserAlert("Error parsing workspace content: " + error.message);
            return;
        }
        
        //open workspace
        var commandData = {};
        commandData.type = "openWorkspace";
        commandData.workspaceJson = workspaceJson;
        commandData.fileMetadata = fileMetadata;

        app.executeCommand(commandData);
    }
}

//=====================================
// UI Entry Point
//=====================================

function saveWorkspace(app,fileAccessObject,requestDirectSave) {

    var activeWorkspaceManager = app.getWorkspaceManager();
    var workspaceText;
    var fileMetadata;
    var doDirectSave = false;
    if(activeWorkspaceManager) {
        var workspaceJson = activeWorkspaceManager.toJson();
        workspaceText = JSON.stringify(workspaceJson);
        fileMetadata = activeWorkspaceManager.getFileMetadata();
        //see if we can do a direct save
        if(requestDirectSave) doDirectSave = fileAccessObject.directSaveOk(fileMetadata);
    }
    else {
        apogeeUserAlert("There is no workspace open.");
        return;
    }

    //clear workspace dirty flag on completion of save
    var onSave = (err,fileSaved,updatedFileMetadata) => {
        if(err) {
            apogeeUserAlert("There was an error saving the file: " + err.toString());
        }
        else if(fileSaved) {
            var workspaceManager = app.getWorkspaceManager();
            workspaceManager.clearIsDirty();
            if(updatedFileMetadata) {
                workspaceManager.setFileMetadata(updatedFileMetadata);
            }
        }
    };

    if(doDirectSave) {
        fileAccessObject.saveFile(fileMetadata,workspaceText,onSave);
    }
    else {
        fileAccessObject.saveFileAs(fileMetadata,workspaceText,onSave);
    }
}

const DIALOG_LAYOUT_TITLE_LINE = {
    "type": "heading",
    "text": "Update Workspace",
    "level": 3
};
const DIALOG_LAYOUT_NAME_LINE = {
    "type": "textField",
    "label": "Name: ",
    "size": 40,
    "key": "name",
    "initial": "",
    "focus": true
};

//=====================================
// UI Entry Point
//=====================================

/** This method gets a callback to update the properties of a workspace. */
function updateWorkspaceProperties(workspaceManager) {
        
    var model = workspaceManager.getModelManager().getModel();

    //load initial values
    var initialValues = {};
    initialValues.name = model.getName();

    //create the dialog layout
    var nameLine = apogeeutil$1.jsonCopy(DIALOG_LAYOUT_NAME_LINE);
    nameLine.value = initialValues.name;

    var dialogLayout = {};
    dialogLayout.layout = [];
    dialogLayout.layout.push(DIALOG_LAYOUT_TITLE_LINE);
    dialogLayout.layout.push(nameLine);
    //(add any workspace ui lines here)

    //create on submit callback
    var onSubmitFunction = function(newValues) {

        var valuesChanged = false;

        //validate the name, if it changed
        if(newValues.name !== initialValues.name) {
            //validate name - for now just make sure it is not zero length
            if(newValues.length === 0) {
                apogeeUserAlert("The name must not be empty");
                return false;
            }

            valuesChanged = true;
        }

        //validate any other fields here

        //update
        if(valuesChanged) {
            var commandData = {};
            commandData.type = "updateWorkspace";
            commandData.updatedCoreProperties = {};
            commandData.updatedCoreProperties.name = newValues.name;

            workspaceManager.getApp().executeCommand(commandData);
        }

        //return true to close the dialog
        return true;
    };

    //show dialog
    showConfigurableDialog(dialogLayout,onSubmitFunction);
}

const DIALOG_LAYOUT_URL_LINE = {
    "type": "textField",
    "label": "URL: ",
    "size": 100,
    "key": "url",
    "value": "",
    "focus": true
};
const DIALOG_LAYOUT_NICKNAME_LINE = {
    "type": "textField",
    "label": "Nickname (optional): ",
    "size": 40,
    "key": "nickname",
    "value": ""
};

//=====================================
// UI Entry Point
//=====================================

/** This method adds a link to the workspace. */
function addLink(app,displayInfo) {
        
    //create the dialog layout 
    var titleLine = {};
    titleLine.type = "heading";
    titleLine.text = displayInfo.ADD_ENTRY_TEXT;
    titleLine.level = 3;

    var dialogLayout = {};
    dialogLayout.layout = [];
    dialogLayout.layout.push(titleLine);
    dialogLayout.layout.push(DIALOG_LAYOUT_URL_LINE);
    dialogLayout.layout.push(DIALOG_LAYOUT_NICKNAME_LINE);

    //create on submit callback
    var onSubmitFunction = function(newValues) {

        //validate url- for now just make sure it is not zero length
        if((!newValues.url)||(newValues.url.length === 0)) {
            apogeeUserAlert("The url must not be empty");
            return false;
        }

        //create command json
        var commandData = {};
        commandData.type = "addLink";
        commandData.entryType = displayInfo.REFERENCE_TYPE;
        commandData.url = newValues.url;
        commandData.nickname = newValues.nickname;

        //run command
        app.executeCommand(commandData);

        //return true to close the dialog
        return true;
    };

    //show dialog
    showConfigurableDialog(dialogLayout,onSubmitFunction);
}

/** This method updates a link in the workspace. */
function updateLink(app,referenceEntry,displayInfo) {
        
    var initialValues = {};
    initialValues.url = referenceEntry.getUrl();
    initialValues.nickname = referenceEntry.getNickname();
    if(initialValues.nickname == initialValues.url) initialValues.nickname = "";

    //create the dialog layout
    var titleLine = {};
    titleLine.type = "heading";
    titleLine.text = displayInfo.UPDATE_ENTRY_TEXT;
    titleLine.level = 3;

    var urlLine = apogeeutil$1.jsonCopy(DIALOG_LAYOUT_URL_LINE);
    urlLine.value = initialValues.url;
    var nicknameLine = apogeeutil$1.jsonCopy(DIALOG_LAYOUT_NICKNAME_LINE);
    nicknameLine.value = initialValues.nickname;

    var dialogLayout = {};
    dialogLayout.layout = [];
    dialogLayout.layout.push(titleLine);
    dialogLayout.layout.push(urlLine);
    dialogLayout.layout.push(nicknameLine);

    //create on submit callback
    var onSubmitFunction = function(newValues) {

        //validate url- for now just make sure it is not zero length
        if((!newValues.url)||(newValues.url.length === 0)) {
            apogeeUserAlert("The url must not be empty");
            return false;
        }

        //run command
        var commandData = {};
        var dataChanged = false;
        commandData.type = "updateLink";
        commandData.entryType = displayInfo.REFERENCE_TYPE;
        commandData.oldUrl = initialValues.url;
        if(initialValues.url != newValues.url) {
            commandData.newUrl = newValues.url;
            dataChanged = true;
        }
        if(initialValues.nickname != newValues.nickname) {
            commandData.newNickname = newValues.nickname;
            dataChanged = true;
        }

        if(dataChanged) {
            app.executeCommand(commandData);
        }
            
        //return true to close the dialog
        return true;
    };

    //show dialog
    showConfigurableDialog(dialogLayout,onSubmitFunction);
}


/** This method deletes a link in the workspace. */
function removeLink(app,referenceEntry,displayInfo) {

    var commandData = {};
        commandData.type = "deleteLink";
        commandData.entryType = displayInfo.REFERENCE_TYPE;
        commandData.url = referenceEntry.getUrl();

    //create on submit callback
    let doAction = () => app.executeCommand(commandData);
    let cancelAction = () => true;

    //verify the delete
    let deleteMsg = "Are you sure you want to delete this link?";
    apogeeUserConfirm(deleteMsg,"Delete","Cancel",doAction,cancelAction);
}

class JsonTableComponentView extends ComponentView {

    constructor(appViewInterface,jsonTableComponent) {
        super(appViewInterface,jsonTableComponent);
    }

    //==============================
    // Protected and Private Instance Methods
    //==============================

    /**  This method retrieves the table edit settings for this component instance
     * @protected */
    getTableEditSettings() {
        return JsonTableComponentView.TABLE_EDIT_SETTINGS;
    }

    /** This method should be implemented to retrieve a data display of the give type. 
     * @protected. */
    getDataDisplay(displayContainer,viewType) {
        
        var dataDisplaySource;
        var app = this.getApp();
        
        //create the new view element;
        switch(viewType) {
            case JsonTableComponentView.VIEW_DATA:
                var component = this.getComponent();
                let dataView = component.getField("dataView");
                //update the display container state bar
                this._setDisplayContainerStatus(displayContainer,dataView);
                switch(dataView) {
                    case JsonTableComponentView.COLORIZED_DATA_VEW:
                    default:
                        dataDisplaySource = this._wrapSourceForViewChange(dataDisplayHelper.getMemberDataTextDataSource(app,this,"member"));
                        return new AceTextEditor(displayContainer,dataDisplaySource,"ace/mode/json",AceTextEditor.OPTION_SET_DISPLAY_SOME);
                        
                    case JsonTableComponentView.TEXT_DATA_VEW:
                        dataDisplaySource = this._wrapSourceForViewChange(dataDisplayHelper.getMemberDataJsonDataSource(app,this,"member"));
                        return new AceTextEditor(displayContainer,dataDisplaySource,"ace/mode/text",AceTextEditor.OPTION_SET_DISPLAY_MAX);
                        
                    case JsonTableComponentView.GRID_DATA_VEW:
                        dataDisplaySource = this._wrapSourceForViewChange(dataDisplayHelper.getMemberDataJsonDataSource(app,this,"member"));
                        return new HandsonGridEditor(displayContainer,dataDisplaySource);
                }
                
            case JsonTableComponentView.VIEW_CODE:
                dataDisplaySource = dataDisplayHelper.getMemberFunctionBodyDataSource(app,this,"member",DEFAULT_DATA_VALUE);
                return new AceTextEditor(displayContainer,dataDisplaySource,"ace/mode/javascript",AceTextEditor.OPTION_SET_DISPLAY_MAX);
                
            case JsonTableComponentView.VIEW_SUPPLEMENTAL_CODE:
                dataDisplaySource = dataDisplayHelper.getMemberSupplementalDataSource(app,this,"member",DEFAULT_DATA_VALUE);
                return new AceTextEditor(displayContainer,dataDisplaySource,"ace/mode/javascript",AceTextEditor.OPTION_SET_DISPLAY_MAX);

            case ComponentView.VIEW_INFO: 
                dataDisplaySource = dataDisplayHelper.getStandardErrorDataSource(app,this);
                return new StandardErrorDisplay(displayContainer,dataDisplaySource);
                
            default:
    //temporary error handling...
                console.error("unrecognized view element: " + viewType);
                return null;
        }
    }

    /** This method updated the data display source to account for reloading the data display due to 
     * a change in the data view. */
    _wrapSourceForViewChange(dataDisplaySource) {
        let originalDoUpdate = dataDisplaySource.doUpdate;
        dataDisplaySource.doUpdate = () => {
            let returnValue = originalDoUpdate();
            returnValue.reloadDataDisplay = this.getComponent().isFieldUpdated("dataView");
            return returnValue;
        };
        return dataDisplaySource;
    }

    _setDisplayContainerStatus(displayContainer,dataView) {
        let displayBarElement = displayContainer.getDisplayBarElement();
        if(displayBarElement) {
            uiutil.removeAllChildren(displayBarElement);
            let statusElement = document.createElement("span");
            statusElement.innerHTML = "Display Format: " + VIEW_DISPLAY_NAMES[dataView];
            statusElement.style.fontSize = "smaller";
            statusElement.style.color = "gray";
            statusElement.style.marginLeft = "20px";
            statusElement.style.userSelect ;            statusElement.className = "visiui_hideSelection";
            displayBarElement.appendChild(statusElement);
        }
    }
}

/** This is used as the default data value if we clear the code. It really should be a function of the data view,
 * since in grid mode this is an invalid value. Support for that shold be added. */
let DEFAULT_DATA_VALUE = "";

//===============================
// Internal Settings
//===============================

JsonTableComponentView.VIEW_DATA = "Data";
JsonTableComponentView.VIEW_CODE = "Formula";
JsonTableComponentView.VIEW_SUPPLEMENTAL_CODE = "Private";

JsonTableComponentView.VIEW_MODES = [
    ComponentView.VIEW_INFO_MODE_ENTRY,
    {
        name: JsonTableComponentView.VIEW_DATA,
        label: "Data",
        sourceLayer: "model",
        sourceType: "data",
        isActive: true
    },
    {
        name: JsonTableComponentView.VIEW_CODE,
        label: "Formula",
        sourceLayer: "model",
        sourceType: "function",
        isActive: false
    },
    {
        name: JsonTableComponentView.VIEW_SUPPLEMENTAL_CODE,
        label: "Private",
        sourceLayer: "model",
        sourceType: "private code",
        isActive: false
    }   
];

JsonTableComponentView.TABLE_EDIT_SETTINGS = {
    "viewModes": JsonTableComponentView.VIEW_MODES,
    "emptyDataValue": ""
};

JsonTableComponentView.COLORIZED_DATA_VEW = "Colorized";
JsonTableComponentView.TEXT_DATA_VEW = "Text Data";
JsonTableComponentView.GRID_DATA_VEW = "Grid";

JsonTableComponentView.DEFAULT_DATA_VIEW = JsonTableComponentView.COLORIZED_DATA_VEW;

let VIEW_DISPLAY_NAMES = {};
VIEW_DISPLAY_NAMES[JsonTableComponentView.COLORIZED_DATA_VEW] = "JSON";
VIEW_DISPLAY_NAMES[JsonTableComponentView.TEXT_DATA_VEW] = "Plain Text";
VIEW_DISPLAY_NAMES[JsonTableComponentView.GRID_DATA_VEW] = "Grid";

//===============================
// External Settings
//===============================

/** This is the component name with which this view is associated. */
JsonTableComponentView.componentName = "apogeeapp.JsonCell";

/** If true, this indicates the component has a tab entry */
JsonTableComponentView.hasTabEntry = false;
/** If true, this indicates the component has an entry appearing on the parent tab */
JsonTableComponentView.hasChildEntry = true;
/** This is the icon url for the component. */
JsonTableComponentView.ICON_RES_PATH = "/icons3/jsonCellIcon.png";
/** This field gives the default value for the JSON taht should be deserialized to
 * create the member for this object. The field "name" can be omitted. This will 
 * be added when the member is created. */

 /** This is configuration for the properties dialog box, the results of which
 * our code will read in. */
JsonTableComponentView.propertyDialogLines = [
    {
        "type":"dropdown",
        "label":"Data Display Format: ",
        "entries":[
            [ VIEW_DISPLAY_NAMES[JsonTableComponentView.COLORIZED_DATA_VEW] , JsonTableComponentView.COLORIZED_DATA_VEW ],
            [ VIEW_DISPLAY_NAMES[JsonTableComponentView.TEXT_DATA_VEW] , JsonTableComponentView.TEXT_DATA_VEW ],
            [ VIEW_DISPLAY_NAMES[JsonTableComponentView.GRID_DATA_VEW] , JsonTableComponentView.GRID_DATA_VEW ]
        ],
        "key":"dataView"
    }
];

/** This component represents a table object. */
class FunctionComponentView extends ComponentView {

    constructor(appViewInterface,functionComponent) {
        //extend edit component
        super(appViewInterface,functionComponent);
    };

    //==============================
    // Protected and Private Instance Methods
    //==============================

    /**  This method retrieves the table edit settings for this component instance
     * @protected */
    getTableEditSettings() {
        return FunctionComponentView.TABLE_EDIT_SETTINGS;
    }

    /** This method should be implemented to retrieve a data display of the give type. 
     * @protected. */
    getDataDisplay(displayContainer,viewType) {
        
        var dataDisplaySource;
        var app = this.getApp();
        
        //create the new view element;
        switch(viewType) {
                
            case FunctionComponentView.VIEW_CODE:
                dataDisplaySource = dataDisplayHelper.getMemberFunctionBodyDataSource(app,this,"member");
                return new AceTextEditor(displayContainer,dataDisplaySource,"ace/mode/javascript",AceTextEditor.OPTION_SET_DISPLAY_MAX);
                
            case FunctionComponentView.VIEW_SUPPLEMENTAL_CODE:
                dataDisplaySource = dataDisplayHelper.getMemberSupplementalDataSource(app,this,"member");
                return new AceTextEditor(displayContainer,dataDisplaySource,"ace/mode/javascript",AceTextEditor.OPTION_SET_DISPLAY_MAX);

            case ComponentView.VIEW_INFO: 
                dataDisplaySource = dataDisplayHelper.getStandardErrorDataSource(app,this);
                return new StandardErrorDisplay(displayContainer,dataDisplaySource);
                
            default:
    //temporary error handling...
                console.error("unrecognized view element: " + viewType);
                return null;
        }
    }

}


FunctionComponentView.VIEW_CODE = "Code";
FunctionComponentView.VIEW_SUPPLEMENTAL_CODE = "Private";

FunctionComponentView.VIEW_MODES = [
    ComponentView.VIEW_INFO_MODE_ENTRY,
    {
        name: FunctionComponentView.VIEW_CODE,
        label: "Code",
        sourceLayer: "model",
        sourceType: "function",
        isActive: true
    },
    {
        name: FunctionComponentView.VIEW_SUPPLEMENTAL_CODE,
        label: "Private",
        sourceLayer: "model",
        sourceType: "private code",
        isActive: false
    },
];

FunctionComponentView.TABLE_EDIT_SETTINGS = {
    "viewModes": FunctionComponentView.VIEW_MODES
};


//======================================
// This is the component generator, to register the component
//======================================

FunctionComponentView.componentName = "apogeeapp.FunctionCell";
FunctionComponentView.hasTabEntry = false;
FunctionComponentView.hasChildEntry = true;
FunctionComponentView.ICON_RES_PATH = "/icons3/functionCellIcon.png";

FunctionComponentView.propertyDialogLines = [
    {
        "type":"textField",
        "label":"Arg List: ",
        "size": 80,
        "key":"argListString"
    }
];

/** This component represents a table object. */
class DynamicFormView extends ComponentView {
        
    constructor(appViewInterface,component) {
        //extend edit component
        super(appViewInterface,component);
    };

    //==============================
    // Protected and Private Instance Methods
    //==============================

    /**  This method retrieves the table edit settings for this component instance
     * @protected */
    getTableEditSettings() {
        return DynamicFormView.TABLE_EDIT_SETTINGS;
    }

    /** This method should be implemented to retrieve a data display of the give type. 
     * @protected. */
    getDataDisplay(displayContainer,viewType) {
        
        var dataDisplaySource;
        var app = this.getApp();
        
        //create the new view element;
        switch(viewType) {
            
            case DynamicFormView.VIEW_FORM:
                dataDisplaySource = this.getFormCallbacks();
                return new ConfigurableFormEditor(displayContainer,dataDisplaySource);
                
            case DynamicFormView.VIEW_CODE:
                dataDisplaySource = dataDisplayHelper.getMemberFunctionBodyDataSource(app,this,"member");
                return new AceTextEditor(displayContainer,dataDisplaySource,"ace/mode/javascript",AceTextEditor.OPTION_SET_DISPLAY_MAX);
                
            case DynamicFormView.VIEW_SUPPLEMENTAL_CODE:
                dataDisplaySource = dataDisplayHelper.getMemberSupplementalDataSource(app,this,"member");
                return new AceTextEditor(displayContainer,dataDisplaySource,"ace/mode/javascript",AceTextEditor.OPTION_SET_DISPLAY_MAX);

            case ComponentView.VIEW_INFO: 
                dataDisplaySource = dataDisplayHelper.getStandardErrorDataSource(app,this);
                return new StandardErrorDisplay(displayContainer,dataDisplaySource);
                
            default:
    //temporary error handling...
                console.error("unrecognized view element: " + viewType);
                return null;
        }
    }

    getFormCallbacks() { 
        var dataDisplaySource = {
            doUpdate: () => {
                //we have no data here, just the form layout
                let reloadData = false;
                let reloadDataDisplay = this.getComponent().isMemberDataUpdated("member");
                return {reloadData,reloadDataDisplay};
            },

            getDisplayData: () => {             
                let functionMember = this.getComponent().getField("member"); 
                let layoutFunction = functionMember.getData();

                //make sure this is a function (could be invalid value, or a user code error)
                if(layoutFunction instanceof Function) {
                    let admin = {
                        getCommandMessenger: () => new UiCommandMessenger(this,functionMember.getId())
                    };
                    try {
                        let layout = layoutFunction(admin);
                        if(layout) return layout;
                        else return ConfigurableFormEditor.getEmptyLayout();
                    }
                    catch(error) {
                        console.error("Error reading form layout " + this.getName() + ": " + error.toString());
                        if(error.stack) console.error(error.stack);
                        return ConfigurableFormEditor.getErrorLayout("Error in layout: " + error.toString())
                    }
                }
                //if we get here there was a problem with the layout
                return apogeeutil.INVALID_VALUE;
            },

            getData: () => {              
                return null;
            }
        };

        return dataDisplaySource;
    }
        
    //======================================
    // Static methods
    //======================================


}

DynamicFormView.VIEW_FORM = "Form";
DynamicFormView.VIEW_CODE = "Code";
DynamicFormView.VIEW_SUPPLEMENTAL_CODE = "Private";

DynamicFormView.VIEW_MODES = [
    ComponentView.VIEW_INFO_MODE_ENTRY,
    {name: DynamicFormView.VIEW_FORM, label: "Form", isActive: true},
    {name: DynamicFormView.VIEW_CODE, label: "Code", isActive: false},
    {name: DynamicFormView.VIEW_SUPPLEMENTAL_CODE, label: "Private", isActive: false},
];

DynamicFormView.TABLE_EDIT_SETTINGS = {
    "viewModes": DynamicFormView.VIEW_MODES
};

//======================================
// This is the component generator, to register the component
//======================================

DynamicFormView.componentName = "apogeeapp.ActionFormCell";
DynamicFormView.hasTabEntry = false;
DynamicFormView.hasChildEntry = true;
DynamicFormView.ICON_RES_PATH = "/icons3/formCellIcon.png";

/** This ccomponent represents a data value, with input being from a configurable form.
 * This is an example of componound component. The data associated with the form
 * can be accessed from the variables (componentName).data. There are also subtables
 * "layout" which contains the form layout and "isInputValid" which is a function
 * to validate form input.
 * If you want a form to take an action on submit rather than create and edit a 
 * data value, you can use the dynmaic form. */
class FormDataComponentView extends ComponentView {

    constructor(appViewInterface,folderComponent) {
        //extend edit component
        super(appViewInterface,folderComponent);
    };

    //==============================
    // Protected and Private Instance Methods
    //==============================

    /**  This method retrieves the table edit settings for this component instance
     * @protected */
    getTableEditSettings() {
        return FormDataComponentView.TABLE_EDIT_SETTINGS;
    }

    /** This method should be implemented to retrieve a data display of the give type. 
     * @protected. */
    getDataDisplay(displayContainer,viewType) {
        
        var dataDisplaySource;
        var app = this.getApp();
        
        //create the new view element;
        switch(viewType) {
                
            case FormDataComponentView.VIEW_FORM:
                dataDisplaySource = this.getFormEditorCallbacks();
                return new ConfigurableFormEditor(displayContainer,dataDisplaySource);
                
            case FormDataComponentView.VIEW_LAYOUT_CODE:
                dataDisplaySource = dataDisplayHelper.getMemberFunctionBodyDataSource(app,this,"member.layout");
                return new AceTextEditor(displayContainer,dataDisplaySource,"ace/mode/javascript",AceTextEditor.OPTION_SET_DISPLAY_MAX);
                
            case FormDataComponentView.VIEW_LAYOUT_SUPPLEMENTAL_CODE:
                dataDisplaySource = dataDisplayHelper.getMemberSupplementalDataSource(app,this,"member.layout");
                return new AceTextEditor(displayContainer,dataDisplaySource,"ace/mode/javascript",AceTextEditor.OPTION_SET_DISPLAY_MAX);
            
            case FormDataComponentView.VIEW_FORM_VALUE:
                dataDisplaySource = dataDisplayHelper.getMemberDataTextDataSource(app,this,"member.data");
                return new AceTextEditor(displayContainer,dataDisplaySource,"ace/mode/json",AceTextEditor.OPTION_SET_DISPLAY_SOME);
                
            case FormDataComponentView.VIEW_INPUT_INVALID_CODE:
                dataDisplaySource = dataDisplayHelper.getMemberFunctionBodyDataSource(app,this,"member.isInputValid");
                return new AceTextEditor(displayContainer,dataDisplaySource,"ace/mode/javascript",AceTextEditor.OPTION_SET_DISPLAY_MAX);
                
            case FormDataComponentView.VIEW_INPUT_INVALID_SUPPLEMENTAL_CODE:
                dataDisplaySource = dataDisplayHelper.getMemberSupplementalDataSource(app,this,"member.isInputValid");
                return new AceTextEditor(displayContainer,dataDisplaySource,"ace/mode/javascript",AceTextEditor.OPTION_SET_DISPLAY_MAX);
                
            default:
    //temporary error handling...
                console.error("unrecognized view element: " + viewType);
                return null;
        }
    }

    getFormEditorCallbacks() {

        var dataDisplaySource = {};
        dataDisplaySource.doUpdate = () => {
            //update depends on multiplefields
            let component = this.getComponent();
            let reloadData = component.isMemberDataUpdated("member.data");
            let reloadDataDisplay = ( (component.isMemberDataUpdated("member.layout")) ||
                (component.isMemberDataUpdated("member.isInputValid")) );
            return {reloadData,reloadDataDisplay};
        },

        //return form layout
        dataDisplaySource.getDisplayData = () => { 
            let layoutFunctionMember = this.getComponent().getField("member.layout");
            if(layoutFunctionMember.getState() == apogeeutil$1.STATE_NORMAL) {
                let layoutFunction = layoutFunctionMember.getData();   
                if(layoutFunction instanceof Function) {
                    try { 
                        let layout = layoutFunction();
                        if(layout) return layout;
                        else return ConfigurableFormEditor.getEmptyLayout();
                    }
                    catch(error) {
                        console.error("Error reading form layout " + this.getName() + ": " + error.toString());
                        if(error.stack) console.error(error.stack);
                        return ConfigurableFormEditor.getErrorLayout("Error in layout: " + error.toString())
                    }
                }
            }
            //if we get here there was a problem with the return value
            return  apogeeutil$1.INVALID_VALUE;
            
        };
        
        //return desired form value
        dataDisplaySource.getData = () => {
            let dataTable = this.getComponent().getField("member.data");
            return dataTable.getData();
        }; 
        
        //edit ok - always true
        dataDisplaySource.getEditOk = () => {
            return true;
        };
        
        //save data - just form value here
        
        dataDisplaySource.saveData = (formValue) => {
            let layoutFunctionMember = this.getComponent().getField("member.layout");
            let isInputValidFunctionMember = this.getComponent().getField("member.isInputValid");
            //validate input
            var isInputValid = isInputValidFunctionMember.getData();
            let validateResult;
            if(isInputValid instanceof Function) {
                try {
                    validateResult = isInputValid(formValue);
                }
                catch(error) {
                    validateResult = "Error running input validation function.";
                    console.error("Error reading form layout: " + this.getName());
                }
            }
            else {
                validateResult = "Input validate function not valid";
            }

            if(validateResult !== true) {
                if(typeof validateResult != 'string') {
                    validateResult = "Improper format for isInputValid function. It should return true or an error message";
                }
                apogeeUserAlert(validateResult);
                return false;
            }

            //save the data - send via messenger to the variable named "data" in code, which is the field 
            //named "member.data", NOT the field named "data"
            let commandMessenger = new UiCommandMessenger(this,layoutFunctionMember.getId());
            commandMessenger.dataCommand("data",formValue);
            return true;
        };
        
        return dataDisplaySource;
    }

    //======================================
    // Static methods
    //======================================

}


FormDataComponentView.VIEW_FORM = "Form";
FormDataComponentView.VIEW_LAYOUT_CODE = "Layout Code";
FormDataComponentView.VIEW_LAYOUT_SUPPLEMENTAL_CODE = "Layout Private";
FormDataComponentView.VIEW_FORM_VALUE = "Form Value";
FormDataComponentView.VIEW_INPUT_INVALID_CODE = "isInputValid(formValue)";
FormDataComponentView.VIEW_INPUT_INVALID_SUPPLEMENTAL_CODE = "isInputValid Private";

FormDataComponentView.VIEW_MODES = [
    FormDataComponentView.VIEW_FORM,
    FormDataComponentView.VIEW_LAYOUT_CODE,
    FormDataComponentView.VIEW_LAYOUT_SUPPLEMENTAL_CODE,
    FormDataComponentView.VIEW_INPUT_INVALID_CODE,
    FormDataComponentView.VIEW_INPUT_INVALID_SUPPLEMENTAL_CODE,
    FormDataComponentView.VIEW_FORM_VALUE
];

FormDataComponentView.TABLE_EDIT_SETTINGS = {
    "viewModes": FormDataComponentView.VIEW_MODES
};

//======================================
// This is the component generator, to register the component
//======================================


FormDataComponentView.componentName = "apogeeapp.DataFormCell";
FormDataComponentView.hasTabEntry = false;
FormDataComponentView.hasChildEntry = true;
FormDataComponentView.ICON_RES_PATH = "/icons3/formCellIcon.png";

/** This is a custom resource component. 
 * To implement it, the resource script must have the methods "run()" which will
 * be called when the component is updated. It also must have any methods that are
 * confugred with initialization data from the model. */
class CustomComponentView extends ComponentView {

    constructor(appViewInterface,component) {
        super(appViewInterface,component);

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        //add css to page! I think this should go in a separate on create event, but until I 
        //make this, I iwll put this here.
        let css = component.getField("css");
        if((css)&&(css != "")) {
            uiutil.setObjectCssData(component.getId(),css);
        }
        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    };

    /** This component overrides the componentupdated to process the css data, which is managed directly in the view. */
    componentUpdated(component) {
        super.componentUpdated(component);

        //if this is the css field, set it immediately
        if(component.isFieldUpdated("css")) {
            uiutil.setObjectCssData(component.getId(),component.getField("css"));
        }
    }

    //==============================
    // Protected and Private Instance Methods
    //==============================

    /** This component extends the on delete method to get rid of any css data for this component. */
    onDelete() {
        //remove the css data for this component
        uiutil.setObjectCssData(this.component.getId(),"");
        
        super.onDelete();
    }

    /**  This method retrieves the table edit settings for this component instance
     * @protected */
    getTableEditSettings() {
        return CustomComponentView.TABLE_EDIT_SETTINGS;
    }

    /** This method should be implemented to retrieve a data display of the give type. 
     * @protected. */
    getDataDisplay(displayContainer,viewType) {
        
        var dataDisplaySource;
        var app = this.getApp();
        
        //create the new view element;
        switch(viewType) {
            
            case CustomComponentView.VIEW_OUTPUT:
                displayContainer.setDestroyViewOnInactive(this.getComponent().getDestroyOnInactive());
                var dataDisplaySource = this.getOutputDataDisplaySource();
                var dataDisplay = new HtmlJsDataDisplay(displayContainer,dataDisplaySource);
                return dataDisplay;
                
            case CustomComponentView.VIEW_CODE:
                dataDisplaySource = dataDisplayHelper.getMemberFunctionBodyDataSource(app,this,"member");
                return new AceTextEditor(displayContainer,dataDisplaySource,"ace/mode/javascript",AceTextEditor.OPTION_SET_DISPLAY_MAX);
                
            case CustomComponentView.VIEW_SUPPLEMENTAL_CODE:
                dataDisplaySource = dataDisplayHelper.getMemberSupplementalDataSource(app,this,"member");
                return new AceTextEditor(displayContainer,dataDisplaySource,"ace/mode/javascript",AceTextEditor.OPTION_SET_DISPLAY_MAX);
            
            case CustomComponentView.VIEW_HTML:
                dataDisplaySource = this.getUiDataDisplaySource("html");
                return new AceTextEditor(displayContainer,dataDisplaySource,"ace/mode/html",AceTextEditor.OPTION_SET_DISPLAY_MAX);
        
            case CustomComponentView.VIEW_CSS:
                dataDisplaySource = this.getUiDataDisplaySource("css");
                return new AceTextEditor(displayContainer,dataDisplaySource,"ace/mode/css",AceTextEditor.OPTION_SET_DISPLAY_MAX);
                
            case CustomComponentView.VIEW_UI_CODE:
                dataDisplaySource = this.getUiDataDisplaySource("uiCode");
                return new AceTextEditor(displayContainer,dataDisplaySource,"ace/mode/javascript",AceTextEditor.OPTION_SET_DISPLAY_MAX);

            case ComponentView.VIEW_INFO: 
                dataDisplaySource = dataDisplayHelper.getStandardErrorDataSource(app,this);
                return new StandardErrorDisplay(displayContainer,dataDisplaySource);
                
            default:
    //temporary error handling...
                console.error("unrecognized view element: " + viewType);
                return null;
        }
    }

    getOutputDataDisplaySource() {

        return {

            //This method reloads the component and checks if there is a DATA update. UI update is checked later.
            doUpdate: () => {
                //return value is whether or not the data display needs to be udpated
                let reloadData = this.getComponent().isMemberDataUpdated("member");
                let reloadDataDisplay = this.getComponent().areAnyFieldsUpdated(["html","uiCode"]);
                return {reloadData,reloadDataDisplay};
            },

            getData: () => {
                let member = this.getComponent().getMember();
                return dataDisplayHelper.getStandardWrappedMemberData(member);
            },

            //below - custom methods for HtmlJsDataDisplay

            //returns the HTML for the data display
            getHtml: () => {
                return this.getComponent().getField("html");
            },

            //returns the resource for the data display
            getResource: () => {
                return this.getComponent().createResource();
            },

            //gets the mebmer used as a refernce for the UI manager passed to the resource functions 
            getContextMember: () => {
                return this.getComponent().getMember();
            }
        }
    }

    /** This method returns the data dispklay data source for the code field data displays. */
    getUiDataDisplaySource(codeFieldName) {

        return {
            doUpdate: () => {
                //return value is whether or not the data display needs to be udpated
                let reloadData = this.getComponent().isFieldUpdated(codeFieldName);
                let reloadDataDisplay = false;
                return {reloadData,reloadDataDisplay};
            },

            getData: () => {
                let codeField = this.getComponent().getField(codeFieldName);
                if((codeField === undefined)||(codeField === null)) codeField = "";
                return codeField;
            },

            getEditOk: () => {
                return true;
            },
            
            saveData: (text) => {
                let app = this.getApp();
                this.getComponent().doCodeFieldUpdate(app,codeFieldName,text);
                return true;
            }
        }
    }
}

CustomComponentView.VIEW_OUTPUT = "Display";
CustomComponentView.VIEW_CODE = "Input Code";
CustomComponentView.VIEW_SUPPLEMENTAL_CODE = "Input Private";
CustomComponentView.VIEW_HTML = "HTML";
CustomComponentView.VIEW_CSS = "CSS";
CustomComponentView.VIEW_UI_CODE = "uiGenerator()";

CustomComponentView.VIEW_MODES = [
    ComponentView.VIEW_INFO_MODE_ENTRY,
    {
        name: CustomComponentView.VIEW_OUTPUT, 
        label: "Display", 
        isActive: true
    },
    {
        name: CustomComponentView.VIEW_HTML, 
        label: "HTML",
        sourceLayer: "app",
        sourceType: "data",
        isActive: false
    },
    {
        name: CustomComponentView.VIEW_CSS, 
        label: "CSS", 
        sourceLayer: "app",
        sourceType: "data",
        isActive: false
    },
    {
        name: CustomComponentView.VIEW_UI_CODE, 
        label: "UI Generator", 
        sourceLayer: "app",
        sourceType: "function",
        isActive: false
    },
    {
        name: CustomComponentView.VIEW_CODE, 
        label: "Input Code", 
        sourceLayer: "model",
        sourceType: "function",
        isActive: false
    },
    {
        name: CustomComponentView.VIEW_SUPPLEMENTAL_CODE,
        label: "Input Private",
        sourceLayer: "model", 
        sourceType: "private code", 
        isActive: false
    },
];

CustomComponentView.TABLE_EDIT_SETTINGS = {
    "viewModes": CustomComponentView.VIEW_MODES
};

/** This is the format string to create the code body for updateing the member
 * Input indices:
 * 0: resouce methods code
 * 1: uiPrivate
 * @private
 */
CustomComponentView.GENERATOR_FUNCTION_FORMAT_TEXT = [
    "//member functions",
    "var resourceFunction = function(component) {",
    "{0}",
    "}",
    "//end member functions",
    "return resourceFunction;",
    ""
       ].join("\n");
    
    


//======================================
// This is the control generator, to register the control
//======================================

CustomComponentView.componentName = "apogeeapp.CustomCell";
CustomComponentView.hasTabEntry = false;
CustomComponentView.hasChildEntry = true;
CustomComponentView.ICON_RES_PATH = "/icons3/genericCellIcon.png";
CustomComponentView.propertyDialogLines = [
    {
        "type":"checkbox",
        "label":"Destroy on Hide: ",
        "key":"destroyOnInactive"
    }
];

/** This attempt has a single form edit page which returns an object. */
// To add - I should make it so it does not call set data until after it is initialized. I will cache it rather 
//than making the user do that.

/** This is a custom resource component. 
 * To implement it, the resource script must have the methods "run()" which will
 * be called when the component is updated. It also must have any methods that are
 * confugred with initialization data from the model. */
class CustomDataComponentView extends ComponentView {

    constructor(appViewInterface,component) {
        //extend edit component
        super(appViewInterface,component);

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        //add css to page! I think this should go in a separate on create event, but until I 
        //make this, I iwll put this here.
        let css = component.getField("css");
        if((css)&&(css != "")) {
            uiutil.setObjectCssData(component.getId(),css);
        }
        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    };

    /** This component overrides the componentupdated to process the css data, which is managed directly in the view. */
    componentUpdated(component) {
        super.componentUpdated(component);

        //if this is the css field, set it immediately
        if(component.isFieldUpdated("css")) {
            uiutil.setObjectCssData(component.getId(),component.getField("css"));
        }
    }

    //==============================
    // Protected and Private Instance Methods
    //==============================

    /** This component extends the on delete method to get rid of any css data for this component. */
    onDelete() {
        //remove the css data for this component
        uiutil.setObjectCssData(this.component.getId(),"");
        
        super.onDelete();
    }


    /**  This method retrieves the table edit settings for this component instance
     * @protected */
    getTableEditSettings() {
        return CustomDataComponentView.TABLE_EDIT_SETTINGS;
    }

    /** This method should be implemented to retrieve a data display of the give type. 
     * @protected. */
    getDataDisplay(displayContainer,viewType) {
        
        var dataDisplaySource;
        var app = this.getApp();
        
        //create the new view element;
        switch(viewType) {
            
            case CustomDataComponentView.VIEW_OUTPUT:
                displayContainer.setDestroyViewOnInactive(this.getComponent().getDestroyOnInactive());
                var dataDisplaySource = this.getOutputDataDisplaySource();
                var dataDisplay = new HtmlJsDataDisplay(displayContainer,dataDisplaySource);
                return dataDisplay;
                
            case CustomDataComponentView.VIEW_VALUE:
                dataDisplaySource = dataDisplayHelper.getMemberDataTextDataSource(app,this,"member.data");
                return new AceTextEditor(displayContainer,dataDisplaySource,"ace/mode/json",AceTextEditor.OPTION_SET_DISPLAY_SOME);
                
            case CustomDataComponentView.VIEW_CODE:
                dataDisplaySource = dataDisplayHelper.getMemberFunctionBodyDataSource(app,this,"member.input");
                return new AceTextEditor(displayContainer,dataDisplaySource,"ace/mode/javascript",AceTextEditor.OPTION_SET_DISPLAY_MAX);
                
            case CustomDataComponentView.VIEW_SUPPLEMENTAL_CODE:
                dataDisplaySource = dataDisplayHelper.getMemberSupplementalDataSource(app,this,"member.input");
                return new AceTextEditor(displayContainer,dataDisplaySource,"ace/mode/javascript",AceTextEditor.OPTION_SET_DISPLAY_MAX);
            
            case CustomDataComponentView.VIEW_HTML:
                dataDisplaySource = this.getUiDataDisplaySource("html");
                return new AceTextEditor(displayContainer,dataDisplaySource,"ace/mode/html",AceTextEditor.OPTION_SET_DISPLAY_MAX);
        
            case CustomDataComponentView.VIEW_CSS:
                dataDisplaySource = this.getUiDataDisplaySource("css");
                return new AceTextEditor(displayContainer,dataDisplaySource,"ace/mode/css",AceTextEditor.OPTION_SET_DISPLAY_MAX);
                
            case CustomDataComponentView.VIEW_UI_CODE:
                dataDisplaySource = this.getUiDataDisplaySource("uiCode");
                return new AceTextEditor(displayContainer,dataDisplaySource,"ace/mode/javascript",AceTextEditor.OPTION_SET_DISPLAY_MAX);

            case ComponentView.VIEW_INFO: 
                dataDisplaySource = dataDisplayHelper.getStandardErrorDataSource(app,this);
                return new StandardErrorDisplay(displayContainer,dataDisplaySource);
                
            default:
    //temporary error handling...
                console.error("unrecognized view element: " + viewType);
                return null;
        }
    }

    getOutputDataDisplaySource() {
        return {

            //This method reloads the component and checks if there is a DATA update. UI update is checked later.
            doUpdate: () => {
                //return value is whether or not the data display needs to be udpated
                let reloadData = this.getComponent().isMemberDataUpdated("member.data");
                let reloadDataDisplay = this.getComponent().areAnyFieldsUpdated(["html","uiCode","member.input"]);
                return {reloadData,reloadDataDisplay};
            },

            getDisplayData: () => {
                let inputMember = this.getComponent().getField("member.input");
                let {abnormalWrappedData,inputData} = dataDisplayHelper.getProcessedMemberDisplayData(inputMember);
                if(abnormalWrappedData) {
                    return abnormalWrappedData;
                }
                //data is just the member data, return as unwrapped 
                return inputData;
            },

            getData: () => {
                let member = this.getComponent().getField("member.data");
                return dataDisplayHelper.getStandardWrappedMemberData(member);
            },

            //edit ok - always true
            getEditOk: () => {
                return true;
            },

            saveData: (formValue) => {
                //send value to the table whose variable name is "data"
                //the context reference is the member called "input" 
                let inputMember = this.getComponent().getField("member.input");
                let commandMessenger = new UiCommandMessenger(this,inputMember.getId());
                commandMessenger.dataCommand("data",formValue);
                return true;
            },

            //below - custom methods for HtmlJsDataDisplay

            //returns the HTML for the data display
            getHtml: () => {
                return this.getComponent().getField("html");
            },

            //returns the resource for the data display
            getResource: () => {
                return this.getComponent().createResource();
            },

            //gets the mebmer used as a refernce for the UI manager passed to the resource functions 
            getContextMember: () => {
                let inputMember = this.getComponent().getField("member.input");
                return inputMember;
            }
        }
    }

    /** This method returns the data dispklay data source for the code field data displays. */
    getUiDataDisplaySource(codeFieldName) {
 
        return {
            doUpdate: () => {
                //return value is whether or not the data display needs to be udpated
                let reloadData = this.getComponent().isFieldUpdated(codeFieldName);
                let reloadDataDisplay = false;
                return {reloadData,reloadDataDisplay};
            },

            getData: () => {
                let codeField = this.getComponent().getField(codeFieldName);
                if((codeField === undefined)||(codeField === null)) codeField = "";
                return codeField;
            },

            getEditOk: () => {
                return true;
            },
            
            saveData: (text) => {
                let app = this.getApp();
                this.getComponent().doCodeFieldUpdate(app,codeFieldName,text);
                return true;
            }
        }
    }



}



//======================================
// This is the control generator, to register the control
//======================================

CustomDataComponentView.componentName = "apogeeapp.CustomDataCell";
CustomDataComponentView.hasTabEntry = false;
CustomDataComponentView.hasChildEntry = true;
CustomDataComponentView.ICON_RES_PATH = "/icons3/genericCellIcon.png";

CustomDataComponentView.propertyDialogLines = [
    {
        "type":"checkbox",
        "label":"Destroy on Hide: ",
        "key":"destroyOnInactive"
    }
];

CustomDataComponentView.VIEW_OUTPUT = "Form"; //oops! this was a mistake, from copying from form data component
CustomDataComponentView.VIEW_VALUE = "Data Value";
CustomDataComponentView.VIEW_CODE = "Input Code";
CustomDataComponentView.VIEW_SUPPLEMENTAL_CODE = "Input Private";
CustomDataComponentView.VIEW_HTML = "HTML";
CustomDataComponentView.VIEW_CSS = "CSS";
CustomDataComponentView.VIEW_UI_CODE = "uiGenerator(mode)";

CustomDataComponentView.VIEW_MODES = [
    ComponentView.VIEW_INFO_MODE_ENTRY,
    {
        name: CustomDataComponentView.VIEW_OUTPUT,
        label: "Display",
        sourceLayer: "model",
        sourceType: "data",
        suffix: ".data", 
        isActive: true
    },
    {
        name: CustomDataComponentView.VIEW_HTML,
        label: "HTML",
        sourceLayer: "app",
        sourceType: "data", 
        isActive: false
    },
    {
        name: CustomDataComponentView.VIEW_CSS,
        label: "CSS",
        sourceLayer: "app",
        sourceType: "data", 
        isActive: false
    },
    {
        name: CustomDataComponentView.VIEW_UI_CODE,
        label: "UI Generator",
        sourceLayer: "app",
        sourceType: "function",
        isActive: false
    },
    {
        name: CustomDataComponentView.VIEW_CODE,
        label: "Input Code",
        sourceLayer: "model", 
        sourceType: "function",
        suffix: ".input",
        isActive: false
    },
    {
        name: CustomDataComponentView.VIEW_SUPPLEMENTAL_CODE,
        label: "Input Private",
        sourceLayer: "model", 
        sourceType: "private code",
        suffix: ".input",
        isActive: false
    },
    {
        name: CustomDataComponentView.VIEW_VALUE,
        label: "Data Value",
        sourceLayer: "model",
        sourceType: "data",
        suffix: ".data", 
        isActive: false
    }
];

CustomDataComponentView.TABLE_EDIT_SETTINGS = {
    "viewModes": CustomDataComponentView.VIEW_MODES
};

/** This component represents a json table object. */
class ErrorComponentView extends ComponentView {

    constructor(appViewInterface,component) {
        //extend edit component
        super(appViewInterface,component);
    };

    //==============================
    // Protected and Private Instance Methods
    //==============================

    /**  This method retrieves the table edit settings for this component instance
     * @protected */
    getTableEditSettings() {
        return ErrorComponentView.TABLE_EDIT_SETTINGS;
    }

    /** This method should be implemented to retrieve a view mode of the give type. 
     * @protected. */
    getDataDisplay(displayContainer,viewType) {
        return new ErrorDisplay(displayContainer,false);
    }

    //======================================
    // Static methods
    //======================================

}

ErrorComponentView.EMPTY_VIEW = "EMPTY_VIEW";

ErrorComponentView.VIEW_MODES = [
    ErrorComponentView.EMPTY_VIEW
];

ErrorComponentView.TABLE_EDIT_SETTINGS = {
    "viewModes": ErrorComponentView.VIEW_MODES,
    "emptyDataValue": ""
};

//======================================
// This is the component generator, to register the component
//======================================

ErrorComponentView.componentName = "apogeeapp.ErrorCell";
ErrorComponentView.hasTabEntry = false;
ErrorComponentView.hasChildEntry = true;
ErrorComponentView.ICON_RES_PATH = "/icons3/errorCellIcon.png";

/** This is a custom resource component. 
 * To implement it, the resource script must have the methods "run()" which will
 * be called when the component is updated. It also must have any methods that are
 * confugred with initialization data from the model. */
class ActionFormComponentView extends ComponentView {

    constructor(appViewInterface,component) {
        super(appViewInterface,component);
    };

    //==============================
    // Protected and Private Instance Methods
    //==============================

    /**  This method retrieves the table edit settings for this component instance
     * @protected */
    getTableEditSettings() {
        return ActionFormComponentView.TABLE_EDIT_SETTINGS;
    }

    /** This method should be implemented to retrieve a data display of the give type. 
     * @protected. */
    getDataDisplay(displayContainer,viewType) {
        
        var dataDisplaySource;
        var app = this.getApp();
        
        //create the new view element;
        switch(viewType) {
            
            case ActionFormComponentView.VIEW_FORM:
                var dataDisplaySource = this.getOutputDataDisplaySource();
                return new ConfigurableFormEditor(displayContainer,dataDisplaySource);

            case ActionFormComponentView.VIEW_LAYOUT_CODE:
                dataDisplaySource = this.getFormCodeDataDisplaySource(app);
                return new AceTextEditor(displayContainer,dataDisplaySource,"ace/mode/javascript",AceTextEditor.OPTION_SET_DISPLAY_MAX);
                
            case ActionFormComponentView.VIEW_INPUT_CODE:
                dataDisplaySource = dataDisplayHelper.getMemberFunctionBodyDataSource(app,this,"member");
                return new AceTextEditor(displayContainer,dataDisplaySource,"ace/mode/javascript",AceTextEditor.OPTION_SET_DISPLAY_MAX);
                
            case ActionFormComponentView.VIEW_INPUT_SUPPLEMENTAL_CODE:
                dataDisplaySource = dataDisplayHelper.getMemberSupplementalDataSource(app,this,"member");
                return new AceTextEditor(displayContainer,dataDisplaySource,"ace/mode/javascript",AceTextEditor.OPTION_SET_DISPLAY_MAX);

            case ComponentView.VIEW_INFO: 
                dataDisplaySource = dataDisplayHelper.getStandardErrorDataSource(app,this);
                return new StandardErrorDisplay(displayContainer,dataDisplaySource);
                
            default:
    //temporary error handling...
                console.error("unrecognized view element: " + viewType);
                return null;
        }
    }

    getOutputDataDisplaySource() {
        return {

            //This method reloads the component and checks if there is a DATA update. UI update is checked later.
            doUpdate: () => {
                let reloadData = false;
                let reloadDataDisplay = this.getComponent().isFieldUpdated("layoutCode") || this.getComponent().isMemberDataUpdated("member");
                return {reloadData,reloadDataDisplay};
            },

            getDisplayData: () => {       
                let wrappedData = dataDisplayHelper.getEmptyWrappedData();

                //get the layout function
                let component = this.getComponent();
                let {formLayoutFunction,errorMessage} = component.createFormLayoutFunction();
                if(errorMessage) {
                    wrappedData.displayInvalid = true;
                    wrappedData.messageType = DATA_DISPLAY_CONSTANTS.MESSAGE_TYPE_ERROR;
                    wrappedData.message = errorMessage;
                    return wrappedData;
                }

                //load the layout
                //read the input data (checking for non-normal state)
                let member = this.getComponent().getMember();
                let {abnormalWrappedData,inputData} = dataDisplayHelper.getProcessedMemberDisplayData(member);
                if(abnormalWrappedData) {
                    return abnormalWrappedData;
                }

                //use the parent folder as the context base
                let contextMemberId = component.getMember().getParentId();
                let commandMessenger = new UiCommandMessenger(this,contextMemberId);
                try {
                    let layout = formLayoutFunction(commandMessenger,inputData);
                    wrappedData.data = layout;
                    return wrappedData;
                }
                catch(error) {
                    wrappedData.displayInvalid = true;
                    wrappedData.messageType = DATA_DISPLAY_CONSTANTS.MESSAGE_TYPE_ERROR;
                    wrappedData.message = "Error executing layout function: " + error.toString();
                    return wrappedData;
                }
            },

            //no data
            getData: () => null
        }
    }

    getFormCodeDataDisplaySource(app) {
        return {

            //This method reloads the component and checks if there is a DATA update. UI update is checked later.
            doUpdate: () => {
                //return value is whether or not the data display needs to be udpated
                let reloadData = this.getComponent().isFieldUpdated("layoutCode");
                let reloadDataDisplay = false;
                return {reloadData,reloadDataDisplay};
            },

            getData: () => {
                return this.getComponent().getField("layoutCode");
            },

            getEditOk: () => {
                return true;
            },

            saveData: (targetLayoutCode) => {
                let component = this.getComponent();

                var command = {};
                command.type = "actionFormUpdateCommand";
                command.memberId = component.getMemberId();
                command.initialValue = component.getField("layoutCode");
                command.targetValue = targetLayoutCode;

                app.executeCommand(command);
                return true; 
            }

        }
    }
}

ActionFormComponentView.VIEW_FORM = "form";
ActionFormComponentView.VIEW_LAYOUT_CODE = "layout";
ActionFormComponentView.VIEW_INPUT_CODE = "input";
ActionFormComponentView.VIEW_INPUT_SUPPLEMENTAL_CODE = "inputPrivate";

ActionFormComponentView.VIEW_MODES = [
    ComponentView.VIEW_INFO_MODE_ENTRY,
    {
        name: ActionFormComponentView.VIEW_FORM,
        label: "Form",
        isActive: true
    },
    {
        name: ActionFormComponentView.VIEW_LAYOUT_CODE,
        label: "Layout Code",
        sourceLayer: "app",
        sourceType: "function", 
        argList: "commandMessenger,inputData",
        isActive: true
    },
    {
        name: ActionFormComponentView.VIEW_INPUT_CODE,
        label: "Input Data Code",
        sourceLayer: "model",
        sourceType: "function", 
        isActive: false
    },
    {   
        name: ActionFormComponentView.VIEW_INPUT_SUPPLEMENTAL_CODE,
        label: "Input Data Private",
        sourceLayer: "model", 
        sourceType: "private code",
        isActive: false
    }
];

ActionFormComponentView.TABLE_EDIT_SETTINGS = {
    "viewModes": ActionFormComponentView.VIEW_MODES
};


//======================================
// This is the control generator, to register the control
//======================================

ActionFormComponentView.componentName = "apogeeapp.NewActionFormCell";
ActionFormComponentView.hasTabEntry = false;
ActionFormComponentView.hasChildEntry = true;
ActionFormComponentView.ICON_RES_PATH = "/icons3/formCellIcon.png";

/** This is a custom resource component. 
 * To implement it, the resource script must have the methods "run()" which will
 * be called when the component is updated. It also must have any methods that are
 * confugred with initialization data from the model. */
class DataFormComponentView extends ComponentView {

    constructor(appViewInterface,component) {
        super(appViewInterface,component);
    };

    //==============================
    // Protected and Private Instance Methods
    //==============================

    /**  This method retrieves the table edit settings for this component instance
     * @protected */
    getTableEditSettings() {
        return DataFormComponentView.TABLE_EDIT_SETTINGS;
    }

    /** This method should be implemented to retrieve a data display of the give type. 
     * @protected. */
    getDataDisplay(displayContainer,viewType) {
        
        var dataDisplaySource;
        var app = this.getApp();
        
        //create the new view element;
        switch(viewType) {
            
            case DataFormComponentView.VIEW_FORM:
                var dataDisplaySource = this.getOutputDataDisplaySource();
                return new ConfigurableFormEditor(displayContainer,dataDisplaySource);

            case DataFormComponentView.VIEW_LAYOUT_CODE:
                dataDisplaySource = this.getLayoutDataDisplaySource(app);
                return new AceTextEditor(displayContainer,dataDisplaySource,"ace/mode/javascript",AceTextEditor.OPTION_SET_DISPLAY_MAX);
                
            case DataFormComponentView.VIEW_INPUT_CODE:
                dataDisplaySource = dataDisplayHelper.getMemberFunctionBodyDataSource(app,this,"member.input");
                return new AceTextEditor(displayContainer,dataDisplaySource,"ace/mode/javascript",AceTextEditor.OPTION_SET_DISPLAY_MAX);
                
            case DataFormComponentView.VIEW_INPUT_SUPPLEMENTAL_CODE:
                dataDisplaySource = dataDisplayHelper.getMemberSupplementalDataSource(app,this,"member.input");
                return new AceTextEditor(displayContainer,dataDisplaySource,"ace/mode/javascript",AceTextEditor.OPTION_SET_DISPLAY_MAX);

            case DataFormComponentView.VIEW_VALIDATOR_CODE:
                dataDisplaySource = this.getValidatorDataDisplaySource(app);
                return new AceTextEditor(displayContainer,dataDisplaySource,"ace/mode/javascript",AceTextEditor.OPTION_SET_DISPLAY_MAX);

            case DataFormComponentView.VIEW_FORM_VALUE:
                dataDisplaySource = dataDisplayHelper.getMemberDataTextDataSource(app,this,"member.value");
                return new AceTextEditor(displayContainer,dataDisplaySource,"ace/mode/json",AceTextEditor.OPTION_SET_DISPLAY_SOME);

            case ComponentView.VIEW_INFO: 
                dataDisplaySource = dataDisplayHelper.getStandardErrorDataSource(app,this);
                return new StandardErrorDisplay(displayContainer,dataDisplaySource);
                
            default:
    //temporary error handling...
                console.error("unrecognized view element: " + viewType);
                return null;
        }
    }

    getOutputDataDisplaySource() {
        //load this when the form is updated, to be used when form submitted
        //we will update the form if this value changes
        let isDataValidFunction;

        return {
            //NEED TO FACTOR IN INPUT VALUE!!!

            //This method reloads the component and checks if there is a DATA update. UI update is checked later.
            doUpdate: () => {
                //return value is whether or not the data display needs to be udpated
                let component = this.getComponent();
                let reloadData = component.isMemberDataUpdated("member.value");
                let reloadDataDisplay = component.areAnyFieldsUpdated(["layoutCode","validatorCode"]) || component.isMemberFieldUpdated("member.input","data");
                return {reloadData,reloadDataDisplay};
            },

            getDisplayData: () => {       
                let wrappedData = dataDisplayHelper.getEmptyWrappedData();

                //get the layout function
                let component = this.getComponent();
                let {layoutFunction,validatorFunction,errorMessage} = component.createFormFunctions();
                if(errorMessage) {
                    wrappedData.displayInvalid = true;
                    wrappedData.messageType = DATA_DISPLAY_CONSTANTS.MESSAGE_TYPE_ERROR;
                    wrappedData.message = errorMessage;
                    return wrappedData;
                }

                //load the layout
                let inputMember = component.getField("member.input");
                let {abnormalWrappedData,inputData} = dataDisplayHelper.getProcessedMemberDisplayData(inputMember);
                if(abnormalWrappedData) {
                    return abnormalWrappedData;
                }

                //save this for use on submit
                isDataValidFunction = validatorFunction;

                //use the parent folder as the context base
                let contextMemberId = component.getMember().getParentId();
                let commandMessenger = new UiCommandMessenger(this,contextMemberId);
                try {
                    let layout = layoutFunction(commandMessenger,inputData);
                    wrappedData.data = layout;
                    return wrappedData;
                }
                catch(error) {
                    wrappedData.displayInvalid = true;
                    wrappedData.messageType = DATA_DISPLAY_CONSTANTS.MESSAGE_TYPE_ERROR;
                    wrappedData.message = "Error executing layout function: " + error.toString();
                    return wrappedData;
                }
            },

            getData: () => {
                let valueMember = this.getComponent().getField("member.value");
                return dataDisplayHelper.getStandardWrappedMemberData(valueMember,true);
            },

            getEditOk: () => true,

            saveData: (formValue) => {
                let component = this.getComponent();
                //below this data is valid only for normal state input. That should be ok since this is save.
                let inputData = component.getField("member.input").getData();

                try {
                    let isValidResult = isDataValidFunction(formValue,inputData);
                    if(isValidResult === true) {
                        //save data
                        let memberId = component.getMemberId();
                        let commandMessenger = new UiCommandMessenger(this,memberId);
                        commandMessenger.dataCommand("value",formValue);
                        return true;
                    }
                    else {
                        //isValidResult should be the error message. Check to make sure if it is string, 
                        //since the user may return false. (If so, give a generic error message)
                        let msg = ((typeof isValidResult) == "string") ? isValidResult : "Invalid form value!";
                        apogeeUserAlert(msg);
                        return false;
                    }
                }
                catch(error) {
                    if(error.stack) console.error(error.stack);
                    apogeeUserAlert("Error validating input: " + error.toString());
                }
            }
        }
    }

    getLayoutDataDisplaySource(app) {
        return {

            //This method reloads the component and checks if there is a DATA update. UI update is checked later.
            doUpdate: () => {
                //return value is whether or not the data display needs to be udpated
                let reloadData = this.getComponent().isFieldUpdated("layoutCode");
                let reloadDataDisplay = false;
                return {reloadData,reloadDataDisplay};
            },

            getData: () => {
                return this.getComponent().getField("layoutCode");
            },

            getEditOk: () => {
                return true;
            },

            saveData: (targetLayoutCode) => {
                let component = this.getComponent();

                var command = {};
                command.type = "dataFormUpdateCommand";
                command.memberId = component.getMemberId();
                command.field = "layout";
                command.initialValue = component.getField("layoutCode");
                command.targetValue = targetLayoutCode;

                app.executeCommand(command);
                return true; 
            }

        }
    }

    getValidatorDataDisplaySource(app) {
        return {

            //This method reloads the component and checks if there is a DATA update. UI update is checked later.
            doUpdate: () => {
                //return value is whether or not the data display needs to be udpated
                let reloadData = this.getComponent().isFieldUpdated("validatorCode");
                let reloadDataDisplay = false;
                return {reloadData,reloadDataDisplay};
            },

            getData: () => {
                return this.getComponent().getField("validatorCode");
            },

            getEditOk: () => {
                return true;
            },

            saveData: (targetLayoutCode) => {
                let component = this.getComponent();

                var command = {};
                command.type = "dataFormUpdateCommand";
                command.memberId = component.getMemberId();
                command.field = "validator";
                command.initialValue = component.getField("validatorCode");
                command.targetValue = targetLayoutCode;

                app.executeCommand(command);
                return true; 
            }

        }
    }
}

DataFormComponentView.VIEW_FORM = "form";
DataFormComponentView.VIEW_LAYOUT_CODE = "layout";
DataFormComponentView.VIEW_INPUT_CODE = "input";
DataFormComponentView.VIEW_INPUT_SUPPLEMENTAL_CODE = "inputPrivate";
DataFormComponentView.VIEW_VALIDATOR_CODE = "validator";
DataFormComponentView.VIEW_FORM_VALUE = "value";

DataFormComponentView.VIEW_MODES = [
    ComponentView.VIEW_INFO_MODE_ENTRY,
    {
        name: DataFormComponentView.VIEW_FORM,
        label: "Form",
        sourceLayer: "model",
        sourceType: "data",
        suffix: ".value", 
        isActive: true
    },
    {
        name: DataFormComponentView.VIEW_LAYOUT_CODE,
        label: "Layout Code",
        sourceLayer: "app",
        sourceType: "function", 
        argList: "commandMessenger,inputData",
        isActive: true,
        //description: "This is a test of the description!"
    },
    {
        name: DataFormComponentView.VIEW_VALIDATOR_CODE,
        label: "Validator Code",
        sourceLayer: "app",
        sourceType: "function", 
        argList: "formValue,inputData",
        isActive: false
    },
    {
        name: DataFormComponentView.VIEW_INPUT_CODE,
        label: "Input Data Code",
        sourceLayer: "model",
        sourceType: "function", 
        suffix: ".input",
        isActive: false
    },
    {
        name: DataFormComponentView.VIEW_INPUT_SUPPLEMENTAL_CODE,
        label: "Input Data Private",
        sourceLayer: "model", 
        sourceType: "private code",
        suffix: ".input",
        isActive: false
    },
    {
        name: DataFormComponentView.VIEW_FORM_VALUE,
        label: "Value",
        sourceLayer: "model",
        sourceType: "data",
        suffix: ".value", 
        isActive: false
    }
];

DataFormComponentView.TABLE_EDIT_SETTINGS = {
    "viewModes": DataFormComponentView.VIEW_MODES
};

//======================================
// This is the control generator, to register the control
//======================================

DataFormComponentView.componentName = "apogeeapp.NewDataFormCell";
DataFormComponentView.hasTabEntry = false;
DataFormComponentView.hasChildEntry = true;
DataFormComponentView.ICON_RES_PATH = "/icons3/formCellIcon.png";

class JsonPlusTableComponentView extends ComponentView {

    constructor(appViewInterface,JsonPlusTableComponent) {
        super(appViewInterface,JsonPlusTableComponent);
    }

    //==============================
    // Protected and Private Instance Methods
    //==============================

    /**  This method retrieves the table edit settings for this component instance
     * @protected */
    getTableEditSettings() {
        return JsonPlusTableComponentView.TABLE_EDIT_SETTINGS;
    }

    /** This method should be implemented to retrieve a data display of the give type. 
     * @protected. */
    getDataDisplay(displayContainer,viewType) {
        
        var dataDisplaySource;
        var app = this.getApp();
        
        
        //create the new view element;
        switch(viewType) {
            case JsonPlusTableComponentView.VIEW_DATA:
                dataDisplaySource = this.getDataSource();
                return new AceTextEditor(displayContainer,dataDisplaySource,"ace/mode/json",AceTextEditor.OPTION_SET_DISPLAY_SOME);
                
            case JsonPlusTableComponentView.VIEW_CODE:
                dataDisplaySource = dataDisplayHelper.getMemberFunctionBodyDataSource(app,this,"member",DEFAULT_DATA_VALUE$1);
                return new AceTextEditor(displayContainer,dataDisplaySource,"ace/mode/javascript",AceTextEditor.OPTION_SET_DISPLAY_MAX);
                
            case JsonPlusTableComponentView.VIEW_SUPPLEMENTAL_CODE:
                dataDisplaySource = dataDisplayHelper.getMemberSupplementalDataSource(app,this,"member",DEFAULT_DATA_VALUE$1);
                return new AceTextEditor(displayContainer,dataDisplaySource,"ace/mode/javascript",AceTextEditor.OPTION_SET_DISPLAY_MAX);

            case ComponentView.VIEW_INFO: 
                dataDisplaySource = dataDisplayHelper.getStandardErrorDataSource(app,this);
                return new StandardErrorDisplay(displayContainer,dataDisplaySource);
                
            default:
    //temporary error handling...
                console.error("unrecognized view element: " + viewType);
                return null;
        }
    }

    
    /** This data source is read only (no edit). It returns text for a json */
    getDataSource() {

        return {
            doUpdate: () => {
                //return value is whether or not the data display needs to be udpated
                let component = this.getComponent();
                let reloadData = component.isMemberDataUpdated("member");
                let reloadDataDisplay = false;
                return {reloadData,reloadDataDisplay};
            },

            getData: () => {
                let member = this.getComponent().getMember();
                let state = member.getState();
                if(state != apogeeutil.STATE_NORMAL) {
                    //handle non-normal state returning wrapped data
                    let wrappedData = dataDisplayHelper.getEmptyWrappedData();
                    wrappedData.hideDisplay = true;
                    wrappedData.data = apogeeutil.INVALID_VALUE;
                    switch(member.getState()) {
                        case apogeeutil.STATE_ERROR: 
                            wrappedData.messageType = DATA_DISPLAY_CONSTANTS.MESSAGE_TYPE_ERROR;
                            wrappedData.message = "Error in value: " + member.getErrorMsg();
                            break;

                        case apogeeutil.STATE_PENDING:
                            wrappedData.messageType = DATA_DISPLAY_CONSTANTS.MESSAGE_TYPE_INFO;
                            wrappedData.message = "Value pending!";
                            break;

                        case apogeeutil.STATE_INVALID:
                            wrappedData.messageType = DATA_DISPLAY_CONSTANTS.MESSAGE_TYPE_INFO;
                            wrappedData.message = "Value invalid!";
                            break;

                        default:
                            throw new Error("Unknown display data value state!")
                    }
                    return wrappedData;
                }

                let jsonPlus = member.getData();

                var textData;
                if(jsonPlus == apogeeutil.INVALID_VALUE) {
                    //for invalid input, convert to display an empty string
                    textData = "";
                }
                else if(jsonPlus === undefined) {
                    textData = "undefined";
                }
                else {
                    let modifiedValueJson = replaceFunctions(jsonPlus);
                    textData = JSON.stringify(modifiedValueJson,null,FORMAT_STRING);
                }

                return textData;
            }
        }
    }


}


const FORMAT_STRING = "\t";

function replaceFunctions(jsonPlus) {
    var copiedJson;

    var objectType = apogeeutil.getObjectType(jsonPlus);
    
    switch(objectType) {
        case "Object":
            copiedJson = replaceFunctionInObject(jsonPlus);
            break;
            
        case "Array": 
            copiedJson = replaceFunctionsInArray(jsonPlus);
            break;

        case "Function": 
            //copiedJson = FUNCTION_REPLACEMENT_STRING;
            copiedJson = jsonPlus.toString();
            break;
            
        default:
            copiedJson = jsonPlus;
    }
    
    return copiedJson;
}

function replaceFunctionInObject(jsonPlus) {
    var copiedJson = {};
    for(let key in jsonPlus) {
        copiedJson[key] = replaceFunctions(jsonPlus[key]);
    }
    return copiedJson;
}

function replaceFunctionsInArray(jsonPlus) {
    var copiedJson = [];
    for(var i = 0; i < jsonPlus.length; i++) {
        var element = jsonPlus[i];
        copiedJson.push(apogeeutil.getNormalizedCopy(element));
    }
    return copiedJson;
}

/** This is used as the default data value if we clear the code. It really should be a function of the data view,
 * since in grid mode this is an invalid value. Support for that shold be added. */
let DEFAULT_DATA_VALUE$1 = "";

//===============================
// Internal Settings
//===============================

JsonPlusTableComponentView.VIEW_DATA = "Data";
JsonPlusTableComponentView.VIEW_CODE = "Formula";
JsonPlusTableComponentView.VIEW_SUPPLEMENTAL_CODE = "Private";

JsonPlusTableComponentView.VIEW_MODES = [
    ComponentView.VIEW_INFO_MODE_ENTRY,
    {
        name: JsonPlusTableComponentView.VIEW_DATA,
        label: "Data",
        sourceLayer: "model",
        sourceType: "data",
        isActive: true
    },
    {
        name: JsonPlusTableComponentView.VIEW_CODE,
        label: "Formula",
        sourceLayer: "model",
        sourceType: "function",
        isActive: false
    },
    {
        name: JsonPlusTableComponentView.VIEW_SUPPLEMENTAL_CODE,
        label: "Private",
        sourceLayer: "model",
        sourceType: "private code",
        isActive: false
    }
];

JsonPlusTableComponentView.TABLE_EDIT_SETTINGS = {
    "viewModes": JsonPlusTableComponentView.VIEW_MODES,
    "emptyDataValue": ""
};

//===============================
// External Settings
//===============================

/** This is the component name with which this view is associated. */
JsonPlusTableComponentView.componentName = "apogeeapp.ExtendedJsonCell";

/** If true, this indicates the component has a tab entry */
JsonPlusTableComponentView.hasTabEntry = false;
/** If true, this indicates the component has an entry appearing on the parent tab */
JsonPlusTableComponentView.hasChildEntry = true;
/** This is the icon url for the component. */
JsonPlusTableComponentView.ICON_RES_PATH = "/icons3/jsonCellIcon.png";
/** This field gives the default value for the JSON taht should be deserialized to
 * create the member for this object. The field "name" can be omitted. This will 
 * be added when the member is created. */

//registration of the child component views

registerComponentView(JsonTableComponentView);
registerComponentView(FunctionComponentView);
registerComponentView(ErrorComponentView);
registerComponentView(DynamicFormView);
registerComponentView(FormDataComponentView);
registerComponentView(CustomComponentView);
registerComponentView(CustomDataComponentView);

setErrorComponentView(ErrorComponentView);
registerComponentView(ActionFormComponentView);
registerComponentView(DataFormComponentView);
registerComponentView(JsonPlusTableComponentView);

/** This function initializes the resources paths. Thuis covers the following paths
 * - "resources" folder - where the resource images are held
 * - "ace_includes" folder - where ace include files like themes are held
 * The argument includeBasePath can be either a string which is the common base path for the two above fodlers
 * or a object (map) including the folder name as the key and the assoicated base path as the value.
 */
function initIncludePath(includePathInfo) {

    if(!includePathInfo.resources) throw new Error("Resources path must be specified");
    if(!includePathInfo.aceIncludes) throw new Error("Ace includes path must be specified");

    //initialize resource path (relative to base path in web page)
    uiutil.initResourcePath(includePathInfo.resources);

    //any needs mode or theme files for the ace editor should go in the folder set below (relative to base path in web page)
    ace.config.set('basePath',includePathInfo.aceIncludes);
}

var apogeeview = /*#__PURE__*/Object.freeze({
    __proto__: null,
    initIncludePath: initIncludePath,
    ComponentView: ComponentView,
    FormInputBaseComponentView: FormInputBaseComponentView,
    AceTextEditor: AceTextEditor,
    ConfigurableFormEditor: ConfigurableFormEditor,
    DataDisplay: DataDisplay,
    dataDisplayHelper: dataDisplayHelper,
    DATA_DISPLAY_CONSTANTS: DATA_DISPLAY_CONSTANTS,
    ErrorDisplay: ErrorDisplay,
    HandsonGridEditor: HandsonGridEditor,
    HtmlJsDataDisplay: HtmlJsDataDisplay,
    StandardErrorDisplay: StandardErrorDisplay,
    getSaveBar: getSaveBar,
    registerComponentView: registerComponentView,
    getComponentViewClass: getComponentViewClass,
    get ERROR_COMPONENT_VIEW_CLASS () { return ERROR_COMPONENT_VIEW_CLASS; },
    UiCommandMessenger: UiCommandMessenger,
    closeWorkspace: closeWorkspace,
    createWorkspace: createWorkspace,
    openWorkspace: openWorkspace,
    saveWorkspace: saveWorkspace,
    updateWorkspaceProperties: updateWorkspaceProperties,
    addComponent: addComponent,
    addAdditionalComponent: addAdditionalComponent,
    addLink: addLink,
    updateLink: updateLink,
    removeLink: removeLink
});

class ReferenceEntryView {

    constructor(app, referenceEntry,displayInfo) {
        this.app = app;
        this.referenceEntry = referenceEntry;
        this.displayInfo = displayInfo;
        this.treeEntry = this._createTreeEntry();
    }


/** This method loads the link onto the page. It returns a promise that
     * resolves when the link is loaded. */
    getTreeEntry() {
        return this.treeEntry;
    }

    onLinkUpdated(referenceEntry) {
        //make sure this is the right entry 
        if(referenceEntry.getId() != this.referenceEntry.getId()) return;
        
        this.referenceEntry = referenceEntry;
        if(referenceEntry.isFieldUpdated("nickname")) {
            let nickname = this.referenceEntry.getNickname();
            if(!nickname) nickname = "-unnamed entry-";
            this.treeEntry.setLabel(nickname);
        }

        if((referenceEntry.isFieldUpdated("state"))||(referenceEntry.isFieldUpdated("stateMsg"))) {
            this.treeEntry.setBannerState(this.referenceEntry.getState(),this.referenceEntry.getStateMsg());
        }
    }

    //===========================================
    // Private Methods
    //===========================================

    _createTreeEntry() {
        var iconUrl = uiutil.getResourcePath(this.displayInfo.ENTRY_ICON_PATH);
        var label = this.referenceEntry.getNickname();
        var menuItemsCallback = () => this._getMenuItems();

        var treeEntry = new TreeEntry(label, iconUrl, null, menuItemsCallback, false);
        treeEntry.setBannerState(this.referenceEntry.getState(),this.referenceEntry.getStateMsg());
        return treeEntry;
    }

    _getMenuItems() {
        //menu items
        var menuItemList = [];

        //add the standard entries
        var itemInfo = {};
        itemInfo.title = this.displayInfo.UPDATE_ENTRY_TEXT;
        itemInfo.callback = () => updateLink(this.app,this.referenceEntry,this.displayInfo);
        menuItemList.push(itemInfo);

        //add the standard entries
        var itemInfo = {};
        itemInfo.title = this.displayInfo.REMOVE_ENTRY_TEXT;
        itemInfo.callback = () => removeLink(this.app,this.referenceEntry,this.displayInfo);
        menuItemList.push(itemInfo);

        return menuItemList;
    }



}

class ReferenceListView {

    constructor(app,referenceType,displayInfo,viewState) {
        this.app = app;
        this.referenceType = referenceType;
        this.displayInfo = displayInfo;

        this.childViews = {};

        this._setTreeEntry(viewState);
    }

    getDisplayInfo() {
        return this.displayInfo;
    }

    getTreeEntry() {
        return this.treeEntry;
    }

    onLinkCreated(referenceEntry) {
        let referenceEntryView = new ReferenceEntryView(this.app,referenceEntry,this.displayInfo);
        this.childViews[referenceEntry.getId()] = referenceEntryView;
        this.treeEntry.addChild(referenceEntryView.getTreeEntry());
    }

    onLinkUpdated(referenceEntry) {
        let referenceEntryView = this.childViews[referenceEntry.getId()];
        if(referenceEntryView) {
            referenceEntryView.onLinkUpdated(referenceEntry);
        }
    }

    onLinkDeleted(referenceEntry) {
        let referenceEntryView = this.childViews[referenceEntry.getId()];
        if(referenceEntryView) {
            this.treeEntry.removeChild(referenceEntryView.getTreeEntry());
        }
    }

    getViewState() {
        if(this.treeEntry) {
            return {treeState: this.treeEntry.getState()};
        }
    }

    //===============================================
    // Private Methods
    //===============================================

    _setTreeEntry(viewState) {
        var iconUrl = uiutil.getResourcePath(this.displayInfo.LIST_ICON_PATH);
        var menuItemCallback = () => this._getListMenuItems();
        this.treeEntry = new TreeEntry(this.displayInfo.LIST_NAME, iconUrl, null, menuItemCallback, false);

        if((viewState)&&(viewState.treeState !== undefined)) {
            this.treeEntry.setState(viewState.treeState);
        }
    }

    /** @private */
    _getListMenuItems() {
        //menu items
        var menuItemList = [];

        //add the standard entries
        var itemInfo = {};
        itemInfo.title = this.displayInfo.ADD_ENTRY_TEXT;
        itemInfo.callback = () => addLink(this.app,this.displayInfo);
        menuItemList.push(itemInfo);
        
        return menuItemList;
    }
}

class ReferenceView {

    constructor(app, referenceManager) {
        this.app = app;
        this.referenceManager = referenceManager;

        //get the view state
        let viewState = this.referenceManager.getCachedViewState();
        let listViewStates = ((viewState)&&(viewState.lists)) ? viewState.lists : {};

        //create the tree entry
        this.treeEntry = this._createTreeEntry(viewState);

        //initailize the child list views
        this.referenceListViews = {};
        let referenceClassArray = referenceManager.constructor.getReferenceClassArray();
        referenceClassArray.forEach( referenceClass => {
            let entryType = referenceClass.REFERENCE_TYPE;
            let referenceListView = this._createReferenceListView(entryType,listViewStates[entryType]); 
            this.referenceListViews[entryType] = referenceListView;
            let childTreeEntry = referenceListView.getTreeEntry();
            this.treeEntry.addChild(childTreeEntry);
        });

        app.addListener("referenceEntry_created",referenceEntry => this._onLinkCreated(referenceEntry));
        app.addListener("referenceEntry_updated",referenceEntry => this._onLinkUpdated(referenceEntry));
        app.addListener("referenceEntry_deleted",referenceEntry => this._onLinkDeleted(referenceEntry));
        app.addListener("referenceManager_updated",referenceManager => this._onReferenceManagerUpdated(referenceManager));

        this.referenceManager.setViewStateCallback(() => this.getViewState());
    }

    /** This returns the tree entry to display the reference entry for this reference manager. */
    getTreeEntry() {
        return this.treeEntry;
    }

    closeWorkspace() {
        //no action in ui for references
    }

    //-----------------------------------
    // Save methods
    //-----------------------------------
    
    getViewState() {
        let json = {};
        json.treeState = this.treeEntry.getState();
        json.lists = {};
        for(let entryType in this.referenceListViews) {
            let referenceList = this.referenceListViews[entryType];
            json.lists[entryType] = referenceList.getViewState();
        }
        return json;
    }

    //==================================
    // Private Methods
    //==================================

    _onLinkCreated(referenceEntry) {
        try {
            let referenceList = this.referenceListViews[referenceEntry.getEntryType()];
            if(referenceList) {
                referenceList.onLinkCreated(referenceEntry);
            }
        }
        catch(error) {
            if(error.stack) console.error(error.stack);

            apogeeUserAlert("Error updating display for created reference entry: " + error.toString());
        }
    }

    _onLinkUpdated(referenceEntry) {
        try {
            let referenceList = this.referenceListViews[referenceEntry.getEntryType()];
            if(referenceList) {
                referenceList.onLinkUpdated(referenceEntry);
            }
        }
        catch(error) {
            if(error.stack) console.error(error.stack);

            apogeeUserAlert("Error updating display for created reference entry: " + error.toString());
        }
    }

    _onLinkDeleted(referenceEntry) {
        try {
            let referenceList = this.referenceListViews[referenceEntry.getEntryType()];
            referenceList.onLinkDeleted(referenceEntry);
        }
        catch(error) {
            if(error.stack) console.error(error.stack);

            apogeeUserAlert("Error updating display for reference entry: " + error.toString());
        }
    }

    _onReferenceManagerUpdated(referenceManager) {
        try {
            this.referenceManager = referenceManager;
            this.referenceManager.setViewStateCallback(() => this.getViewState());
        }
        catch(error) {
            if(error.stack) console.error(error.stack);

            apogeeUserAlert("Error updating display for deleted reference entry: " + error.toString());
        }
    }

    /** @private */
    _createTreeEntry(viewState) {
        var iconUrl = uiutil.getResourcePath(REFERENCES_ICON_PATH);
        let treeEntry = new TreeEntry("Libraries", iconUrl, null, null, false);

        if((viewState)&&(viewState.treeState !== undefined)) {
            treeEntry.setState(viewState.treeState);
        }

        return treeEntry;
    }

    _createReferenceListView(entryType,viewState) {
        let listDisplayInfo = LIST_DISPLAY_INFO[entryType];
        if(!listDisplayInfo) {
            listDisplayInfo = apogeeutil$1.jsonCopy(DEFAULT_LIST_DISPLAY_INFO);
            //set the proper entry type, and use that for the list name too
            listDisplayInfo.REFERENCE_TYPE = entryType;
            listDisplayInfo.LIST_NAME = entryType;
        }
        return new ReferenceListView(this.app,entryType,listDisplayInfo,viewState);
    }

}



let REFERENCES_ICON_PATH = "/icons3/folderIcon.png";

/** This is the UI definition data for the added reference lists.
 * This should be placed somewhere else to make it easier for people to 
 * add additional reference types.
 */
let LIST_DISPLAY_INFO = {

    "amd module": {
        "REFERENCE_TYPE": "amd module",
        "LIST_NAME": "Web Modules",
        "ADD_ENTRY_TEXT":"Add Web Module",
        "UPDATE_ENTRY_TEXT":"Update Web Module",
        "REMOVE_ENTRY_TEXT":"Remove Web Module",
        "LIST_ICON_PATH":"/icons3/folderIcon.png",
        "ENTRY_ICON_PATH":"/icons3/amdModuleIcon.png"
    },

    "css link": {
        "REFERENCE_TYPE": "css link",
        "LIST_NAME": "CSS Links",
        "ADD_ENTRY_TEXT":"Add CSS Link",
        "UPDATE_ENTRY_TEXT":"Update CSS Link",
        "REMOVE_ENTRY_TEXT":"Remove CSS Link",
        "LIST_ICON_PATH":"/icons3/folderIcon.png",
        "ENTRY_ICON_PATH": "/icons3/cssLinkIcon.png"
    },

    "npm module": {
        "REFERENCE_TYPE": "npm module",
        "LIST_NAME": "NPM Modules",
        "ADD_ENTRY_TEXT":"Add NPM Module",
        "UPDATE_ENTRY_TEXT":"Update NPM Module",
        "REMOVE_ENTRY_TEXT":"Remove NPM Module",
        "LIST_ICON_PATH":"/icons3/folderIcon.png",
        "ENTRY_ICON_PATH":"/icons3/npmModuleIcon.png"
    },

    "es module": {
        "REFERENCE_TYPE": "es module",
        "LIST_NAME": "Web Modules",
        "ADD_ENTRY_TEXT":"Add ES Web Module",
        "UPDATE_ENTRY_TEXT":"Update Web Module",
        "REMOVE_ENTRY_TEXT":"Remove Web Module",
        "LIST_ICON_PATH":"/icons3/folderIcon.png",
        "ENTRY_ICON_PATH":"/icons3/esModuleIcon.png"
    },

    "js link": {
        "REFERENCE_TYPE": "js link",
        "LIST_NAME": "JS Scripts",
        "ADD_ENTRY_TEXT":"Add JS Script Link",
        "UPDATE_ENTRY_TEXT":"Update JS Script Link",
        "REMOVE_ENTRY_TEXT":"Remove JS Script Link",
        "LIST_ICON_PATH":"/icons3/folderIcon.png",
        "ENTRY_ICON_PATH":"/icons3/jsLinkIcon.png"
    }
};

//if this is used, replace the reference type and list name
let DEFAULT_LIST_DISPLAY_INFO = {
    "REFERENCE_TYPE": "PUT THE ENTRY TYPE HERE!",
    "LIST_NAME": "PUT THE ENTRY TYPE HERE!",
    "ADD_ENTRY_TEXT":"Add Link",
    "UPDATE_ENTRY_TEXT":"Update Link",
    "REMOVE_ENTRY_TEXT":"Remove Link",
    "LIST_ICON_PATH":"/icons3/folderIcon.png",
    "ENTRY_ICON_PATH":"/icons3/javascriptLink.png"
};

/** This class manages the user interface for a workspace object. */
class ModelView {

    constructor(workspaceView,modelManager) {

        //yes these
        this.modelManager = modelManager;
        this.workspaceView = workspaceView;

        this.treeEntry = null;

        this.componentViewMap = {};

        this.init();

        //subscribe to events
        let app = this.modelManager.getApp();
        app.addListener("component_created",component => this.onComponentCreated(component));
        app.addListener("component_updated",component => this.onComponentUpdated(component));
        app.addListener("component_deleted",component => this.onComponentDeleted(component));
        app.addListener("modelManager_updated",modelManager => this.onModelManagerUpdated(modelManager));

        this.modelManager.setViewStateCallback(() => this.getViewState());
    }

    getTreeEntry() {
        return this.treeEntry;
    }

    getTabFrame() {
        return this.workspaceView.getTabFrame();
    }

    getComponentViewByComponentId(componentId) {
        return this.componentViewMap[componentId];
    }

    getComponentViewByMemberId(memberId) {
        let componentId = this.modelManager.getComponentIdByMemberId(memberId);
        return this.getComponentViewByComponentId(componentId);
    }

    /** This method indicates that parent component displays are present in the UI. */
    hasParentDisplays() {
        return true;
    }

    getApp() {
        return this.workspaceView.getApp();
    }

    getWorkspaceView() {
        return this.workspaceView;
    }

    getModelManager() {
        return this.modelManager;
    }

    closeWorkspace() {
        for(let viewId in this.componentViewMap) {
            let componentView = this.componentViewMap[viewId];
            componentView.closeWorkspace();
        }
    }

    //================================
    // Event handlers
    //================================


    /** This is called on component created events. We only 
     * want to respond to the root folder event here.
     */
    onComponentCreated(component) {
        try {
            //create the component view
            let componentViewClass = getComponentViewClass(component.constructor.uniqueName);
            let componentView;
            if(componentViewClass) {
                componentView = new componentViewClass(this,component);
            }

            if(!componentView) {
                componentView = new ERROR_COMPONENT_VIEW_CLASS(this,component);
            }

            this.componentViewMap[component.getId()] = componentView;

            //find the parent
            let parentComponent = component.getParentComponent(this.modelManager);
            if(this.hasParentDisplays()) {
                if(parentComponent) {
                    let parentComponentView = this.getComponentViewByComponentId(parentComponent.getId());
                    if(parentComponentView) {
                        parentComponentView.addChild(componentView);
                        componentView.setLastAssignedParentComponentView(parentComponentView);
                    }
                }
                else { 
                    //this is a root component
                    this.addChildToRoot(componentView);
                }
            }

            //do view state initialization
            componentView.loadViewStateFromComponent();
        }
        catch(error) {
            if(error.stack) console.error(error.stack);

            apogeeUserAlert("Error updating display for created component: " + error.toString());
        }
    }

    onComponentUpdated(component) {
        try {
            let componentView = this.getComponentViewByComponentId(component.getId());
            componentView.componentUpdated(component);
        }
        catch(error) {
            if(error.stack) console.error(error.stack);

            apogeeUserAlert("Error updating display for component: " + error.toString());
        }
    }

    onComponentDeleted(component) {
        try {
            let componentId = component.getId();

            let componentView = this.componentViewMap[componentId];
            if(componentView) {
                componentView.onDelete();

                if(this.hasParentDisplays) {
                    //remove from the parent parent
                    let parentComponentView = componentView.getLastAssignedParentComponentView();
                    if(parentComponentView) {
                        parentComponentView.removeChild(componentView);
                    }
                    else {
                        //this is a root component
                        this.removeChildFromRoot(componentView);
                    }
                }
            }

            delete this.componentViewMap[componentId];
        }
        catch(error) {
            if(error.stack) console.error(error.stack);

            apogeeUserAlert("Error updating display for delete component: " + error.toString());
        }
    }

    onModelManagerUpdated(modelManager) {
        try {
            this.modelManager = modelManager;
            let model = this.modelManager.getModel();
            if(model.isFieldUpdated("name")) {
                this.workspaceView.setName(model.getName());
            }
            
            this.modelManager.setViewStateCallback(() => this.getViewState());
        }
        catch(error) {
            if(error.stack) console.error(error.stack);

            apogeeUserAlert("Error updating display for model update: " + error.toString());
        }
    }

    addChildToRoot(componentView) {
        this.treeEntry.addChild(componentView.getTreeEntry());
    }

    removeChildFromRoot(componentView) {
        this.treeEntry.removeChild(componentView.getTreeEntry());
    }

    //====================================
    // properties and display
    //====================================

    getViewState() {
        if(this.treeEntry) {
            return {treeState: this.treeEntry.getState()};
        }
    }

    init() {
        this.treeEntry = this.createTreeEntry();
        this.treeEntry.setState(TreeEntry.EXPANDED);

        let viewState = this.modelManager.getCachedViewState();
        if((viewState)&&(viewState.treeState !== undefined)) {
            this.treeEntry.setState(viewState.treeState);
        }
    }

    createTreeEntry() {

        //menu item callback
        var menuItemCallback = () => {
            //open menu item
            var menuItemList = [];
            var app = this.getApp();
            let initialValues = {parentId: this.getModelManager().getModel().getId()};
            let pageComponents = componentInfo.getPageComponentNames();
            pageComponents.forEach(pageComponentName => {
                let childMenuItem = {};
                let pageComponentClass = componentInfo.getComponentClass(pageComponentName);
                childMenuItem.title = "Add Child " + pageComponentClass.displayName;
                childMenuItem.callback = () => addComponent(this,app,pageComponentClass,initialValues);
                menuItemList.push(childMenuItem);
            });

            return menuItemList;
        };

        var iconUrl = uiutil.getResourcePath(ICON_RES_PATH);
        var isRoot = true;
        return new TreeEntry(MODEL_FOLDER_LABEL, iconUrl, null, menuItemCallback, isRoot);
    }

}

let MODEL_FOLDER_LABEL = "Code";

let ICON_RES_PATH = "/componentIcons/folder.png";

/** This class manages the user interface for a workspace object. */
class WorkspaceView {

    constructor(workspaceManager,appView) {

        //yes these
        this.workspaceManager = workspaceManager;
        this.app = workspaceManager.getApp();
        this.appView = appView;
        this.modelView = null;

        this.treeEntry = null;

        this.init();

        this.app.addListener("workspaceManager_updated",workspaceManager => this.onWorkspaceUpdated(workspaceManager));

        //Thisis used to retieve UI state to save when the app is being saved
        this.workspaceManager.setViewStateCallback(() => this.getViewState());
    }

    getTreeEntry() {
        return this.treeEntry;
    }

    getTabFrame() {
        return this.appView.getTabFrame();
    }

    getModelView() {
        return this.modelView;
    }

    getApp() {
        return this.app;
    }

    getWorkspaceManager() {
        return this.workspaceManager;
    }

    /** This sets the name label on the workspace. The name comes from the model, however, we will display it on the workspace object. */
    setName(name) {
        this.treeEntry.setLabel(name);
    }

    /** This method takes any actions on workspace close. */
    close() {
        if(this.modelView) {
            this.modelView.closeWorkspace();
        }
        if(this.referenceView) {
            this.referenceView.closeWorkspace();
        }
    }

    onWorkspaceUpdated(workspaceManager) {
        try {
            this.workspaceManager = workspaceManager;
            this.workspaceManager.setViewStateCallback(() => this.getViewState());
        }
        catch(error) {
            if(error.stack) console.error(error.stack);

            apogeeUserAlert("Error updating display for workspace update: " + error.toString());
        }
    }

    //====================================
    // properties and display
    //====================================

    /** Thie methor retrieves a serialized UI state, to be used during save. */
    getViewState() {
        if(this.treeEntry) {
            return {treeState: this.treeEntry.getState()};
        }
    }

    init() {
        this.treeEntry = this.createTreeEntry();

        //model manager
        this.modelView = new ModelView(this,this.workspaceManager.getModelManager());
        let modelTreeEntry = this.modelView.getTreeEntry();
        this.treeEntry.addChild(modelTreeEntry);

        //reference mamageger
        this.referenceView = new ReferenceView(this.app,this.workspaceManager.getReferenceManager());
        let refTreeEntry = this.referenceView.getTreeEntry();
        this.treeEntry.addChild(refTreeEntry);

        //set the view state
        let viewState = this.workspaceManager.getCachedViewState();
        if((viewState)&&(viewState.treeState !== undefined)) {
            this.treeEntry.setState(viewState.treeState);
        }
        else {
            this.treeEntry.setState(TreeEntry.EXPANDED);
        }
    }

    createTreeEntry() {
        //generally we expct the workspace not to exist yet. We will update this when it opens.
        let modelManager = this.workspaceManager.getModelManager();
        let model = modelManager.getModel();
        var labelText = model ? model.getName() : Workspace_OPENING_NAME; //add the name
        var iconUrl = uiutil.getResourcePath(WorkspaceView.ICON_RES_PATH);
        var menuItemCallback = () => this.getMenuItems();
        var isRoot = true;
        return new TreeEntry(labelText, iconUrl, null, menuItemCallback,isRoot);
    }

    getMenuItems() {
        //menu items
        var menuItemList = [];

        //add the standard entries
        var itemInfo = {};
        itemInfo.title = "Edit Properties";
        itemInfo.callback = () => updateWorkspaceProperties(this.getWorkspaceManager());
        menuItemList.push(itemInfo);

        //DEV ENTRY
        itemInfo = {};
        itemInfo.title = "Print Dependencies";
        itemInfo.callback = () => this.showDependencies();
        menuItemList.push(itemInfo);

        return menuItemList;
    }


}

let Workspace_OPENING_NAME = "opening...";

WorkspaceView.ICON_RES_PATH = "/icons3/workspaceIcon.png";

class ApogeeView {

    /** This creates the app view, which in turn creates the contained app.
     * - containerId - This is the DOM element ID in which the app view should be created. If this is set
     * to null (or other false value) the UI will not be created.
     * - appConfigManager - This is the app config managerm which defines some needed functionality. 
     */
    constructor(containerId,appConfigManager) {
        this.treePane = null;
        this.tabFrame = null;
        this.workspaceView = null;
        this.containerId = containerId;
        this.app = new Apogee(appConfigManager);
        
        if(containerId) {
            this._loadUI(containerId);
        }

        this._subscribeToAppEvents();
    }

    getTreePane() {
        return this.treePane;
    }

    getTabFrame() {
        return this.tabFrame;
    }

    getApp() {
        return this.app;
    }

    ///** This method should be implemented if custom menus or menu items are desired. */
    //addToMenuBar(menuBar,menus);

    //==============================
    // Private Methods
    //==============================

    //---------------------------------
    // User Interface Creation Methods
    //---------------------------------

    /** This method creates the app ui. 
     * @private */
    _loadUI(containerId) {
        
        var windowElements = uiutil.initWindows(containerId);
        var topContainer = windowElements.baseElement;
        
        var mainContainer = new DisplayAndHeader(DisplayAndHeader.FIXED_PANE,
                null,
                DisplayAndHeader.FIXED_PANE,
                null
            );
        topContainer.appendChild(mainContainer.getOuterElement());
        
        //-------------------
        //create menus
        //-------------------
        var menuBar = this._createMenuBar();
        mainContainer.getHeader().appendChild(menuBar);
        
        //----------------------
        //create the split pane
        //----------------------
        this.splitPane = new SplitPane(
                SplitPane.SCROLLING_PANE,
                SplitPane.FIXED_PANE
            );
        let contentOutsideMenuBar = this.splitPane.getOuterElement();
        //adding this class puts the content at lower z-index than menu bar.
        contentOutsideMenuBar.classList.add("content_outside_menu_bar");
        mainContainer.getBody().appendChild(contentOutsideMenuBar);

        //---------------------
        //load the tree pane
        //---------------------
        this.treePane = this.splitPane.getLeftPaneContainer();

        //tree view
        this.tree = new TreeControl();
        uiutil.removeAllChildren(this.treePane);
        this.treePane.appendChild(this.tree.getElement());
        
        //----------------------
        //create the tab frame
        //----------------------
        this.tabFrame = new TabFrame();
        this.splitPane.getRightPaneContainer().appendChild(this.tabFrame.getElement());
        
        //add listener for displaying the active tab
        this.tabFrame.addListener(uiutil.SHOWN_EVENT,tab => this._onTabShown(tab));
        this.tabFrame.addListener(uiutil.HIDDEN_EVENT,tab => this._onTabHidden(tab));

        //-----------------------
        // Create the width resize listener (for now I am putting it in app - refering to both panes)
        //-----------------------

        this.splitPane.addListener("move",() => this._onSplitPaneResize());
        window.addEventListener("resize",() => this._onWindowResize());

        //-------------------------------
        // disable drag globally
        //---------------------------------

        //disable dragging globally by stapping drag start in window during capture
        let preventAction = (event) => {
            event.preventDefault();
        };
        window.addEventListener("dragstart",preventAction,true);
    }

    //-----------------------------------
    // workspace event handling
    //-----------------------------------

    /** This method subscribes to workspace events to update the UI. It is called out as a separate method
     * because we must reload it each time the app is created. */
    _subscribeToAppEvents() {
        //subscribe to events
        this.app.addListener("workspaceManager_created",workspaceManager => this._onWorkspaceCreated(workspaceManager));
        this.app.addListener("workspaceManager_deleted",workspaceManager => this._onWorkspaceClosed(workspaceManager));
        this.app.addListener("component_updated",component => this._onComponentUpdated(component));
    }

    _onWorkspaceCreated(workspaceManager) {
        if(this.workspaceView != null) {
            //discard an old view if there is one
            this._onWorkspaceClosed();
        }

        //create the new workspace view
        this.workspaceView = new WorkspaceView(workspaceManager,this);

        //load the tree entry, if needed
        if(this.containerId) {
            let treeEntry = this.workspaceView.getTreeEntry();
            this.tree.setRootEntry(treeEntry);
        }
    }

    _onWorkspaceClosed(workspaceManager) {
        //close any old workspace view
        if(this.workspaceView) {
            this.workspaceView.close();
            this.workspaceView = null;
        }

        //clear the tree
        if(this.containerId) {
            this.tree.clearRootEntry();
        }

        //rather than rely on people to clear their own workspace handlers from the app
        //I clear them all here
        //I haven't decided the best way to do this. In the app? Here? I see problems
        //with all of them.
        //for now I clear all here and then resubscribe to events here and in the app, since those
        //objects live on.
        this.app.clearListenersAndHandlers();
        this.app.subscribeToAppEvents();
        this._subscribeToAppEvents();
    }

    /** This is called whenever a component in the model, or the model, changes. If the display name
     * of that component changes, we update the tab display name. This is also not very general. I should
     * clean it up to allow other things besides components to have tabs. I should probably make a tab event that
     * its title changes, or just that it was udpated. */
    _onComponentUpdated(component) {
        //tab id for components is the component id
        if((component.getId() == this.tabFrame.getActiveTab())) {
            //this is pretty messy too... 
            let model = this.app.getModel();
            if((component.isDisplayNameUpdated())||(component.getMember().isFullNameUpdated(model))) {
                let tab = this.tabFrame.getTab(component.getId());
                this._onTabShown(tab);
            }
        }
    }


    //------------------------------
    // Active Tab display name handling logic
    // This is not good. I need to clean a few things up.
    // - the id is the component id. If we geet tabs for other things we will need a more general id
    // - by the same token, we should have a way of getting the display name from the tab itself, as part of the tab interface.
    //------------------------------
    _onTabHidden(tab) {
        this.activeTabIconDisplay.style.display = "none";
        this.activeTabTitleDisplay.style.display = "none";
    }

    _onTabShown(tab) {
        if(!this.workspaceView) return;
        let modelView = this.workspaceView.getModelView();
        if(modelView) {
            var componentId = tab.getId();
            let tabComponentView = modelView.getComponentViewByComponentId(componentId);
            if(tabComponentView) {
                this.activeTabIconDisplay.src = tabComponentView.getIconUrl();
                this.activeTabTitleDisplay.innerHTML = tabComponentView.getDisplayName(true,modelView.getModelManager());
                this.activeTabIconDisplay.style.display = "";
                this.activeTabTitleDisplay.style.display = "";
            }
        }
    }

    //---------------------------------
    // Width resize events - for tab frame and tree frame
    //---------------------------------

    _onSplitPaneResize() {
        this._triggerResizeWait();
    }

    _onWindowResize() {
        this._triggerResizeWait();
    }

    _triggerResizeWait() {
        //only do the slow resizde timer if we have listeners
        if(!this.app.hasListeners("frameWidthResize")) return;

        //create a new timer if we don't already have one
        if(!this.resizeWaitTimer) {
            this.resizeWaitTimer =  setTimeout(() => this._resizeTimerExpired(),RESIZE_TIMER_PERIOD_MS);
        }
    }

    _resizeTimerExpired() {
        this.resizeWaitTimer = null;
        this.app.dispatchEvent("frameWidthResize",null);
    }

    //=================================
    // Menu Functions
    //=================================

    /** This method creates the creates the menu bar, with the attached functionality. 
     * @private */
    _createMenuBar() {
        var name;
        var menus = {};
        
        //creat menu  bar with left elements (menus) and right elements (active tab display)
        var menuBar = uiutil.createElementWithClass("div","menu_bar");
        var menuBarLeft = uiutil.createElementWithClass("div","menu_bar_left",menuBar);
        var menuBarRight = uiutil.createElementWithClass("div","menu_bar_right",menuBar);

        //apogee icon
        let apogeeIcon = document.createElement("img");
        apogeeIcon.src = uiutil.getResourcePath("/shortlogo16.png");
        apogeeIcon.className = "menu_bar_icon";
        menuBarLeft.appendChild(apogeeIcon);
        // apogeeIcon.onclick = () => {
        //     this.minimizeContent();
        // }

        //Workspace menu
        name = "File";
        this.workspaceMenu = Menu.createMenu(name);
        //add custom spacing
        let workspaceMenuElement = this.workspaceMenu.getElement();
        workspaceMenuElement.style.marginLeft = "8px";
        workspaceMenuElement.style.marginRight = "2px";
        workspaceMenuElement.style.marginTop = "2px";
        workspaceMenuElement.style.marginBottom = "2px";
        menuBarLeft.appendChild(workspaceMenuElement);
        menus[name] = this.workspaceMenu;
        
        //populate the workspace menu on the fly - depends on workspace state
        var getWorkspaceMenuCallback = () => this._getWorkspaceMenuItems();
        this.workspaceMenu.setAsOnTheFlyMenu(getWorkspaceMenuCallback);
        
        //Edit menu
        name = "Edit";
        this.editMenu = Menu.createMenu(name);
        //add custom spacing
        let editMenuElement = this.editMenu.getElement();
        editMenuElement.style.marginLeft = "8px";
        editMenuElement.style.marginRight = "2px";
        editMenuElement.style.marginTop = "2px";
        editMenuElement.style.marginBottom = "2px";
        menuBarLeft.appendChild(editMenuElement);
        menus[name] = this.editMenu;
        
        //populate the workspace menu on the fly - depends on workspace state
        var getEditMenuCallback = () => this._getEditMenuItems();
        this.editMenu.setAsOnTheFlyMenu(getEditMenuCallback);

        //Edit menu
        name = "Help";
        this.helpMenu = Menu.createMenu(name);
        //add custom spacing
        let helpMenuElement = this.helpMenu.getElement();
        helpMenuElement.style.marginLeft = "8px";
        helpMenuElement.style.marginRight = "2px";
        helpMenuElement.style.marginTop = "2px";
        helpMenuElement.style.marginBottom = "2px";
        menuBarLeft.appendChild(helpMenuElement);
        menus[name] = this.helpMenu;
        
        //populate the workspace menu on the fly - depends on workspace state
        var getHelpMenuCallback = () => this._getHelpMenuItems();
        this.helpMenu.setAsOnTheFlyMenu(getHelpMenuCallback);
        
        //allow the implementation to add more menus or menu items
        if(this.addToMenuBar) {
            this.addToMenuBar(menuBar,menus);
        }
        
        //add the active tab display
        this.activeTabIconDisplay = uiutil.createElementWithClass("img","tab-icon-display",menuBarRight);
        this.activeTabIconDisplay.style.display = "none";
        this.activeTabTitleDisplay = uiutil.createElementWithClass("div","tab-title-display",menuBarRight);
        this.activeTabTitleDisplay.style.display = "none";
        return menuBar;
        
    }

    /** This method gets the workspace menu items. This is created on the fly because the
     * items will change depending on the state of the workspace. */
    _getWorkspaceMenuItems() {
        
        let menuItems = [];
        let menuItem;

        let fileAccessObject = this.app.getFileAccessObject();
        
        menuItem = {};
        menuItem.title = "New";
        menuItem.callback = () => createWorkspace(this.app);
        menuItems.push(menuItem);
        
        menuItem = {};
        menuItem.title = "Open";
        menuItem.callback = () => openWorkspace(this.app,fileAccessObject);
        menuItems.push(menuItem);

        let workspaceManager = this.app.getWorkspaceManager();
        if(workspaceManager) {
            var fileMetadata = workspaceManager.getFileMetadata();

            if(fileAccessObject.directSaveOk(fileMetadata)) {
                menuItem = {};
                menuItem.title = "Save";
                menuItem.callback = () => saveWorkspace(this.app,fileAccessObject,true);
                menuItems.push(menuItem);
            }

            menuItem = {};
            menuItem.title = "Save as";
            menuItem.callback = () => saveWorkspace(this.app,fileAccessObject,false);
            menuItems.push(menuItem);
        }  

        menuItem = {};
        menuItem.title = "Close";
        menuItem.callback = () => closeWorkspace(this.app);
        menuItems.push(menuItem);
        
        return menuItems;
    }

    /** This method gets the workspace menu items. This is created on the fly because the
     * items will change depending on the state of the workspace. */
    _getEditMenuItems() {
        
        var menuItems = [];
        var menuItem;

        let commandManager = this.app.getCommandManager();
        let commandHistory = commandManager.getCommandHistory();
        
        //populate the undo menu item
        var undoLabel;
        var undoCallback;
        var nextUndoDesc = commandHistory.getNextUndoDesc();
        if(nextUndoDesc === null) {
            undoLabel = "-no undo-";
            undoCallback = null;
        }
        else {
            if(nextUndoDesc == "") {
                undoLabel = "Undo";
            }
            else {
                undoLabel = "Undo: " + nextUndoDesc;
            }
            undoCallback = () => commandHistory.undo();
        }
        menuItem = {};
        menuItem.title = undoLabel;
        menuItem.callback = undoCallback;
        menuItems.push(menuItem);
        
        //populate the redo menu item
        var redoLabel;
        var redoCallback;
        var nextRedoDesc = commandHistory.getNextRedoDesc();
        if(nextRedoDesc === null) {
            redoLabel = "-no redo-";
            redoCallback = null;
        }
        else {
            if(nextRedoDesc == "") {
                redoLabel = "Redo";
            }
            else {
                redoLabel = "Redo: " + nextRedoDesc;
            }
            redoCallback = () => commandHistory.redo();
        }
        menuItem = {};
        menuItem.title = redoLabel;
        menuItem.callback = redoCallback;
        menuItems.push(menuItem);
        
        return menuItems;
    }

    _getHelpMenuItems() {
        var menuItems = [];
        var menuItem;

        //help entry
        menuItem = {};
        menuItem.title = "Apogee Help";
        menuItem.callback = helpCallback;
        menuItems.push(menuItem);
        
        //about entry
        menuItem = {};
        menuItem.title = "About";
        menuItem.callback = aboutCallback;
        menuItems.push(menuItem);
        
        return menuItems;
    }
    
    //========================================
    // Static Functions
    //========================================

    // /** This method is used to register a new component view class for the user interface. */
    // static registerComponentView(viewClass) {
    //     componentClassMap[viewClass.componentName] = viewClass;
    // }

    // /** This method retrieves a component view class using the component unique name. */
    // static getComponentViewClass(componentName) {
    //     return componentClassMap[componentName];
    // }

}


//let componentClassMap = {};

const RESIZE_TIMER_PERIOD_MS = 500;

function helpCallback() {
    let title = "Apogee Help";
    let message;
    //if we are in a browser, allow the user to open the link. Otherwise just print it.
    if(__browser__) {
        message = 'For help, please go to the website: <a href="https://www.apogeejs.com" target="_blank">https://www.apogeejs.com</a>';
    }
    else {
        message = 'For help, please go to the website: <b>https://www.apogeejs.com</b>';
    }
    showSimpleActionDialog(title,message,["OK"]);
}

function aboutCallback() {
    let title = "Apogee Programming Environment";
    let message = "Version: " + __apogee_version__;
    showSimpleActionDialog(title,message,["OK"]);
}

/**
 * Toolbar Plugin
 * - Allows toolbar items, such as buttons.
 * - Each item can have an optional "update" function. This will be called when the selection changes and allows
 * for corresponding changes to the button appearance or function. It is passed "selectionInfo". See below.
 * - Each item can have an optional "getMarkSelectionGenerator" function. This is generates an entry for the selection
 * info for a given mark. (Block selection info is handled automatically.) See below for format.
 * - Each item must have a "registerEditorView" function. This will be called to pass the editor view to the button, so it can
 * act on the view.
 * - Each item must have a "getElement" call, to retrive the DOM element for the item.
 * 
 * SelectionInfo is an object with two entries, "blocks" and "marks". The entry in blocks is automatically generated. The entry
 * for marks is generated by a function from the item itself. The item provides this from the "getMarkSelectionGenerator".
 * 
 * (FOR NOW - see code for examples of how these work)
*/

class ApogeeToolbar {
  constructor(items) {
    this.items = items;
    
    this.dom = document.createElement("div");
    this.dom.className = "atb_toolbar";

    this.markSelectionGenerators = {};

    this.items.forEach(item => this._addToolbarItem(item));
    
  }

  setEditorView(editorView) {
    this.editorView = editorView;

    this.items.forEach(item => {
      item.registerEditorView(editorView);
    });
    this.update();
  }

  getElement() {
    return this.dom;
  }


  update() {
    var selectionInfo = this._getSelectionInfo();
    this.items.forEach(item => {
      item.update(selectionInfo);
    });
  }

  destroy() {
    //this.dom.remove()
  }

  _addToolbarItem(toolbarItem) {

    //this allows mark items to create custom information for themselves in a simple and efficient way
    //blocks are handled in standard way
    if(toolbarItem.getMarkSelectionGenerator) {
      this._registerMarkSelectionGenerator(toolbarItem.getMarkSelectionGenerator());
    }

    this.dom.appendChild(toolbarItem.getElement());
  }

  /** This function allows each mark to create information on selection to decide the item
   * status, such as if the press should turn the mark on or off */
  _registerMarkSelectionGenerator(selectionGenerator) {
    if(selectionGenerator.name) {
      this.markSelectionGenerators[selectionGenerator.name] = selectionGenerator;
    }
  }

  /** This function creates information on each selection event to update the status of the buttons */
  _getSelectionInfo() {

    let { $from, $to } = this.editorView.state.selection;
    let doc = this.editorView.state.doc;
    let schema = this.editorView.state.schema;

    //----------------------------
    //get block info
    //create a list of blocks present
    //-----------------------------
    let blockInfo = {};
    let startBlockIndex = $from.index(0);
    let endBlockIndex = $to.index(0);

    let blockMap = {};
    blockInfo.blockTypes = [];
    for(let index = startBlockIndex; index <= endBlockIndex; index++) {
      let childNode = doc.maybeChild(index);
      if((childNode)&&(!blockMap[childNode.type.name])) {
        blockMap[childNode.type.name] = true;
        blockInfo.blockTypes.push(childNode.type);
      }
    }

    //-------------------
    //get mark info
    //toolbar buttons register a function to create their own mark info entry
    //-------------------
    //initialize mark info
    let markInfo = {};
    for(let markName in this.markSelectionGenerators) {
      let initEntryFunction = this.markSelectionGenerators[markName].getEmptyInfo;
      markInfo[markName] = initEntryFunction ? initEntryFunction() : {};
    }

    //process marks for text nodes.
    let textNodeNumber = 0;
    let setMarkInfo = node => {
      if(node.isText) {
        node.marks.forEach( mark => {
          let markInfoUpdater = this.markSelectionGenerators[mark.type.name].updateInfo;
          if(markInfoUpdater) {
            let markInfoEntry = markInfo[mark.type.name];
            markInfoUpdater(mark,markInfoEntry,textNodeNumber);
          }
        });
        textNodeNumber++;
      }
    };

    doc.nodesBetween($from.pos,$to.pos,setMarkInfo);

    //call final update, if needed
    for(let markName in this.markSelectionGenerators) {
      let onCompleteFunction = this.markSelectionGenerators[markName].onComplete;
      let markInfoEntry = markInfo[markName];
      if(onCompleteFunction) onCompleteFunction(markInfoEntry,textNodeNumber);
    }
    
    //return selection info
    let selectionInfo = {};
    selectionInfo.blocks = blockInfo;
    selectionInfo.marks = markInfo;
    return selectionInfo;
  }

}

//PROBLEMS

//--------------------------------------------------------
// Commands
//--------------------------------------------------------

// :: (EditorState, ?(tr: Transaction))  bool
// If we are in a top level list, this will convert the line to a paragraph type block
function exitEmptyList(state, dispatch) {
    let { $head } = state.selection;
    let schema = state.schema;
    //make sure this is an empty list item in the root of a list
    if (($head.parent.type != schema.nodes.listItem) || ($head.depth != 2) || ($head.parent.content.size != 0)) return false;

    //set this block type to default
    return setBlockType(schema.nodes.paragraph, state, dispatch);
}

// :: (EditorState, ?(tr: Transaction))  bool
// If we are in a top level list at the start of the line, this will convert the line to a paragraph type block
function exitFromStartOfList(state, dispatch) {
    let { $head, empty } = state.selection;
    let schema = state.schema;
    if((empty)&&($head.parent.type == schema.nodes.listItem)&&($head.parentOffset == 0)) {
        return setBlockType(schema.nodes.paragraph, state, dispatch);
    }
    else {
        return false;
    }
 }

 // :: (EditorState, ?(tr: Transaction))  bool
// If we are at the end of a top level list and the next block is a text block, this pulls
// that text block into the list.
function joinNextBlockToListFromEnd(state,dispatch) {
    let { empty, $head } = state.selection;
    let schema = state.schema;
    if((empty) && //empty selection
            ($head.parent.type == schema.nodes.listItem) && //in a list item
            ($head.parentOffset == $head.parent.content.size) && //at end of list item
            ($head.index($head.depth-1)+1 == $head.node($head.depth-1).childCount) //last list item
        ) { 
        //WE ARE ASSUMING ONLY SINGLE LEVEL LISTS HERE!!!
        let nextNodeStartPos = $head.after($head.depth-1);
        let nextNode = state.doc.resolve(nextNodeStartPos).nodeAfter;
        //only pull next node in if it is a text block
        if((nextNode)&&(nextNode.isTextblock)) {
            let $insideNextNode = state.doc.resolve(nextNodeStartPos+1);
            //get the selection up to the inside of the next node
            let newSelection = new prosemirrorState_es_js.TextSelection($head,$insideNextNode);
            let tr = state.tr.setSelection(newSelection).deleteSelection();
            if(dispatch) {
                dispatch(tr.scrollIntoView());
            }
        }
        
        //if we get here the command is not valid
        return true;
    }
}

 // :: (EditorState, ?(tr: Transaction))  bool
// If we are at the end of a top level list and the next block is a text block, this pulls
// that text block into the list.
function joinNextBlockFromListFromEnd(state,dispatch) {
    let { empty, $head } = state.selection;
    if((empty) && //empty selection
            ($head.parent.isTextblock) && //in a text block
            ($head.depth == 1) && //at the top level
            ($head.parentOffset == $head.parent.content.size) //at end
        ) { 
        let nextNodeStartPos = $head.after($head.depth);
        let nextNode = state.doc.resolve(nextNodeStartPos).nodeAfter;
        //only pull next node in if it is in a list
        if((nextNode)&&(nextNode.type.spec.group == "list")) {
            //WE ARE ASSUMING ONLY SINGLE LEVEL LISTS HERE!!!
            let $insideNextListItemNode = state.doc.resolve(nextNodeStartPos+2);
            //get the selection up to the inside of the next node
            let newSelection = new prosemirrorState_es_js.TextSelection($head,$insideNextListItemNode);
            let tr = state.tr.setSelection(newSelection).deleteSelection();
            if(dispatch) {
                dispatch(tr.scrollIntoView());
            }
        }
        
        //if we get here the command is not valid
        return true;
    }
}

function setMark(markType, attrs, state, dispatch) {
    let { empty, $cursor, ranges } = state.selection;
    if ((empty && !$cursor) || !markApplies(state.doc, ranges, markType)) return false
    if (dispatch) {
        if ($cursor) {
            dispatch(state.tr.addStoredMark(markType.create(attrs)));
        }
        else {
            let tr = state.tr;
            for (let i = 0; i < ranges.length; i++) {
                let { $from, $to } = ranges[i];
                tr.addMark($from.pos, $to.pos, markType.create(attrs));
            }
            dispatch(tr.scrollIntoView());
        }
    }
    return true
}


function clearMark(markType, state, dispatch) {
    let { empty, $cursor, ranges } = state.selection;
    if ((empty && !$cursor) || !markApplies(state.doc, ranges, markType)) return false
    if (dispatch) {
        if ($cursor) {
            dispatch(state.tr.removeStoredMark(markType));
        }
        else {
            let tr = state.tr;
            for (let i = 0; i < ranges.length; i++) {
                let { $from, $to } = ranges[i];
                tr.removeMark($from.pos, $to.pos, markType);
            }
            dispatch(tr.scrollIntoView());
        }
    }
    return true
}

function markApplies(doc, ranges, type) {
    for (let i = 0; i < ranges.length; i++) {
        let { $from, $to } = ranges[i];
        let can = $from.depth == 0 ? doc.type.allowsMarkType(type) : false;
        doc.nodesBetween($from.pos, $to.pos, node => {
            if (can) return false
            can = node.inlineContent && node.type.allowsMarkType(type);
        });
        if (can) return true
    }
    return false
}


//--
//to non-list block type commands
//--

/** This function converts a selection to a new non-list block type. */
function setBlockType(nodeType, state, dispatch) {

    //this will be our transform
    let transform = state.tr;    
    let schema = state.schema;
    let selection = state.selection;

    //node type setup
    let targetTextBlockType = (nodeType.spec.group == "list") ? schema.nodes.listItem : nodeType;
    let listTypeIfApplicable;
    if(nodeType.spec.group == "list") {
        listTypeIfApplicable = nodeType;
        targetTextBlockType = schema.nodes.listItem;
    }
    else {
        listTypeIfApplicable = null;
        targetTextBlockType = nodeType;
    }

    //------------------------------
    //if there are start and end lists, split them from the selection to update
    //------------------------------
    transform = splitStartAndEndLists(transform,selection);

    //------------------------------
    // Wrap selected nodes in a worker block - this lets us hold basre list items
    //------------------------------
    transform = wrapSelectionInWorkerParent(transform,selection,schema);

    //------------------------------
    // Lift out any lists in the worker block
    //------------------------------
    transform = liftFromAnyListsInWorkerParent(transform,schema);

    //------------------------------
    // Convert all blocks to desired type, except ignore apogee blocks
    //------------------------------
    transform = convertWorkerParentChildren(transform,targetTextBlockType,schema);

    //------------------------------
    // Get rid of worker block
    //------------------------------
    transform = removeWorkerBlock(transform,listTypeIfApplicable,schema);

    //------------------------------
    // Join any lists at start and end if applicable
    //------------------------------
    if(listTypeIfApplicable) {
        transform = joinNeighboringLists(transform);
    }
    
    //------------------------------
    // execute the transform
    //------------------------------

    if ((dispatch) && (transform.docChanged)) {
        dispatch(transform);
    }

    return true;
}

//===============================
// Support Functions
//===============================

/** Split any lists so there is not a list that spans outside the current selection */
function splitStartAndEndLists(transform,selection,schema) {
    //this is our range to convert
    let { $from, $to } = selection;
    transform = splitSpannedListAfterPos($to, transform);
    transform = splitSpannedListBeforePos($from, transform);
    return transform;
}


/** This function wraps the given selection in one or more worker parent nodes, with any apogee
 * component nodes excluded.
 */
function wrapSelectionInWorkerParent(transform,selection,schema) {

    let refDoc = transform.doc;
    let refStep = transform.steps.length;

    //this is our range to convert
    let { $from, $to } = selection;

    //update if we have done any transform
    if (transform.docChanged) {
        let newFrom = transform.mapping.map($from.pos);
        let newTo = transform.mapping.map($to.pos);
        $from = refDoc.resolve(newFrom);
        $to = refDoc.resolve(newTo);
    }

    //get start and end index in top level
    let firstIndex = $from.index(0);
    let lastIndex = $to.index(0);

    let startPosition;
    let endPosition;
    let inFutureList = false;
    let insertDepth = 0;
    refDoc.forEach( (node,offset,index) => {
        if((index >= firstIndex)&&(index <= lastIndex)) {

            if(node.type === schema.nodes.apogeeComponent) {
                if(inFutureList) {
                    inFutureList = false;
                    endPosition = offset;
                    //wrap in a worker parent
                    insertDepth = 0;
                    wrapSelectionInNode(startPosition,endPosition,insertDepth,schema.nodes.workerParent,transform,refStep);
                }
            }
            else {
                if(!inFutureList) {
                    inFutureList = true;
                    //set the start position
                    startPosition = offset;
                }
                //update the end position
                endPosition = offset + node.nodeSize;
            }
    
        }
    });

    //create the final list/worker segment
    if(inFutureList) {
        wrapSelectionInNode(startPosition,endPosition,insertDepth,schema.nodes.workerParent,transform,refStep);
    }

    return transform;
}

/** This function lifts the child blocks from an list blocks included in the worker parent block(s). */
function liftFromAnyListsInWorkerParent(transform,schema) {
    let doc = transform.doc;
    let refStep = transform.steps.length;

    doc.forEach( (childNode,offset,index) => {
        //process worker parents in the doc
        if(childNode.type == schema.nodes.workerParent) {
            let childPosition = offset;
            childNode.forEach( (grandchildNode,childOffset,childIndex) => {
                //unwrap any list node
                if(grandchildNode.type.spec.group == "list") {
                    let grandchildPosition = childPosition + 1 + childOffset;
                    unwrapChildren(grandchildNode,grandchildPosition,transform,refStep);
                }
            });
        }
    });

    return transform;
}

/** This function changes any child block node in the worker parent node(s) to the target text
 * block type. */
function convertWorkerParentChildren(transform,targetTextBlockType,schema) {
    let doc = transform.doc;
    let refStep = transform.steps.length;

    doc.forEach( (childNode,offset,index) => {
        //work on children or the worker parent
        if(childNode.type == schema.nodes.workerParent) {
            let childPosition = offset;
            //change block type to target type
            childNode.forEach( (grandchildNode,childOffset,childIndex) => {
                let grandchildPosition = childPosition + 1 + childOffset;
                convertBlockType(targetTextBlockType,null,grandchildNode,grandchildPosition,transform,refStep);
            });
        }
    });

    return transform;
}

/** This function removes and worker blocks in the document. If the worker block should be
 * a list, it is converted to that list type. Otherwise the child blocks are just lifted out. */
function removeWorkerBlock(transform,listTypeIfApplicable,schema) {
    //FIX THIS
    //convert worker children to target link and remove worker 
    //get the updated doc
    let doc = transform.doc;
    let refStep = transform.steps.length;

    doc.forEach( (childNode,offset,index) => {
        if(childNode.type == schema.nodes.workerParent) {
            let childPosition = offset;

            if(listTypeIfApplicable) {
                //if this should be a list, convert worker parent to list
                convertBlockType(listTypeIfApplicable,null,childNode,childPosition,transform,refStep);
            }
            else {
                //otherwise lift out of worker block
                unwrapChildren(childNode,childPosition,transform,refStep);
            }
        }
    });

    return transform;
}

/** This goes through the document and joins any lists that are next to each other. */
function joinNeighboringLists(transform) {
    /* ADD THIS LATER */
    return transform;
}


/** This function cuts the document so there is not a list spanned before the text block at the given position. */
function splitSpannedListAfterPos($pos, transform, schema) {

    let modPath = pathToModPath($pos.path);

    //traverse backwards to look for the deepest entry that cuts a list (last element is doc, we can ignore it)
    for (let i = modPath.length - 1; i > 0; i--) {
        let entry = modPath[i];
        if ((entry.node.type.spec.group == "list") && (entry.index < entry.node.childCount - 1)) {
            //split here!
            //cut at the end of the child block
            let childBlockDepth = i + 1;
            let cutDepth = i;
            let cutPosition = $pos.end(childBlockDepth) + 1;
            transform = transform.split(cutPosition, cutDepth);
            break;
        }
    }

    return transform;
}

/** This function cuts the document so there is not a list spanned after the text block at the given position. */
function splitSpannedListBeforePos($pos, transform, schema) {
    let modPath = pathToModPath($pos.path);

    //traverse backwards to look for the deepest entry that cuts list (last element is doc, we can ignore it)
    for (let i = modPath.length - 1; i > 0; i--) {
        let entry = modPath[i];
        if ((entry.node.type.spec.group == "list") && (entry.index > 0)) {
            //split here!
            //cut at start of the child block
            let childBlockDepth = i + 1;
            let cutDepth = i;
            let cutPosition = $pos.start(childBlockDepth) - 1;
            transform = transform.split(cutPosition, cutDepth); //cut position off by 1 when at the start of a child list, but need to cut is parent
            break;
        }
    }

    return transform;
}


//depth is set to 0
function wrapSelectionInNode(baseFrom, baseTo, parentDepth, nodeType, transform, refStep) {
    let mapping = transform.mapping.slice(refStep);
    let from = mapping.map(baseFrom, 1);
    let to = mapping.map(baseTo, -1);
    let $from = transform.doc.resolve(from);
    let $to = transform.doc.resolve(to);
    let range = new prosemirrorModel_es_js.NodeRange($from, $to, parentDepth);
    let wrapping = range && prosemirrorTransform_es_js.findWrapping(range, nodeType);
    if (!wrapping) throw new Error("Wrapping not found!"); //need to work out error handling
    //return the updated transform
    return transform.wrap(range, wrapping);
}

/** This lifts children of the given node out of that node. */
function unwrapChildren(node,nodeRefStart,transform,refStep) {
    //get the mapping to remap the node position
    let mapping = transform.mapping.slice(refStep);
    let start = mapping.map(nodeRefStart, 1);
    let end = mapping.map(nodeRefStart + node.nodeSize, 1);

    //return transform.step(new ReplaceStep(start, end, new Slice(node.content, 0, 0), false))

    return transform.step(new prosemirrorTransform_es_js.ReplaceAroundStep(start, end, start + 1, end - 1,
        new prosemirrorModel_es_js.Slice(prosemirrorModel_es_js.Fragment.empty, 0, 0), 0, false))
}

/** This method converts the given block into the targetnode type. */
function convertBlockType(targetNodeType,attrs,node,nodeRefStart,transform,refStep) {
    //get the mapping to remap the node position
    let mapping = transform.mapping.slice(refStep);
    let start = mapping.map(nodeRefStart, 1);
    let end = mapping.map(nodeRefStart + node.nodeSize, 1);
    return transform.step(new prosemirrorTransform_es_js.ReplaceAroundStep(start, end, start + 1, end - 1,
            new prosemirrorModel_es_js.Slice(prosemirrorModel_es_js.Fragment.from(targetNodeType.create(attrs, null, node.marks)), 0, 0), 1, true))
}

/** This load the path data into an alternat struct */
//helper
function pathToModPath(path) {
    let modPath = [];
    for (let i = 0; i < path.length - 2; i += 3) {
        let entry = {};
        entry.node = path[i];
        entry.index = path[i + 1];
        entry.startPos = path[i + 2];
        modPath.push(entry);
    }
    return modPath;
}

//===================================================================
/** Special work around
 * Using the standard document logic, if an apogee node is the first node (and it is not the only node) then
 * when a user presses enter the new paragraph will be created _above_ the node. I don't want this.
 *This logic will detect that single case and put the new paragraph after. */
function insertParagraphAfterFirstApogeeNode(state,dispatch) {
    let {$from, $to} = state.selection;
    let schema = state.schema;
    //only run this if we are at the start of the doc
    if($from.pos !== 0) return;

    //see if the selection is a single apogee node (we can probably use a general function for this)
    //THIS MIGHT NEED TO BE UPDATED, for now you can only select a single apogee node
    let apogeeNodeCount = 0;
    let nonApogeeNodeCount = 0;
    let checkNodes = (node, pos, parent, index) => {
        (node.type == schema.nodes.apogeeComponent) ? apogeeNodeCount++ : nonApogeeNodeCount++;
        return false;
    };
    state.doc.nodesBetween($from.pos,$to.pos,checkNodes);

    if((apogeeNodeCount !== 1)&&(nonApogeeNodeCount !== 0)) return;

    //create a paragraph after the node
    if (dispatch) {        let typeToCreate = schema.nodes.paragraph;
        let pos = $to.pos;
        let tr = state.tr.insert(pos, typeToCreate.createAndFill());
        tr.setSelection(prosemirrorState_es_js.TextSelection.create(tr.doc, pos + 1));
        dispatch(tr.scrollIntoView());
    }
    return true
}

let enter = prosemirrorCommands_es_js.chainCommands(exitEmptyList, insertParagraphAfterFirstApogeeNode, prosemirrorCommands_es_js.createParagraphNear, prosemirrorCommands_es_js.splitBlock);
let backspace = prosemirrorCommands_es_js.chainCommands(exitEmptyList,prosemirrorCommands_es_js.deleteSelection, prosemirrorCommands_es_js.joinBackward, exitFromStartOfList);
let del = prosemirrorCommands_es_js.chainCommands(prosemirrorCommands_es_js.deleteSelection, prosemirrorCommands_es_js.joinForward, joinNextBlockToListFromEnd, joinNextBlockFromListFromEnd);

// :: Object
// A keymap for the apogee schema
let pcBaseKeymap = {
  "Enter": enter,
  //"Mod-Enter": exitCode,
  "Backspace": backspace,
  "Mod-Backspace": backspace,
  "Delete": del,
  "Mod-Delete": del,
  "Mod-a": prosemirrorCommands_es_js.selectAll
};

// :: Object
// A copy of `pcBaseKeymap` that also binds **Ctrl-h** like Backspace,
// **Ctrl-d** like Delete, **Alt-Backspace** like Ctrl-Backspace, and
// **Ctrl-Alt-Backspace**, **Alt-Delete**, and **Alt-d** like
// Ctrl-Delete.
let macBaseKeymap = {
  "Ctrl-h": pcBaseKeymap["Backspace"],
  "Alt-Backspace": pcBaseKeymap["Mod-Backspace"],
  "Ctrl-d": pcBaseKeymap["Delete"],
  "Ctrl-Alt-Backspace": pcBaseKeymap["Mod-Delete"],
  "Alt-Delete": pcBaseKeymap["Mod-Delete"],
  "Alt-d": pcBaseKeymap["Mod-Delete"]
};
for (let key in pcBaseKeymap) macBaseKeymap[key] = pcBaseKeymap[key];

// :: Object
// Depending on the detected platform, this will hold
// [`pcBasekeymap`](#commands.pcBaseKeymap) or
// [`macBaseKeymap`](#commands.macBaseKeymap).
let baseKeymap = __OS_IS_MAC__ ? macBaseKeymap : pcBaseKeymap;

/** This is a toolbar button for marks. It is inteded for marks with either no attrbiutes or with 
 * fixed attributes. Arguments:
 * - markType - this is the schema mark type object.
 * - attr - these are the attributes for the marks. It should be fixed of empty.
 * - labelText - This is the text that appears on the label. 
 * - textStyleClass - This is the CSS class name for the text. Note that the background and text color are controlled
 * by the button to show enabled,disabled and highlighted.
 * - toolTip - This is the tooltip text for the button.
 */
class MarkToggleItem {
    constructor(markType, attr, labelText, styleClass, tooltip) {
        this.markType = markType;
        this.attr = attr;
        this.labelText = labelText;
        this.styleClass = styleClass;

        this.selectionGenerator = createSelectionGenerator(markType);

        this.element = document.createElement("span");
        this.element.title = tooltip;
        this.element.textContent = labelText;

        this.element.onclick = () => {
            this.editorView.focus();
            if (this.elementIsSelected) {
                clearMark(this.markType, this.editorView.state, this.editorView.dispatch);
            }
            else {
                setMark(this.markType, this.attr, this.editorView.state, this.editorView.dispatch);
            }
        };

        this._setElementIsSelected(false);
    }

    registerEditorView(editorView) {
        this.editorView = editorView;
    }

    getElement() {
        return this.element;
    }

    getMarkSelectionGenerator() {
        return this.selectionGenerator;
    }

    /** This gets the selection info and sets whether the toggle should be on or off. 
     * Mark is considered "on" if it is present on all text nodes in the selection.
    */
    update(selectionInfo) {
        let markInfo = selectionInfo.marks[this.markType.name];
        let isSelected = (markInfo)&&(markInfo.present === true)&&(markInfo.missing === false);
        this._setElementIsSelected(isSelected);
    }

    //=========================
    // internal
    //=========================

    /** This sets the toggle state and the display class. */
    _setElementIsSelected(isSelected) {
        if (this.elementIsSelected != isSelected) {
            this.elementIsSelected = isSelected;
            if (isSelected) {
                this.element.className = "atb_toggleButton atb_toggleOnClass " + this.styleClass;
            }
            else {
                this.element.className = "atb_toggleButton atb_toggleOffClass " + this.styleClass;
            }
        }
    }

}

function createSelectionGenerator(markType) {
    let selectionGenerator = {};
    selectionGenerator.name = markType.name;
    selectionGenerator.getEmptyInfo = () => { return { last: -1, missing: false}; };
    selectionGenerator.updateInfo = (mark,markInfoEntry,textNodeNumber) => {
        //record if there are any text nodes with this mark missing
        if(textNodeNumber - markInfoEntry.last > 1) {
            markInfoEntry.missing = true;
        }
        markInfoEntry.last = textNodeNumber;

        //record that this mark is present
        markInfoEntry.present = true;
    };
    selectionGenerator.onComplete = (markInfoEntry,nodeCount) => {
        if(nodeCount - markInfoEntry.last > 1) {
            markInfoEntry.missing = true;
        }
    };

    return selectionGenerator;
}

/** This is a toolbar element for marks which have a single attribute key and multple attribute values. Arguments:
 * - markType - this is the schema mark type object.
 * - attrName - this is the name or the single attribute for the marks. 
 * - attrValueList - This is a list of values for the attribute. Each value should have a two element array, the first 
 * being the display label and the second beint the internal value represented.
 * - defaultValue - This is the value for the list which corresponds to no mark present. For example in the font
 * case, this should be the font that is showing when no mark is present.
 */
//This is a menu element for a mark with multiple attribute values, for a single attribute name
//the default value should be the selection option for no mark present.
class MarkDropdownItem {
    constructor(markType, attrName, attrValueList, defaultValue, tooltip) {
        this.markType = markType;
        this.attrValueList = attrValueList;
        this.defaultValue = defaultValue;

        this.selectionGenerator = createSelectionGenerator$1(markType, attrName);

        this.element = document.createElement("select");
        this.element.title = tooltip;
        attrValueList.forEach(attrValueEntry => {
            let option = document.createElement("option");
            option.value = attrValueEntry[1];
            option.text = attrValueEntry[0];
            this.element.add(option);
        });

        this.element.value = this.defaultValue;

        this.element.onchange = () => {
            this.editorView.focus();
            //allow string or boolean value (I think it turns to string even if boolean is set)
            if(this.element.value == defaultValue) {
                //remove mark
                clearMark(this.markType, this.editorView.state, this.editorView.dispatch);
            }
            else {
                //set the mark with the current value
                var attr = {};
                attr[attrName] = this.element.value;
                setMark(this.markType, attr, this.editorView.state, this.editorView.dispatch);
            }
        };
    }

    registerEditorView(editorView) {
        this.editorView = editorView;
    }

    getElement() {
        return this.element;
    }

    getMarkSelectionGenerator() {
        return this.selectionGenerator;
    }

    /** This gets the selection info and sets whether the toggle should be on or off. */
    update(selectionInfo) {
        let markInfo = selectionInfo.marks[this.markType.name];

        if((markInfo.values.length === 1)&&(!markInfo.missing)) {
            //mark present on all text nodes - display this as the current value
            this._setElementValue(markInfo.values[0]);
        }
        else if(markInfo.values.length === 0) {
            //mark not present. This is the default.
            this._setElementValue(this.defaultValue);
        }
        else {
            //multiple values present - display no current value
            this._setElementValue(null);
        }

        return;
    }

    
    //=========================
    // internal
    //=========================

    
    /** This sets the toggle state and the display class. */
    _setElementValue(value) {
        if (this.element.value !== value) {
            this.element.value = value;
        }
    }

}

function createSelectionGenerator$1(markType,attrName) {
    let selectionGenerator = {};
    selectionGenerator.name = markType.name;
    selectionGenerator.getEmptyInfo = () => { return { last: -1, missing: false, values: [] }; };
    selectionGenerator.updateInfo = (mark,markInfoEntry,textNodeNumber) => {
        //record if there are any text nodes with this mark missing
        if(textNodeNumber - markInfoEntry.last > 1) {
            markInfoEntry.missing = true;
        }
        markInfoEntry.last = textNodeNumber;

        //recorc that this mark is present
        let attrValue = mark.attrs[attrName];
        if(markInfoEntry.values.indexOf(attrValue) < 0) markInfoEntry.values.push(attrValue);
    };
    selectionGenerator.onComplete = (markInfoEntry,nodeCount) => {
        if(nodeCount - markInfoEntry.last > 1) {
            markInfoEntry.missing = true;
        }
    };

    return selectionGenerator;
}

/** This is a toolbar item button. Arguments:
 * - commandFunction - this is the action taken when the button is pressed when enabled.
 * - isHighlightedFunction - This function is called with selectionInfo on selection change to determine if the 
 * button should be in the highlighted state. This does not change the action. If the function is not provided
 * the button is never highlighted.
 * - isEnabled - This function is called with the selectionInfo on selection change to determine if the
 * button shoudl be enabled. The button only acts when enabled. If this function is not provided, the button is
 * always enabled.
 * - labelText - This is the text that appears on the label. 
 * - textStyleClass - This is the CSS class name for the text. Note that the background and text color are controlled
 * by the button to show enabled,disabled and highlighted.
 * - toolTip - This is the tooltip text for the button.
 */
class ActionButton {
    constructor(commandFunction, isHighlightedFunction, isEnabledFunction, labelText, textStyleClass, tooltip) {
        this.commandFunction = commandFunction;
        this.labelText = labelText;
        this.textStyleClass = textStyleClass;

        this.element = document.createElement("span");
        this.element.title = tooltip;
        this.element.textContent = labelText;

        this.element.onclick = () => {
            this.editorView.focus();
            if(this.isEnabled) {
                this.commandFunction(this.editorView.state, this.editorView.dispatch);
            }
        };

        this.isHighlightedFunction = isHighlightedFunction;
        this.isEnabledFunction = isEnabledFunction;

        this.isEnabled;
        this._setState(true,false);
    }

    registerEditorView(editorView) {
        this.editorView = editorView;
    }

    getElement() {
        return this.element;
    }

    /** This gets the selection info and sets whether the toggle should be on or off. */
    update(selectionInfo) {

        //call function to decide if button is enabled if function defined. Otherwise just keep it on. 
        var isHighlighted = this.isHighlightedFunction ? this.isHighlightedFunction(selectionInfo) : false;
        var isEnabled = this.isEnabledFunction ? this.isEnabledFunction(selectionInfo) : true;

        this._setState(isEnabled,isHighlighted);
    }

    //=========================
    // internal
    //=========================

    /** This sets the toggle state and the display class. */
    _setState(isEnabled,isHighlighted) {
        let className = "atb_actionButton " + this.textStyleClass;

        if (isEnabled) {
            if (isHighlighted) {
                className += " atb_actionHighlightedClass";
            }
            else {
                className += " atb_actionEnabledClass";
            }
        }
        else {
            className += " atb_actionDisabledClass";
        }

        if(className != this.element.classname) {
            this.element.className = className;
        }

        this.isEnabled = isEnabled;
        
    }

}

//============================
// StateCheck plugin
//============================

//This is a test to measure the state of the editor. I want to use this to 
//configure my menu bar (as to what is active)
class StateCheck {
    constructor(editorView) {
      this.editorView = editorView;
    }
  
    update() {
      this._showSelectionInfo();
    }
  
  
    _showSelectionInfo() {
  
      var { empty, $cursor, ranges } = this.editorView.state.selection;
      var doc = this.editorView.state.doc;
      /////////////////////////////////////////////
      //temp printout to examine selection
      console.log("================");
      if(empty) console.log(empty);
      if($cursor) {
        this._printResolvedPosition("$cursor",$cursor);
      }
      else {
        this._printResolvedPosition("$from",ranges[0].$from);
        this._printResolvedPosition("$to",ranges[0].$to);
      }
      console.log("================");
      return;
    }

    _getNodePathString(path) {
      let simplifiedPath = path.map( element => {
        if(typeof element == "object") {
          return element.type.name;
        }
        else {
          return element;
        }
      });

      return JSON.stringify(simplifiedPath);
    }

    _printResolvedPosition(name,$pos) {
      console.log(name);
      console.log("pos: " + $pos.pos);
      console.log("parentDepth: " + $pos.depth);
      console.log("parentType: " + $pos.parent.type.name);
      console.log("parentOffset: " + $pos.parentOffset);
    }
  }

const dummyFunction = () => true;

const PASSTHROUGH_KEYMAP = {
    "Enter": dummyFunction,
    "Delete": dummyFunction,
    "Mod-a": dummyFunction,
    "ArrowLeft": dummyFunction,
    "ArrowRight": dummyFunction,
    "ArrowUp": dummyFunction,
    "ArrowDown": dummyFunction,
    "Shift-ArrowLeft": dummyFunction,
    "Shift-ArrowRight": dummyFunction,
    "Shift-ArrowUp": dummyFunction,
    "Shift-ArrowDown": dummyFunction,
    "Mod-z": dummyFunction,
    "Mod-y": dummyFunction,
    "Mod-c": dummyFunction,
    "Mod-x": dummyFunction,
    "Mod-v": dummyFunction,
};

//key handler args: state, dispatch, view

let inverseKeydownHandler = prosemirrorKeymap_es_js.keydownHandler(PASSTHROUGH_KEYMAP);

function interactiveNodeKeydownHandler(view,event) {

    if((view.state.selection instanceof prosemirrorState_es_js.NodeSelection)&&(view.state.selection.node.type.spec.hasInteractiveSelection)) {
        //interactive node selected
        let passThrough = inverseKeydownHandler(view,event);

        if(passThrough) return false;
        else {
            //pass these events along
            console.log("Event captured for selecte interactive node: " + event.key);

            return true;
        }
    }
    else {
        //interactive node is not selected
        return false;
    }
}


/** This creates a plugin to filter out keydown events and to forward when
/* thee is an interactive node selected. */ 
const getInteractiveNodePlugin = function() {
    return new prosemirrorState_es_js.Plugin({
        props: {
            handleKeyDown: interactiveNodeKeydownHandler
        }
    })
};

function isLeafBlock(node) {
    if(!node) return false;
    return node.isBlock && (node.isAtom || node.isLeaf);
}

// ::- Gap cursor selections are represented using this class. Its
// `$anchor` and `$head` properties both point at the cursor position.
class GapSelection extends prosemirrorState_es_js.Selection {
    // : (ResolvedPos)
    constructor($anchor, $head = $anchor) {
        super($anchor, $head);
        this.anchorIsGap = GapSelection.isGapLocation($anchor);
        this.headIsGap = ($anchor.pos !== $head.pos) ? GapSelection.isGapLocation($head) : false;
    }

    get $cursor() { return this.$anchor.pos == this.$head.pos ? this.$head : null }

    map(doc, mapping) {
        let $head = doc.resolve(mapping.map(this.head));
        let $anchor = doc.resolve(mapping.map(this.anchor));
        //one end must be a gap
        if((GapSelection.isGapLocation($head))||(GapSelection.isGapLocation($head))) {
            return new GapSelection($anchor, $head)
        }
        else {
            //(standard default when selection not valid)
            return prosemirrorState_es_js.Selection.near($head);
        }
    }

    get visible() {
        return (this.$anchor.pos !== this.$head.pos);
    }

    replace(tr, content = prosemirrorModel_es_js.Slice.empty) {
        super.replace(tr, content);
        if (content == prosemirrorModel_es_js.Slice.empty) {
            let marks = this.$from.marksAcross(this.$to);
            if (marks) tr.ensureMarks(marks);
        }
    }

    eq(other) {
        return ((other instanceof GapSelection)&&(other.head == this.head)&&(other.anchor == this.anchor))
    }

    toJSON() {
        return {type: "gapselection", anchor: this.anchor, head: this.head}
    }

    static fromJSON(doc, json) {
        if (typeof json.anchor != "number" || typeof json.head != "number")
            throw new RangeError("Invalid input for GapSelection.fromJSON")
        return new GapSelection(doc.resolve(json.anchor), doc.resolve(json.head))
    }

    getBookmark() { return new GapSelectionBookmark(this.anchor, this.head) }

    /** This method is a gap location is the node before is or after it is a leaf block. 
     * We are currently making the assumption that the leaf blocks are only placed at the root level. */
    static isGapLocation($pos) {
        return ($pos.depth === 0) && ( (isLeafBlock($pos.nodeBefore))||(isLeafBlock($pos.nodeAfter)) );
    }

    static findFrom($pos, dir, mustMove) {
        search: for (;;) {
            if (!mustMove && GapSelection.isGapLocation($pos)) return $pos
            let pos = $pos.pos, next = null;
            // Scan up from this position
            for (let d = $pos.depth;; d--) {
                let parent = $pos.node(d);
                if (dir > 0 ? $pos.indexAfter(d) < parent.childCount : $pos.index(d) > 0) {
                    next = parent.child(dir > 0 ? $pos.indexAfter(d) : $pos.index(d) - 1);
                    break
                } else if (d == 0) {
                    return null
                }
                pos += dir;
                let $cur = $pos.doc.resolve(pos);
                if (GapSelection.isGapLocation($cur)) return $cur
            }

            // And then down into the next node
            for (;;) {
                let inside = dir > 0 ? next.firstChild : next.lastChild;
                if (!inside) {
                    if (next.isAtom && !next.isText && !prosemirrorState_es_js.NodeSelection.isSelectable(next)) {
                        $pos = $pos.doc.resolve(pos + next.nodeSize * dir);
                        mustMove = false;
                        continue search
                    }
                    break
                }
                next = inside;
                pos += dir;
                let $cur = $pos.doc.resolve(pos);
                if (GapSelection.isGapLocation($cur)) return $cur
            }

            return null
        }
    }
}

prosemirrorState_es_js.Selection.jsonID("gapselection", GapSelection);

class GapSelectionBookmark {
    constructor(anchor, head) {
        this.anchor = anchor;
        this.head = head;
    }
    map(mapping) {
        return new GapSelectionBookmark(mapping.map(this.anchor), mapping.map(this.head))
    }
    resolve(doc) {
        let $anchor = doc.resolve(this.anchor);
        let $head = doc.resolve(this.head);
        if((GapSelection.isGapLocation($anchor))||(GapSelection.isGapLocation($head))) {
            return GapSelection.between($anchor, $head)
        }
        else {
            return prosemirrorState_es_js.Selection.near($head)
        }
    }
}

// :: ()  Plugin
// Create a gap cursor plugin. When enabled, this will capture clicks
// near and arrow-key-motion past places that don't have a normally
// selectable position nearby, and create a gap cursor selection for
// them. The cursor is drawn as an element with class
// `ProseMirror-gapcursor`. You can either include
// `style/gapcursor.css` from the package's directory or add your own
// styles to make it visible.
const apogeeSelectionPlugin = function() {
    return new prosemirrorState_es_js.Plugin({
        props: {
            decorations: drawGapCursor,

            createSelectionBetween(_view, $anchor, $head) {
                if((GapSelection.isGapLocation($anchor))||(GapSelection.isGapLocation($head))) return new GapSelection($anchor, $head)
            },

            handleClick,
            handleKeyDown: handleKeyDown$1
        }
    })
};

const handleKeyDown$1 = prosemirrorKeymap_es_js.keydownHandler({
    "ArrowLeft": arrow$1("horiz", -1, false),
    "ArrowRight": arrow$1("horiz", 1, false),
    "ArrowUp": arrow$1("vert", -1, false),
    "ArrowDown": arrow$1("vert", 1, false),
    "Shift-ArrowLeft": arrow$1("horiz", -1, true),
    "Shift-ArrowRight": arrow$1("horiz", 1, true),
    "Shift-ArrowUp": arrow$1("vert", -1, true),
    "Shift-ArrowDown": arrow$1("vert", 1, true)
});

//code

////////////////////////////////////////////////////////////
// DOH! in code below, I use thehead for the moving part of the selection
// if there is a non-empty selection and a non-shift arrow, the
// end that moves depends on the arrow direction


function arrow$1(axis, dir, shiftPressed) {
    return function(state, dispatch, view) {
        let selection = state.selection;
        let {$head, $anchor} = selection;

        if(selection instanceof prosemirrorState_es_js.NodeSelection) {
            //case 1: node selection
            if(isLeafBlock(selection.node)) {
                return _createGapSelectionNearNode($anchor,$head,axis,dir,shiftPressed,state,dispatch);
            }
            else {
                //just give up if we are not in a leaf block
                return false;
            }
        }
        else {
            //other cases need the moving side of the selection
            //get the moving side of the selection
            let $movingPos, $otherPos;
            if(shiftPressed) {
                //when shift, head always moves 
                $movingPos = $head;
                $otherPos = $anchor;
            }
            else {
                //without shift, the end in direction of motion moves
                $movingPos = (dir > 0) ? $head.max($anchor) : $head.min($anchor);
                $otherPos = ($movingPos === $head) ? $anchor : $head;
            }

            if(GapSelection.isGapLocation($movingPos)) {
                //create new selection leaving a gap position
                return _createSelectionMovingFromGap($movingPos,$otherPos,axis,dir,shiftPressed,state,dispatch)
            }
            else if ($movingPos.parent.isTextblock) {
                //create new selection leavnig a text position
                return _createSelectionMovingFromText($movingPos,$otherPos,axis,dir,shiftPressed,state,dispatch,view)
            }
        }
        //nto handled
        return false;
    }
}

/** This handle mouse clicks to make selections. Text and Node selections use default handling.
 * Here we make Gap Selections if needed. A Gap Selection is used if the cursor is at a gap location
 * or at least one end of a non-empty selection is at a gap location
 */
function handleClick(view, pos, event) {
    if (!view.editable) return false
    let $pos = view.state.doc.resolve(pos);

    //to be a gap selection one side must be a gap location
    let headWillBeGap = GapSelection.isGapLocation($pos);
    let tailWillBeGap;
    if(event.shiftKey) {
        tailWillBeGap = (view.state.selection instanceof GapSelection)&&(view.state.selection.this.anchorIsGap);  
    }
    else {
        tailWillBeGap = headWillBeGap;
    }
    if(! ((headWillBeGap)||(tailWillBeGap)) ) return false;
    
    //create the gap position 
    let $newHead = $pos;
    let $newAnchor;
    if(event.shiftKey) {
        $newAnchor = view.state.selection.$anchor;
    }
    else {
        $newAnchor = $newHead;
    }
    view.dispatch(view.state.tr.setSelection(new GapSelection($newAnchor,$newHead)));
    return true
}

function drawGapCursor(state) {
    if (!(state.selection instanceof GapSelection)) return null
    let widgets = [];
    if(state.selection.headIsGap) widgets.push(_createWidget(state.selection.head));
    if(state.selection.anchorIsGap) widgets.push(_createWidget(state.selection.anchor));
    return prosemirrorView_es_js.DecorationSet.create(state.doc,widgets)
}

function _createWidget(pos) {
    let node = document.createElement("div");
    node.className = "ProseMirror-gapcursor";
    return prosemirrorView_es_js.Decoration.widget(pos, node, {key: "gapselectioncursor"})
}

//=================================
// Internal Functions
//=================================

/** This method creates a GapSelection around the node, with the head in
 * the direction of travel (+1 or -1). 
 * Returns true if the operation either succeeds or would succeed (if dispatch 
 * were present) */
function _createGapSelectionNearNode($anchor,$head,axis,dir,shiftPressed,state,dispatch) {
    //execute if dispatch present
    if (dispatch) {
        let $newHead, $newAnchor;
        //get the new head - in the direction of travel from anchor
        //we won't assume the order of the current head and anchor
        if( ($head.pos > $anchor.pos) === (dir > 0) ) {
            $newHead = $head;
            $newAnchor = shiftPressed ? $anchor : $head;
        }
        else {
            $newHead = $anchor;
            $newAnchor = shiftPressed ? $head : $anchor;
        }
        dispatch(state.tr.setSelection(new GapSelection($newAnchor,$newHead)).scrollIntoView());
    }
    return true;
}

/** This sets a new selection updating the previous selection for motion in the given direction
 * from the moving side of the selection.
 * This handles a vertical and horizontal arrow the same, currently not caching position information into
 * the next line for the case of vertical arrow. */
function _createSelectionMovingFromGap($movingPos,$otherPos,axis,dir,shiftPressed,state,dispatch) {
    //the head is in a gap. navigate in the direction of travel until we reacn an inline node
    let doc = $movingPos.parent;
    let pos;
    let $newHead, $newAnchor;
    let headType, anchorType;

    if(dir > 0) dir = 1;
    else if(dir < 0) dir = -1;

    //////////////////////////////////////////////////////////////
    //do the following code differently?
    //- get $head.nodeBefore or $head.nodeAfter
    //- check the type
    //-- list (or other container) - cycle through its children from start/end to find fist text block
    //-- text block - get position at start/end fro type text position
    //-- leaf block - get position before/after for type gap position
    ////////////////////
    // new alg
    // - start at current position
    // - go one unit in specified direction
    // - get parent node type:
    // -- none - check position type
    // --- this is a gap position - create gap selection here
    // --- this is not a gap - put cursor inside next text node
    // -- text - create a text selection here
    //////////////////////////////////////////////////////////////
    
    //from the current gap, find the next gap or inline node, whichever comes first
    for(pos = $movingPos.pos + dir; !headType; pos += dir) {
        if((pos > doc.content.size)||(pos < 0)) {
            //we reached the end of the doc
            //no new selection, but return this as handled
            return true;
        }
        let $pos = doc.resolve(pos);
        let parentNode = $pos.parent;
        if(parentNode == doc) {
            if(GapSelection.isGapLocation($pos)) {
                //we are at a gap location
                //put gap selection here
                $newHead = $pos;
                headType = "gap";
            }
            //we are between non-leaf node - continue moving
        }
        else if(parentNode.isTextblock) {
            //we are in a text node
            //this is the next position for text
            $newHead = doc.resolve(pos);
            headType = "text";
        }
        //if we get here - continue moving
        //maybe in a parent non-text node or maybe fall through from parent node null
    }

    //get the new anchor
    if(shiftPressed) {
        $newAnchor = $otherPos;
        anchorType = $newAnchor.depth ? "text" : "gap"; //I am assuming it is 0 or in text. I maybe should be more careful
    }
    else {
        $newAnchor = $newHead;
        anchorType = headType;
    }

    if((headType == "gap")||(anchorType == "gap")) {
        //gap selection
        if (dispatch) dispatch(state.tr.setSelection(new GapSelection($newAnchor,$newHead)).scrollIntoView());
        return true
    }
    else {
        //text selection
        if (dispatch) dispatch(state.tr.setSelection(new prosemirrorState_es_js.TextSelection($newAnchor,$newHead)).scrollIntoView());
        return true
    }
}

/** This sets a new selection updating the previous selection for motion in the given direction
 * from the moving side of the selection (or takes no action, letting the default selection happen) */
function _createSelectionMovingFromText($movingPos,$otherPos,axis,dir,shiftPressed,state,dispatch,view) {
    //if we are in a text block and the next node is a leaf block, see if we leave the current text block
    //---------------------------------------------------------------------------------------------------------------
    // SCHEMA ASSUMPTION - We are assuming leaf nodes are always in the root level of the document, not in containers
    // further, we are not allowed to have an empty container block.
    //---------------------------------------------------------------------------------------------------------------

    //if we do not leave the current block, we will allow default selection handling.
    //but this is potentially expensive, at least for vertical, so we will do that check last

    //if our current text block is _not_ in the root level, our next block may be the next block in this grandparent
    //with our assumption, this would be a text block or a container of 1 or more text blocks.
    let grandparentDepth = $movingPos.depth-1;
    if(grandparentDepth !== 0) {
        if($movingPos.index(grandparentDepth) !== ((dir > 0) ? $movingPos.node(grandparentDepth).childCount-1 : 0)) {
            //we are not the end block in the direction of motion
            //next block is a text block
            //use the default select handling
            return false
        } 
    }

    //check if the next block at document level is a leaf block (since we assume they are only at root level)
    let doc = $movingPos.doc;
    let nextBlockInRoot = doc.maybeChild($movingPos.index(0) + ((dir > 0) ? 1 : -1) );
    if((nextBlockInRoot)&&(isLeafBlock(nextBlockInRoot))) {
        //next block in direction of travel is a leaf block. We will make a gap selection if we leave the current block
        //we will do that check now (as mentioned above)

        //check if we leave the current block
        if( !( (axis == "vert") ? _leavesTextblockVertical(view, $movingPos, dir) : _leavesTextblockHorizontal(view, $movingPos, dir)) ) {
            //we do not leave the current block
            //use default selection handling
            return false;
        }

        //get the position ouside the current block and document level
        let newHeadPos = (dir > 0) ? $movingPos.end(1) + 1 : $movingPos.start(1) - 1;
        let $newHead = doc.resolve(newHeadPos);
        let $newAnchor = shiftPressed ? $otherPos : $newHead;
        if (dispatch) dispatch(state.tr.setSelection(new GapSelection($newAnchor,$newHead)).scrollIntoView());
        return true
    }
    else {
        //next is text or we leav document
        //use default selection handling
        return false;
    }
}

////////////////////////////////////////////////////////////////

//=========================
// Deep internal functions copied from ProseMirror domCoords.js and dom.js.
// I needed a few modifications.
//=========================

/** This is a copied version of endOfTextblockHorizontal from domCoords. I needed a modified version
 * of its partner function. When I copied this, the copy is only valid for the case
 * of non-bidirectional text. I am not supporting it, yet. */
function _leavesTextblockHorizontal(view, $pos, dir) {
    let offset = $pos.parentOffset, atStart = !offset, atEnd = offset == $pos.parent.content.size;
    return (dir < 0) ? atStart : atEnd
}


/** This is a copied version of endOfTextblockVertical from domCoords, because I wanted it to be slightly 
 * different - the original only gives the right result for no shift key. */
function _leavesTextblockVertical(view, $pos, dir) {
    let {node: dom} = view.docView.domFromPos($pos.pos);
    for (;;) {
        let nearest = view.docView.nearestDesc(dom, true);
        if (!nearest) break
        if (nearest.node.isBlock) { dom = nearest.dom; break }
        dom = nearest.dom.parentNode;
    }
    let coords = view.coordsAtPos($pos.pos);
    for (let child = dom.firstChild; child; child = child.nextSibling) {
        let boxes;
        if (child.nodeType == 1) boxes = child.getClientRects();
        else if (child.nodeType == 3) boxes = __copied_textRange(child, 0, child.nodeValue.length).getClientRects();
        else continue
        for (let i = 0; i < boxes.length; i++) {
            let box = boxes[i];
            if (box.bottom > box.top && ((dir < 0) ? box.bottom < coords.top + 1 : box.top > coords.bottom - 1))
                return false
        }
    }
    return true

}

/** was dom.js textRange */
function __copied_textRange(node, from, to) {
    let range = document.createRange();
    range.setEnd(node, to == null ? node.nodeValue.length : to);
    range.setStart(node, from || 0);
    return range
}

//================================================================================
// Apogee component
//================================================================================

class ApogeeComponentView {
  constructor(node, view, getPos, pageDisplay) {
    // We'll need these later
    this.node = node;
    this.view = view;
    this.getPos = getPos;
    this.pageDisplay = pageDisplay;

    // The node's representation in the editor
    this.dom = document.createElement("div");
    this.dom.className = "page-apogee-comp";
    this.dom.draggable = false;

    this.contentDiv = document.createElement("div");
    this.contentDiv.className = "page-apogee-comp-container";
    this.dom.appendChild(this.contentDiv);

    this.setViewDataFromNode();

  }

  selectNode() {
    this.dom.classList.add("ProseMirror-selectednode");
    //if (!this.innerView) this.open()
  }

  deselectNode() {
    this.dom.classList.remove("ProseMirror-selectednode");
    //if (this.innerView) this.close()
  }

  setViewDataFromNode() {
    let name = this.node.attrs["name"];
    let memberId = this.node.attrs["memberId"];

    //temporary solution to a problem: we will hold an ID during a name
    //change so we don't lose track of an object.
    //we will not display data in this time.
    let childComponentDisplay;
    if (name) {
      childComponentDisplay = this.pageDisplay.getChildComponentDisplay(name,true);

    }

    if (childComponentDisplay) {
      var displayElement = childComponentDisplay.getElement();
      this.contentDiv.appendChild(displayElement);
    }
    else {
      this.contentDiv.innerHTML = "Component not found: " + name;
    }

  }

  //===========================================================
  //figrue out what I want here
  getJsonData() {
    //get the attribute!!!! - this is just a string
    var name = this.node.attrs["name"];
    if (name) stateJson = { name };
    else stateJson = {};
    return stateJson;
  }

  getTextData() {
    //get the json data and make to text
    var data = this.getJsonData();
    var textData;
    if (data == null) textData = "";
    else textData = JSON.stringify(data);
    return textData;
  }
  //end simplified
  //============================================================

  update(node) {
    if (!node.sameMarkup(this.node)) return false
    this.node = node;
    this.setViewDataFromNode();
    return true
  }

  destroy() {
    this.node = null;
    this.view = null;
    this.getPos = null;
    this.pageDisplay = null;
    this.dom = null;
    this.contentDiv = null;
  }

  stopEvent(event) {
    return true;
  }

  ignoreMutation() { return true }
}

//===========================

function createProseMirrorManager(app, schema) {

    //this is the function return object - the editor manager
    let proseMirror = {};

    //===========================
    //create the toolbar
    //===========================
    let convertToParagraphCommand = (state, dispatch) => setBlockType(schema.nodes.paragraph, state, dispatch);
    let convertToH1Command = (state, dispatch) => setBlockType(schema.nodes.heading1, state, dispatch);
    let convertToH2Command = (state, dispatch) => setBlockType(schema.nodes.heading2, state, dispatch);
    let convertToH3Command = (state, dispatch) => setBlockType(schema.nodes.heading3, state, dispatch);
    let convertToH4Command = (state, dispatch) => setBlockType(schema.nodes.heading4, state, dispatch);
    let convertToBulletCommand = (state, dispatch) => setBlockType(schema.nodes.bulletList, state, dispatch);
    let convertToNumberedCommand = (state, dispatch) => setBlockType(schema.nodes.numberedList, state, dispatch);

    //this function determines if the block button is highlighted
    let getBlockIsHighlightedFunction = (nodeType) => {
        return (selectionInfo) => {
            let blockTypes = selectionInfo.blocks.blockTypes;
            return ((blockTypes.length === 1) && (blockTypes[0] == nodeType));
        }
    };

    let toolbarItems = [
        new ActionButton(convertToParagraphCommand, getBlockIsHighlightedFunction(schema.nodes.paragraph), null, "Normal", "atb_normal_style", "Normal Paragraph Text"),
        new ActionButton(convertToH1Command, getBlockIsHighlightedFunction(schema.nodes.heading1), null, "H1", "atb_h1_style", "Heading 1"),
        new ActionButton(convertToH2Command, getBlockIsHighlightedFunction(schema.nodes.heading2), null, "H2", "atb_h2_style", "Heading 2"),
        new ActionButton(convertToH3Command, getBlockIsHighlightedFunction(schema.nodes.heading3), null, "H3", "atb_h3_style", "Heading 3"),
        new ActionButton(convertToH4Command, getBlockIsHighlightedFunction(schema.nodes.heading4), null, "H4", "atb_h4_style", "Heading 4"),
        new ActionButton(convertToBulletCommand, getBlockIsHighlightedFunction(schema.nodes.bulletList), null, '\u2022', "atb_ul_style", "Bullet List"),
        new ActionButton(convertToNumberedCommand, getBlockIsHighlightedFunction(schema.nodes.numberedList), null, "1.", "atb_ol_style", "Nubmered List"),
        new MarkToggleItem(schema.marks.bold, null, "B", "atb_bold_style", "Bold"),
        new MarkToggleItem(schema.marks.italic, null, "I", "atb_italic_style", "Italic"),
        new MarkDropdownItem(schema.marks.fontfamily, "fontfamily", [["Sans-serif", "Sans-serif"], ["Serif", "Serif"], ["Monospace", "Monospace"]], "Sans-serif", "Font"),
        new MarkDropdownItem(schema.marks.fontsize, "fontsize", [["75%", ".75em"], ["100%", "1em"], ["150%", "1.5em"], ["200%", "2em"]], "1em", "Font Size"),
        new MarkDropdownItem(schema.marks.textcolor, "color", [["Black", "black"], ["Blue", "blue"], ["Red", "red"], ["Green", "green"], ["Yellow", "yellow"], ["Dark Gray", "#202020"],
        ["Gray", "#505050"], ["light gray", "#808080"]], "black","Font Color"),
        new MarkDropdownItem(schema.marks.highlight, "color", [["None", "none"], ["Yellow", "yellow"], ["Cyan", "cyan"], ["Pink", "pink"], ["Green", "green"],
        ['Orange', "orange"], ["Red", "red"], ["Gray", "#a0a0a0"]], "none","Highlight"),

    ];

    //===========================
    //state debug plugin
    //===========================

    let stateCheckPlugin = new prosemirrorState_es_js.Plugin({
        view(editorView) {
            let stateCheck = new StateCheck(editorView);
            return stateCheck;
        },

        props: {
            createSelectionBetween(_view, $anchor, $head) {
                console.log("XXX Create Selection between: " + $anchor.pos + " - " + $head.pos);
                return false;
              },
        }
    });

    //==============================
    // Create the editor
    //==============================

    function undo() {
        let commandManager = app.getCommandManager();
        let commandHistory = commandManager.getCommandHistory();
        commandHistory.undo();
    }

    function redo() {
        let commandManager = app.getCommandManager();
        let commandHistory = commandManager.getCommandHistory();
        commandHistory.redo();
    }

    //===============================
    //set up the export functions
    //===============================

    proseMirror.getPlugins = () => plugins;

    proseMirror.createEditorView = function (containerElement, pageDisplay, editorData) {

        //create the toolbar instance
        let toolbarView = new ApogeeToolbar(toolbarItems);
        proseMirror.editorToolbarElement = toolbarView.dom;

        //create the toolbar plugin - we will reuse the toolbar element here
        let toolbarPlugin = new prosemirrorState_es_js.Plugin({
            view(editorView) {
                toolbarView.setEditorView(editorView);
                return toolbarView;
            }
        });

        let plugins = [
            getInteractiveNodePlugin(),
            prosemirrorKeymap_es_js.keymap({ "Mod-z": undo, "Mod-y": redo }),
            prosemirrorKeymap_es_js.keymap(baseKeymap),
            apogeeSelectionPlugin(),
            toolbarPlugin,
            stateCheckPlugin
        ];

        var nodeViews = {};
        nodeViews.apogeeComponent = (node, view, getPos) => new ApogeeComponentView(node, view, getPos, pageDisplay);

        let pageComponentView = pageDisplay.getComponentView();

        var dispatchTransaction = transaction => pageComponentView.applyTransaction(transaction);

        var editorView = new prosemirrorView_es_js.EditorView(containerElement, {
            state: editorData,
            dispatchTransaction: dispatchTransaction,
            nodeViews: nodeViews
        });

        return { editorView, toolbarView, plugins };
    };



    return proseMirror;

}

//this constant is used (or hopefully not) in correctCreateInfoforRepeatedNames
const MAX_SUFFIX_INDEX = 99999;

/** This is the base class for a parent component (an object that has children),
 * It extends the component class. */
class ParentComponentView extends ComponentView {

    constructor(appViewInterface,component) {
        //base constructor
        super(appViewInterface,component);

        //ccreate the editor manager
        this.editorManager = createProseMirrorManager(this.getApp(),component.getSchema());
    }

    createTreeDisplay() {
        var treeDisplay = super.createTreeDisplay();
        
        //add any existing children to the tree entry
        var treeEntry = treeDisplay.getTreeEntry();
        var parentFolder = this.component.getParentFolderForChildren();
        var appViewInterface = this.getAppViewInterface();
        var childIdMap = parentFolder.getChildIdMap();
        for(var childKey in childIdMap) {
            var childMemberId = childIdMap[childKey];
            var childComponentView = appViewInterface.getComponentViewByMemberId(childMemberId);
            if(childComponentView) {
                var childTreeEntry = childComponentView.getTreeEntry();
                treeEntry.addChild(childTreeEntry);
            }
        }
        
        return treeDisplay;
    }
    
    //----------------------
    // Parent Methods
    //----------------------

    /** This function adds a fhile componeent to the displays for this parent component. */
    removeChild(childComponentView) {
        //remove from tree entry
        var treeEntry = this.getTreeEntry();
        if(treeEntry) {
            var childTreeEntry = childComponentView.getTreeEntry();
            if(childTreeEntry) {
                treeEntry.removeChild(childTreeEntry);
            }
        }

        if(this.tabDisplay) {
            this.tabDisplay.removeChild(childComponentView); 
        }
        
        //remove child windows - just hide them. They will be deleted in the component
        childComponentView.closeComponentDisplay();
    }

    /** This function adds a fhile componeent to the displays for this parent component. */
    addChild(childComponentView) {
        //add the child to the tree entry
        var treeEntry = this.getTreeEntry();
        if(treeEntry) {
            var childTreeEntry = childComponentView.getTreeEntry();
            treeEntry.addChild(childTreeEntry);
        }

        //add child entry for tab
        if(this.tabDisplay) {
            this.tabDisplay.addChild(childComponentView); 
        }
    }


    //###########################################################################################################
    //start page code
    
    getEditorState() {
        return this.getComponent().getEditorState();
    }

    getEditorManager() {
        return this.editorManager;
    }

    getSchema() {
        return this.getComponent().getSchema();
    }

    //----------------------------------------
    // Editor Command Processing
    //----------------------------------------

    /** This function turns a transaction into an application command. This is used
     * for the command path for commands generated outside the editor. */
    createEditorCommand(transaction,optionalInitialSelection,optionalInitialMarks) {

        var commandData = {};
        commandData.type = "literatePageTransaction";
        commandData.componentId = this.getComponent().getId();

        //we include the transaction because that is how prose mirror modiies state
        //it will be deleted from any command saved in the history so there is only JSON objects left.
        //If a command from history is used, the transaction will be reconstructed from the history.
        commandData.transaction = transaction;

        //the initial selection and marks should be included if this is a document changing transaction, 
        //they are used to make the undo command.
        if(optionalInitialSelection) commandData.initialSelection = optionalInitialSelection.toJSON();
        if(optionalInitialMarks) commandData.initialMarks = optionalInitialMarks.map(mark => mark.toJSON());
            
        return commandData;
    }

    
    /** This method is called to respond to transactions created in the editor. */
    applyTransaction(transaction) {
        
        let editorState = this.getEditorState();

        //this will hold the resulting command
        let apogeeCommand;
        let commandsDeleteComponent = false;
        let deleteMsg;

        let initialSelection = editorState.selection;
        let initialMarks = editorState.marks;

        if(this.transactionUpdatesModel(transaction)) {

            let commandList = [];
            let allDeletedNames = [];

            //record if the transaction sets the selection or markSet
            let finalSelection = transaction.selectionSet ? transaction.selection : null;
            let finalStoredMarks = transaction.storedMarksSet ? transaction.storedMarks : null;

            let workingInitialSelection = initialSelection;
            let workingInitialMarks = initialMarks;

            //-----------------------------------------
            //process each step, looking for inserted or deleted apogee nodes
            //if there are any, intercept these commands and modify them to do the proper
            //actions on the model and update the transaction so the apogee components 
            //are created/deleted at the proper time relative to their insert/remove from the document.
            //-------------------------------------------
            let activeNameMap = this.createActiveNameMap();
            let modifiedTransaction = editorState.tr;
            let transactionModified = false;
            transaction.steps.forEach( (oldStep, index) => {

                let oldStepDoc = transaction.docs[index];

                //--------------------------------------
                //process the step for deleted components
                //--------------------------------------
                let deleteComponentCommands;
                let deletedComponentShortNames = this.getStepDeletedComponentShortNames(oldStep,oldStepDoc);
                if(deletedComponentShortNames.length > 0) {
                    //update active name map
                    this.updateActiveNameMapForDelete(activeNameMap,deletedComponentShortNames);

                    //get delete commands
                    deleteComponentCommands = this.createDeleteComponentCommands(deletedComponentShortNames);

                    //save the deleted names so we can warn the user about the delete
                    allDeletedNames = allDeletedNames.concat(deletedComponentShortNames);
                }

                //--------------------------------------
                //process the step for any added components including potentially modifying the slice
                //--------------------------------------
                let createComponentCommands;
                let { insertSlice, createdComponentInfos } = this.processForStepComponentCreateCommands(oldStep,activeNameMap);
                if(createdComponentInfos.length > 0) {
                    //get the create commands
                    createComponentCommands = this.createCreateComponentCommands(createdComponentInfos);

                    //perhaps confusingly, the activeNameMap is updated in place in the above function so we don't have to 
                    //do it here.
                }

                //--------------------------------------
                // Update the new transaction and commands if an apogee nodes are created and/or deleted
                //--------------------------------------
                if((deleteComponentCommands)||(createComponentCommands)) {
                    //we want to modify the step and insert the delete and/or create component commands

                    //right now we are assuming and only supporting the case that the command that creates or
                    //deleted components is a REPLACE step (not a REPLACE AROUND or anything else)
                    if(oldStep.jsonID != "replace") {
                        throw new Error("Component add/remove in a non-replace step: " + oldStep.jsonID + "; NOT CURRRENTLY SUPPORTED!");
                    }

                    //----------------------------------
                    //create the remove step (if needed)
                    //-----------------------------------
                    //this is the range in which we wil insert the new content
                    let insertFrom = oldStep.from;
                    let insertTo;

                    //if there is content removed, do this in an explicit delete step and, if needed, a later insert after any components are created/deleted
                    if(oldStep.from != oldStep.to) {
                        //store the initial modified step count
                        let initialStepCount = modifiedTransaction.steps.length;

                        //rather than replacing the content including the new apogee node, just DELETE for now.
                        //we must delete issue a create component command before we insert it into the doc.
                        modifiedTransaction.deleteRange(oldStep.from,oldStep.to);
                        transactionModified = true;

                        //we want to look at the steps we created, so we can update these with our new content
                        //for now we will support only one replace step is created.
                        let addedRemoveSliceLength = 0;
                        let newStepCount = modifiedTransaction.steps.length;
                        if(newStepCount - initialStepCount != 1) {
                            let addedStep = modifiedTransaction.steps[newStepCount-1];
                            if((addedStep.slice)&&(addedStep.slice.content)) {
                                addedRemoveSliceLength = addedStep.slice.content.size;
                            }
                        }

                        insertTo = oldStep.from + addedRemoveSliceLength;
                    }
                    else {
                        insertTo = oldStep.from;
                    }

                    //close out the old transaction if needed, starting a new one
                    if(transactionModified) {
                        //save the transaction as a command (so we can add the model commands now)
                        let editorCommand = this.createEditorCommand(modifiedTransaction,workingInitialSelection,workingInitialMarks);
                        commandList.push(editorCommand);

                        //create a new transaction
                        let config = {};
                        config.doc = modifiedTransaction.doc;
                        config.selection = modifiedTransaction.selection;
                        config.storedMarks = modifiedTransaction.storedMarks;
                        let intermediateState = prosemirrorState_es_js.EditorState.create(config);

                        modifiedTransaction = intermediateState.tr;
                        workingInitialSelection = config.selection;
                        workingInitialMarks = config.storedMarks;
                        transactionModified = false;
                    }

                    //----------------------------
                    //insert any model commands
                    //----------------------------
                    if(deleteComponentCommands) commandList.push(...deleteComponentCommands);
                    if(createComponentCommands) commandList.push(...createComponentCommands);

                    //----------------------------
                    //create the editor insert step (if needed)
                    //----------------------------
                    if(insertSlice) {
                        modifiedTransaction.replaceRange(insertFrom,insertTo,insertSlice);
                        transactionModified = true;
                    }    
                }
                else {
                    //add the old step to the current modified transaction
                    modifiedTransaction.step(oldStep);
                }

            });

            //if the selection or stored marks was explicitly set in the transaction, add these back to the final new transaction
            if(finalSelection) {
                let fixedSelection = this.convertSelectionToNewDoc(finalSelection,modifiedTransaction.doc);
                modifiedTransaction.setSelection(fixedSelection);
                transactionModified = true;
            }
            if(finalStoredMarks) {
                modifiedTransaction.setStoredMarks(finalStoredMarks);
                transactionModified = true;
            }

            //close out the final transaction, if needed
            if(transactionModified) {
                //make sure we scroll into view
//TEST:CHANGE SCROLL INTO VIEW
//                    modifiedTransaction.scrollIntoView();

                //save the transaction as a command (so we can add the model commands now)
                let editorCommand = this.createEditorCommand(modifiedTransaction,workingInitialSelection,workingInitialMarks);
                commandList.push(editorCommand);
            }

            //-------------------
            // Get verificaion if we are deleting anything
            //-------------------
            if(allDeletedNames.length > 0) {
                //flag a delete will be done
                commandsDeleteComponent = true;
                deleteMsg = "This action will delete the selected cells. Are you sure you want to do that? Cells to delete: " + allDeletedNames;
            }

            //-------------------------
            //create the apogee command for the input transaction
            //-------------------------
            apogeeCommand = {};
            apogeeCommand.type = "compoundCommand";
            apogeeCommand.childCommands = commandList;
        }
        else {
            //--------------------------
            //There is no change to the model. Convert the transaction directly to an editor command
            //--------------------------
            apogeeCommand = this.createEditorCommand(transaction,initialSelection,initialMarks);
        }

        //-------------------
        //execute the command
        //-------------------
        if(apogeeCommand) {

            let doAction = () => {
                this.getApp().executeCommand(apogeeCommand);
            };

            if(commandsDeleteComponent) {
                //if there is a delete, verify the user wants to do this
                let cancelAction = () => {
                    this.giveEditorFocusIfShowing();
                };
                apogeeUserConfirm(deleteMsg,"Delete","Cancel",doAction,cancelAction);
            }
            else {
                //otherwise just take the action
                doAction();
            }
        }
    }

    //---------------------------------------
    // Transaction Processing to extract model commands
    //---------------------------------------

    /** This function checks if the editor transaction creates or deletes any apogee components. */
    transactionUpdatesModel(transaction) {

        if(!transaction.docChanged) return false;

        let modelUpdated = false;

        //check for deleted components
        let deleteNodeComponentCheck = node => {
            if(node.type.name == "apogeeComponent") modelUpdated = true;

            //apogee nodes are top level. Return false so we do no dive into child nodes.
            //if we change this rule, we need to change this code.
            return false;
        };

        //check steps to see if model is updated
        transaction.steps.forEach( (step,index) => {

            //look for deleted components in removed nodes 
            let doc = transaction.docs[index];
            if(step.jsonID == "replace") {
                doc.nodesBetween(step.from,step.to,deleteNodeComponentCheck);
            }
            else if(step.jsonID == "replaceAround") {
                doc.nodesBetween(step.from,step.gapFrom,deleteNodeComponentCheck);
                doc.nodesBetween(step.gapTo,step.to,deleteNodeComponentCheck);
            }

            //look for created components in added nodes
            if(this.stepHasCreateComponentNode(step)) modelUpdated = true;
        });

        return modelUpdated;
    }

    /** This function creates a map of the component names currently in this parent component. */
    createActiveNameMap() {
        //retrieve the existing names
        let activeNameMap = {};
        let member = this.getComponent().getMember();
        for(let name in member.getChildIdMap()) {
            activeNameMap[name] = true;
        }

        return activeNameMap;
    }
    
    /** This function updates the active name map for the list of deleted components. If updates the map in place, but also returns it. */
    updateActiveNameMapForDelete(activeNameMap,deletedComponentShortNames) {
        deletedComponentShortNames.forEach( name => {
            if(activeNameMap[name]) delete activeNameMap[name];
        });
    }

    /** This function gets the shorts names for the components deleted in this step. */
    getStepDeletedComponentShortNames(step,stepDoc) {
        let deletedComponentShortNames = [];

        //this will store the name if this is a component node
        let getApogeeNodeNames = node => {
            if(node.type.name == "apogeeComponent") {
                deletedComponentShortNames.push(node.attrs.name);
            }
        };

        //read the deleted nodes, saving the apogee component node names
        if(step.jsonID == "replace") {
            stepDoc.nodesBetween(step.from,step.to,getApogeeNodeNames);
        }
        else if(step.jsonID == "replaceAround") {
            stepDoc.nodesBetween(step.from,step.gapFrom,getApogeeNodeNames);
            stepDoc.nodesBetween(step.gapTo,step.to,getApogeeNodeNames);
        }

        return deletedComponentShortNames;
    }
    
    /** This method process the step, modifying it as needed:
     * -it pulls out the "state" that we include in the pasted data, but we don't track this value in the working node
     * - it checks if the name is available. If not, it modifying the name.
     * The passed in variable "activeNameMap" is modified in place as new names are added
     */
    //let { insertSlice, createdComponentInfos } = this.processForStepComponentCreateCommands(oldStep,oldStepJson,activeNameMap);
    processForStepComponentCreateCommands(oldStep,activeNameMap) {
        let insertSlice;
        let createdComponentInfos = [];

        if(!this.stepHasCreateComponentNode(oldStep)) {
            //no modified step or create component commands needed
            insertSlice = oldStep.slice;
            createdComponentInfos = [];
        }
        else {
            //we will check each apogee node to see if we need to change the name of any of them
            //it might be a little cumbersome how I do this.
            let newSliceContentJson = [];
            let oldStepJson = oldStep.toJSON();
            if(oldStepJson.stepType == "replace"){
                oldStepJson.slice.content.forEach( oldNodeJson => {

                    if(oldNodeJson.type == "apogeeComponent") {
                        let newNodeJson = apogeeutil$1.jsonCopy(oldNodeJson);

                        //remove the state from the json, but save it separately
                        let state = newNodeJson.attrs.state;
                        delete newNodeJson.attrs.state;

                        //get the name and do any needed name processing
                        let requestedName = newNodeJson.attrs.name;

                        let nameToUse = this.createComponentReplacementNameProcessing(requestedName,activeNameMap);
                        if(nameToUse != requestedName) {
                            newNodeJson.attrs.name = nameToUse;

                            //we need to change the name in the state too
                           if(state) {
                                state.memberJson.name = nameToUse;                                
                            }
                        }

                        //store the create info
                        let createdComponentInfo = {};
                        createdComponentInfo.name = nameToUse;
                        createdComponentInfo.state = state;
                        createdComponentInfos.push(createdComponentInfo);

                        //store the modified json
                        newSliceContentJson.push(newNodeJson);
                        
                    }
                    else {
                        //not a component, store the original node
                        newSliceContentJson.push(oldNodeJson);
                    }
                });
            }

            let newSliceJson = {};
            Object.assign(newSliceJson,oldStepJson.slice);
            newSliceJson.content = newSliceContentJson;
            insertSlice = prosemirrorModel_es_js.Slice.fromJSON(this.getSchema(),newSliceJson);
        }

        

        //return the new step
        return { insertSlice, createdComponentInfos };
    }

    /** This method checks the name of a created component and returns the proper name to 
     * use to create the component. It will be modified if the name already exists. This function modifies the active name map 
     * in place. */
    createComponentReplacementNameProcessing(name,activeNameMap) {
        if(activeNameMap[name]) {
            //repeat name! - modify it with a suffix
            for(let suffixIndex = 1; true; suffixIndex++) {
                let testName = name + "_" + suffixIndex;
                if(!activeNameMap[testName]) {
                    let newName = testName;
                    //mark this name as used
                    activeNameMap[newName] = true;
                    return newName;
                }
                
                //I assume this will never happen, but just in case we will provide an end to this loop
                if(suffixIndex > MAX_SUFFIX_INDEX) {
                    throw new Error("Too many repeat names in create new component!");
                }
            }
        }
        else {
            //old name was good, mark it as used
            activeNameMap[name] = true;
            return name
        }
    }

    /** This method returns true if the given step has any create component node command. */
    stepHasCreateComponentNode(step) {
        if((step.jsonID == "replace")||(step.jsonID == "replaceAround")) {
            return step.slice.content.content.some( node => (node.type.name == "apogeeComponent") );
        }
    }

    /** This method takes a selection pointing at one document and makes a new one pointing at the given
     * document. The positions in the documents must match.
     */
    convertSelectionToNewDoc(selection,newDoc) {
        let $newAnchor = newDoc.resolve(selection.$anchor.pos);
        let $newHead = newDoc.resolve(selection.$head.pos);
        if(selection instanceof prosemirrorState_es_js.TextSelection) {
            return new prosemirrorState_es_js.TextSelection($newAnchor,$newHead);
        }
        else if(selection instanceof prosemirrorState_es_js.NodeSelection) {
            return new prosemirrorState_es_js.NodeSelection($newAnchor);
        }
        else {
            throw new Exception("Unknown selection type: " + selection.constructor.name);
        }
        
    }

    /** This method maps the list of component names to a list of delete commands. */
    createDeleteComponentCommands(deletedComponentShortNames) {
        return deletedComponentShortNames.map(shortName => {

            let parentMember = this.getComponent().getParentFolderForChildren();
            let memberId = parentMember.lookupChildId(shortName);
            
            let commandData = {};
            commandData.type = "deleteComponent";
            commandData.memberId = memberId;
            return commandData;
        });
    }
    
    /** This method maps the list of component craete infos to a list of create commands. */
    createCreateComponentCommands(createdComponentInfos) {
        return createdComponentInfos.map( createInfo => {
            let state = createInfo.state;

            let parentMember = this.getComponent().getParentFolderForChildren();

            let commandData = {};
            commandData.type = "addComponent";
            commandData.parentId = parentMember.getId();
            commandData.memberJson = state.memberJson;
            commandData.componentJson = state.componentJson;
            return commandData;
        })
    }

    //------------------------------------------
    // Editor command processing from commands created outside the editor
    //------------------------------------------

    /** This method removes the node of the given name frmo the folder. If no
     * transaction argument is included, a new transaction will be created. If the
     * transaction object is included, the remove action will be added to it. 
     */
    getSelectApogeeNodeCommand(childShortName) {
        var state = this.getEditorState();
      
        let {found,from,to} = this.getComponentRange(state,childShortName);
        //end test

        if(found) {
            let $from = state.doc.resolve(from);
            let selection = new prosemirrorState_es_js.NodeSelection($from);
            let transaction = state.tr.setSelection(selection);//.scrollIntoView(); //TEST:CHANGE SCROLL INTO VIEW
            return this.createEditorCommand(transaction);
        }
        else {
            return null;
        }
    }

    /** This will move the selection to the start of the document. */
    getSelectStartOfDocumentCommand() {
        let state = this.getEditorState();
        let $startPos = state.doc.resolve(0);
        let selection = prosemirrorState_es_js.TextSelection.between($startPos, $startPos);
        let transaction = state.tr.setSelection(selection).scrollIntoView();
        return this.createEditorCommand(transaction);
    }

    /** This will move the selection to the end of the document. */
    getSelectEndOfDocumentCommand() {
        let state = this.getEditorState();
        //check the node
        let lastNode = state.doc.content.content[state.doc.content.content.length-1];
        let endPos = state.doc.content.size;
        let $endPos = state.doc.resolve(endPos);
        let selection;
        //We should get a different criteria here
        //We want to use the gap cursor if the last element is not a textblock or a parent to a text block (list!)
        //Currently only the apogeeComponent fits. 
        //If we add new blocks we might need new criteria, but I am not sure what it is now.
        if(lastNode.type.name == "apogeeComponent") {
            selection = new GapSelection($endPos);
        }
        else {
            selection = prosemirrorState_es_js.TextSelection.between($endPos, $endPos);
        }
        let transaction = state.tr.setSelection(selection).scrollIntoView();
        return this.createEditorCommand(transaction);
    }
    
    getComponentRange(editorData,componentShortName) {
        let doc = editorData.doc;
        let schema = editorData.schema;
        let result = {};
        doc.forEach((node, offset) => {
            if (node.type == schema.nodes.apogeeComponent) {
                if (node.attrs.name == componentShortName) {

                    if (result.found) {
                        //this shouldn't happen
                        throw new Error("Multiple nodes found with the given name");
                    }

                    result.found = true;
                    result.from = offset;
                    result.to = result.from + node.nodeSize;
                }
            }
        });
        return result;
    }

    /** This method give focus to the editor for this componennt, if the component is showing. */
    giveEditorFocusIfShowing() {
        let display = this.getTabDisplay();
        if((display)&&(display.getIsShowing())) {
            let editorView = display.getEditorView(); 
            if(editorView.dom) {
                editorView.focus();
            }
        }
    }
      
    /** This method adds an apogee component node of the given name to the folder.
     * It will be placed in the current selection, unless the "insertAtEnd" argument is true. 
     * If no transaction argument is included, a new transaction will be created. If the
     * transaction object is included, the remove action will be added to it. 
     */
    getInsertApogeeNodeOnPageCommands(shortName,insertAtEnd) {
        let state = this.getEditorState();
        let schema = state.schema;
        let setupTransaction;
        let commandInfo = {};
        
        if(!insertAtEnd) {
            let { empty } = state.selection;
            if(!empty) {

                //BELOW I HAVE TWO MODELS FOR INSERTING A NEW NODE - OVER THE CURRENT SELECTION
                //OR AFTER THE CURRENT SELECTION 

                //-----------------------------------------------
                // START insert the node over the current selection
                // It is commented out because some users got confused when a node got deleted when they added a new one,
                // which happened in the case a node is selected.
                
                // setupTransaction = state.tr.deleteSelection(); 

                // //see if we need to delete any apogee nodes
                // var deletedComponentShortNames = this.getDeletedApogeeComponentShortNames(setupTransaction);
                // commandInfo.deletedComponentShortNames = deletedComponentShortNames

                // if(deletedComponentShortNames.length > 0) {
                //     //create delete commands
                //     commandInfo.deletedComponentCommands = this.createDeleteComponentCommands(deletedComponentShortNames); 
                // }

                //END insert over current selection
                //------------------------------------------------

                //-----------------------------------------------
                // START insert the node at the end of the current selection
                let $endPos = state.selection.$to;
                let selection = new prosemirrorState_es_js.TextSelection($endPos,$endPos);
                setupTransaction = state.tr.setSelection(selection);
                // END insert the node at the end of the current selection
                //------------------------------------------------
            }
        }
        else {
            //insert at end
            //move selection to end
            let docLength = state.doc.content.size;
            let $pos = state.doc.resolve(docLength);
            let selection = new prosemirrorState_es_js.TextSelection($pos,$pos);
            setupTransaction = state.tr.setSelection(selection);
        }

        if(setupTransaction) {
            let initial1Selection = state.selection;
            let initial1Marks = state.marks;
            commandInfo.editorSetupCommand = this.createEditorCommand(setupTransaction,initial1Selection,initial1Marks);
        }

        //create a second transaction
        let addTransaction;
        let initial2Selection;
        let initial2Marks;
        if(setupTransaction) {
            let config = {};
            config.doc = setupTransaction.doc;
            config.selection = setupTransaction.selection;
            config.storedMarks = setupTransaction.storedMarks;
            let intermediateState = prosemirrorState_es_js.EditorState.create(config);

            addTransaction = intermediateState.tr;
            initial2Selection = config.selection;
            initial2Marks = config.storedMarks;
        }
        else {
            addTransaction = state.tr;
            initial2Selection = state.selection;
            initial2Marks = state.marks;
        }

        //finish the document transaction
        addTransaction = addTransaction.replaceSelectionWith(schema.nodes.apogeeComponent.create({ "name": shortName }));
//TEST:CHANGE SCROLL INTO VIEW
//        addTransaction.scrollIntoView();
        commandInfo.editorAddCommand = this.createEditorCommand(addTransaction,initial2Selection,initial2Marks);

        return commandInfo;
        
    }

    
    /** This function returns the names of any apogee components nodes which are deleted in the
     * given transaction. */
    getDeletedApogeeComponentShortNames(transaction) {
        //prepare to get apogee nodes
        let transactionShortNames = [];
    
        //get all the replcaed apogee components
        transaction.steps.forEach( (step,index) => {
            let stepDoc = transaction.docs[index];
            let stepShortNames = this.getStepDeletedComponentShortNames(step,stepDoc);
            transactionShortNames.push(...stepShortNames);
        });
    
        return transactionShortNames;
    
    }

    /** This method removes the node of the given name frmo the folder. If no
     * transaction argument is included, a new transaction will be created. If the
     * transaction object is included, the remove action will be added to it. 
     */
    getRemoveApogeeNodeFromPageCommand(childShortName) {
        var state = this.getEditorState();
      
        let {found,from,to} = this.getComponentRange(state,childShortName);
        //end test

        if(found) {
            let transaction = state.tr.delete(from, to);//.scrollIntoView();//TEST:CHANGE SCROLL INTO VIEW
            var commandData = this.createEditorCommand(transaction,state.selection,state.marks);
            return commandData;
        }
        else {
            return null;
        }
    }

    /** This method updates the name attribute of the given node. If no 
     * transaction argument is included, a new transaction will be created. If the
     * transaction object is included, the remove action will be added to it. 
     */
    getRenameApogeeNodeCommands(memberId,oldShortName,newShortName) {
        var state = this.getEditorState();
        let {found,from,to} = this.getComponentRange(state,oldShortName);

        let commands = {};

        if(found) {
            //clear the component state (by recording member id)
            let setupTransaction = state.tr.replaceWith(from, to,state.schema.nodes.apogeeComponent.create({"memberId": memberId }));
            commands.setupCommand = this.createEditorCommand(setupTransaction,state.selection,state.marks);

            //later set the new name
            let config = {};
            config.doc = setupTransaction.doc;
            config.selection = setupTransaction.selection;
            config.storedMarks = setupTransaction.storedMarks;
            let intermediateState = prosemirrorState_es_js.EditorState.create(config);
            let setNameTransaction = intermediateState.tr.replaceWith(from, to,state.schema.nodes.apogeeComponent.create({"name": newShortName}));
            commands.setNameCommand = this.createEditorCommand(setNameTransaction,config.selection,config.storedMarks);

            return commands;
        }
        else {
            return null;
        }
    }
        
    //end page code
    //############################################################################################################

}

/** This is used to flag this as an edit component. */
ParentComponentView.isParentComponentView = true;

/** This is a standin for the display conatiner for the literate page
 * 
 * @class 
 */
class PageDisplayContainer {

    constructor(componentDisplay, viewModeInfo) {
        
        //variables
        this.viewModeInfo = viewModeInfo;
        
        this.mainElement = null;
        this.viewToolbarElement = null;
        this.viewHeadingElement = null;
        this.headerContainer = null;
        this.messageContainer = null;
        this.viewContainer = null;
        this.viewDisplayElement = null;

        this.viewSelectorContainer = null;
        this.viewActiveElement = null;
        this.viewNameElement = null;

        this.hasViewSourceText = false;
        this.viewSource = null;
        
        this.isComponentShowing = false;
        this.isViewActive = viewModeInfo.isActive;
        this.isViewRemoved = viewModeInfo.isTransient; //start removed for transient displays
        this.isViewHidden = false;
        this.message = "";
        this.messageType = DATA_DISPLAY_CONSTANTS.MESSAGE_TYPE_NONE;  //start with an empty message
        this.isContentLoaded = false;
        
        this.destroyViewOnInactive = true;
        
        this.inEditMode = false;
        
        this.componentDisplay = componentDisplay;
        this.componentView = componentDisplay.getComponentView();
        this.viewTypeName = viewModeInfo.name;
        this.viewTypeLabel = viewModeInfo.label;

        this.dataDisplay = null;
        this.dataDisplayLoaded = false;

        this.heightUiActive = false;
        this.showLessButton = null;
        this.showMoreButton = null;
        this.showMaxButton = null;

        this.savedUiState = {};

        this.uiCompleted = false;
        this.uiDestroyed = false;
        
        //initialize
        this._initUI();
    }

    getComponentView() {
        return this.componentView;
    }

    getComponentDisplay() {
        return this.componentDisplay;
    }

    getDataDisplay() {
        return this.dataDisplay;
    }

    //-------------------
    // state management
    //-------------------

    /** This method should be called whent the frame parent is loaded or unloaded from the DOM. */
    setIsComponentShowing(isComponentShowing) {
        this.isComponentShowing = isComponentShowing;
        this._updateDataDisplayLoadedState();
    }

    /** This returns the isComponentShowing status of the display. */
    getIsComponentShowing() {
        return this.isComponentShowing;
    }

    getStateJson() {
        //update the saved state json
        this.savedUiState.isViewActive = this.isViewActive;
        if(this.dataDisplay) {
            this.dataDisplay.addUiStateData(this.savedUiState);
        }
        return this.savedUiState;
    }

    setStateJson(json) {
        if(json) {
            this.savedUiState = json;
        }
        else {
            this.savedUiState = {};
        }

        //update any relevent fields
        if(this.savedUiState.isViewActive !== undefined) {
            this._setIsViewActive(this.savedUiState.isViewActive);
        }

        if(this.dataDisplay) {
            this.dataDisplay.readUiStateData(this.savedUiState);
        }
    }

    //---------------------------
    // GUI ELEMENT
    //---------------------------

    /** This method returns the view label element to be used in the component title bar. */
    getViewSelectorContainer() {
        return this.viewSelectorContainer;
    }

    /** This method returns the main dom element for the window frame. */
    getDisplayElement() {
        return this.mainElement;
    }

    /** This method returns the display bar. It is a status and control bar for the data display to manage. */
    getDisplayBarElement() {
        return this.viewDisplayElement;
    }

    //------------------------------
    // standard methods
    //------------------------------

    /** The displayDestroyFlags indicate when the display for this view mode will be destroyed,
     * refering to times it is not visible to the user. See further notes in the constructor
     * description. */
    setDestroyViewOnInactive(destroyViewOnInactive) {
        this.destroyViewOnInactive = destroyViewOnInactive;
    }   

    /** This method destroys the data display. */
    destroy() {
        this._destroyUI();
        this._deleteDataDisplay();
    }

    
    /** This method should be called called before the view mode is closed. It should
     * return true or false. NO - IT RETURNS SOMETHING ELSE! FIX THIS! */
    isCloseOk() {
        if(this.dataDisplay) {
            if(this.dataDisplay.isCloseOk) {
                return this.dataDisplay.isCloseOk();
            }
            
            if(this.inEditMode) {
                return DisplayContainer.UNSAVED_DATA;
            }
        }
        
        return DisplayContainer.CLOSE_OK;
    }
        
    /** This method is called when the member is updated, to make sure the 
    * data display is up to date. */
    componentUpdated(component) {
        if(this.uiDestroyed) return;

        //update the data display
        if(this.dataDisplay) {
            let {reloadData,reloadDataDisplay} = this.dataDisplay.doUpdate();
            if(reloadDataDisplay) {
                //this will also reload data
                this._reloadDataDisplay();
            }
            else if(reloadData) {
                this._updateDataDisplay();
            }
        }

        //update name label on view heading if needed
        if((this.hasViewSourceText)&&(this.componentView.getComponent().isMemberFieldUpdated("member","name"))) {
            this.viewSource.innerHTML = this._getViewSourceText();
        }
    }


    //-----------------------------
    // Accessed by the data display
    //------------------------------

    setHideDisplay(doHide) {
        if(doHide != this.isViewHidden) {
            this.isViewHidden = doHide;
            this._updateViewState();
        }
    }

    getDisplayHidden() {
        return this.isViewHidden;
    }

    setRemoveView(doRemove) {
        if(doRemove != this.isViewRemoved) {
            this.isViewRemoved = doRemove;
            this._updateViewState();
        }
    }

    getViewRemoved() {
        return this.isViewRemoved;
    }

    setMessage(messageType,message) {
        this.messageType = messageType;

        this.messageContainer.className = MESSAGE_CONTAINER_BASE_CLASS;
        let messageTypeClass = MESSAGE_TYPE_CLASS_MAP[messageType];
        if(!messageTypeClass) messageTypeClass = DATA_DISPLAY_CONSTANTS.MESSAGE_TYPE_NONE;

        this.messageContainer.classList.add(messageTypeClass);

        this.message = (this.messageType != DATA_DISPLAY_CONSTANTS.MESSAGE_TYPE_NONE) ? message : "";
        this.messageContainer.innerHTML = this.message;
    }

    getMessageType() {
        return this.messageType;
    }

    getMessage() {
        return this.message;
    }

    //edit mode methods

    onCancel() {
        //reload old data
        this.dataDisplay.showData();
        
        return true;
    }

    startEditMode(onSave,onCancel) {
        if(!this.inEditMode) {
            this.inEditMode = true;
            var saveBar = getSaveBar(onSave,onCancel);
            this._setHeaderContent(saveBar);
            //take additional edit mode actions
            this.mainElement.classList.add("visiui_displayContainer_editMode");
            this.viewSelectorContainer.classList.add("visiui_displayContainer_viewSelectorContainerClass_editMode");
            this.componentDisplay.notifyEditMode(true,this.viewTypeName);

            //save listener for display view
            this.onKeyDown = event => this._keyDownHandler(event,onSave,onCancel);
            this.mainElement.addEventListener("keydown",this.onKeyDown);
        }
    }

    endEditMode() {
        //exit edit mode
        if(this.inEditMode) {
            this.inEditMode = false;
            this._setHeaderContent(null);
            if(this.onKeyDown) {
                this.mainElement.removeEventListener("keydown",this.onKeyDown);
                this.onKeyDown = null;
            }
            this.mainElement.classList.remove("visiui_displayContainer_editMode");
            this.viewSelectorContainer.classList.remove("visiui_displayContainer_viewSelectorContainerClass_editMode");
            this.componentDisplay.notifyEditMode(false,this.viewTypeName);
        }
        //select the associated node in the document.
        let parentComponentView = this.componentView.getParentComponentView();
        if(parentComponentView) {
            //give the editor focus
            parentComponentView.giveEditorFocusIfShowing();
        }

    }

    isInEditMode() {
        return this.inEditMode;
    }



    //====================================
    // Private Methods
    //====================================

    /** This method should be called whent the frame parent is loaded or unloaded from the DOM. */
    _setIsViewActive(isViewActive) {
        this.isViewActive = isViewActive;
        this._updateViewState();
        this._updateDataDisplayLoadedState();
    }

    /** @private */
    _initUI() {
        
        //make the container
        this.mainElement = uiutil.createElementWithClass("div","visiui_displayContainer_mainClass",null);

        //create the view header
        this.viewToolbarElement = uiutil.createElementWithClass("div","visiui_displayContainer_viewToolbarClass",this.mainElement);
        
        //create the heading element and its content
        this.viewHeadingElement = uiutil.createElementWithClass("div","visiui_displayContainer_viewHeadingClass",this.viewToolbarElement);
        let {viewTitleText,hasViewSourceText,viewTypeText,viewTypeClassName,viewDescText} = this._getViewHeadingInfo();

        let viewTitleElement = uiutil.createElementWithClass("span","visiui_displayContainer_viewTitleClass",this.viewHeadingElement);
        viewTitleElement.innerHTML = viewTitleText;

        this.hasViewSourceText = hasViewSourceText;
        if(hasViewSourceText) {
            //this is saved so we can update the name if it changes
            this.viewSource = uiutil.createElementWithClass("span","visiui_displayContainer_viewSourceClass",this.viewHeadingElement);
            this.viewSource.innerHTML = this._getViewSourceText();
        }
        if(viewTypeText) {
            let viewType = uiutil.createElementWithClass("span",viewTypeClassName,this.viewHeadingElement);
            viewType.innerHTML = viewTypeText;
        }
        if(viewDescText) {
            //NOTE - I probably need to add some options!!!
            let options = {
                wrapperAddonClass: "visiui_displayContainer_HelpWrapperAddon",
                imageAddonClass: "visiui_displayContainer_HelpImageAddon",
                textAddonClass: "visiui_displayContainer_HelpTextAddon"
            };
            if(viewDescText.length > 24) {
                options.textWidth = "300px";
            }
            let helpElements = getHelpElement(viewDescText,options);
            this.viewHeadingElement.appendChild(helpElements.wrapperElement);
        }

        this.sizingElement = uiutil.createElementWithClass("div","visiui_displayContainer_viewSizingElementClass",this.viewToolbarElement);

        //create the view display
        this.viewDisplayElement = uiutil.createElementWithClass("div","visiui_displayContainer_viewDisplayBarClass",this.viewToolbarElement);
        
        //add the header elment (for the save bar)
        this.headerContainer = uiutil.createElementWithClass("div","visiui_displayContainer_headerContainerClass",this.mainElement);

        //add the message element
        this.messageContainer = uiutil.createElementWithClass("div","visiui_displayContainer_messageContainerClass",this.mainElement);

        //add the view container
        this.viewContainer = uiutil.createElementWithClass("div","visiui_displayContainer_viewContainerClass",this.mainElement);

        //make the selector for the view, displayed in the component title bar
        this.viewSelectorContainer = uiutil.createElementWithClass("div","visiui_displayContainer_viewSelectorContainerClass",null);
        if(this.viewModeInfo.isInfoView) {
            this.viewSelectorContainer.classList.add("visiui_displayContainer_viewSelectorContainerClass_info");
        }
        //this is set from link to div so it can not get focus. later, we _do_ want it to get focuus, but if it does we need to make
        //sure button presses are handled properly. (as it would have been, enter does not work to leave the cell)
        this.viewSelectorLink = uiutil.createElementWithClass("div","visiui_displayContainer_viewSelectorLinkClass visiui_hideSelection",this.viewSelectorContainer);

        this.expandImage = uiutil.createElementWithClass("img","visiui_displayContainer_expandContractClass visiui_hideSelection",this.viewSelectorLink);
        this.expandImage.src = uiutil.getResourcePath(PageDisplayContainer.VIEW_CLOSED_IMAGE_PATH);
    
        this.contractImage = uiutil.createElementWithClass("img","visiui_displayContainer_expandContractClass visiui_hideSelection",this.viewSelectorLink);
        this.contractImage.src = uiutil.getResourcePath(PageDisplayContainer.VIEW_OPENED_IMAGE_PATH);

        this.viewNameElement = uiutil.createElementWithClass("span","visiui_displayContainer_viewSelectorClass visiui_hideSelection",this.viewSelectorLink);
        this.viewNameElement.innerHTML = this.viewTypeLabel;

        this.viewSelectorLink.onclick = () => { this._setIsViewActive(!this.isViewActive); return false; };

        //set initial state
        this.setMessage(this.messageType,this.message);
        this._updateViewState();
    }

    /** This tears down any elements created in UI initialization */
    _destroyUI() {
        if(!this.uiDestrpoyed) {
            this.uiDestroyed = true;

            if(this.onKeyDown) {
                this.mainElement.removeEventListener("keyDown",this.onKeyDown);
                this.onKeyDown = null;
            }
            this.mainElement = null;
            this.viewToolbarElement = null;
            this.viewHeadingElement = null;

            if(this.showLessButton) {
                this.showLessButton.onclick = null;
                this.showLessButton = null;
            }
            if(this.showMoreButton) {
                this.showMoreButton.onclick = null;
                this.showMoreButton = null;
            }
            if(this.showMaxButton) {
                this.showMaxButton.onclick = null;
                this.showMaxButton = null;
            }
            this.sizingElement = null;

            this.viewDisplayElement = null;
            this.headerContainer = null;
            this.viewContainer = null;
            this.viewSelectorContainer = null;

            if(this.viewSelectorLink) {
                this.viewSelectorLink.onclick = null;
                this.viewSelectorLink = null;
            }

            this.expandImage = null;
            this.contractImage = null;

            this.viewNameElement = null;
        }
    }

    _updateViewState() {
        //show/hide ui elements
        if(this.isViewRemoved) {
            this.mainElement.style.display = "none";
            this.viewSelectorContainer.style.display = "none";
        }
        else if(this.isViewActive) { 
            this.viewSelectorContainer.style.display = "";
            this.expandImage.style.display = "none";
            this.contractImage.style.display = "";
            this.mainElement.style.display = "";
            if(this.isViewHidden) {
                this.viewContainer.style.display = "none";
            }
            else {
                this.viewContainer.style.display = "";
            }
        }
        else {
            this.viewSelectorContainer.style.display = "";
            this.expandImage.style.display = "";
            this.contractImage.style.display = "none";
            this.mainElement.style.display = "none";
        }
    }

    /** This method clears the data display. It should only be called when the data display is not showing. 
     * maybe allow this when the display is showing - unload and reload it*/
    _reloadDataDisplay() {

        //update the stored UI state json
        this.savedUiState = this.getStateJson();

        //reset any data display specific parts of the ui
        this._cleanupDataDisplayUI();

        //this destrpys the data display, not the container - bad name
        this._deleteDataDisplay();

        //reload display
        this._updateDataDisplayLoadedState();
    }

    _getViewHeadingInfo() {
        let viewTitleText = this.viewModeInfo.label;
        if(this.viewModeInfo.sourceType == DATA_DISPLAY_CONSTANTS.VIEW_SOURCE_TYPE_FUNCTION) {
            let argList = (this.viewModeInfo.argList !== undefined) ? this.viewModeInfo.argList : "";
            viewTitleText += "(" + argList + ")";
        }

        let hasViewSourceText = (this.viewModeInfo.sourceLayer == DATA_DISPLAY_CONSTANTS.VIEW_SOURCE_LAYER_MODEL);
        
        let viewTypeText;
        let viewTypeClassName;
        if(this.viewModeInfo.sourceLayer == DATA_DISPLAY_CONSTANTS.VIEW_SOURCE_LAYER_MODEL) {
            if(this.viewModeInfo.sourceType == DATA_DISPLAY_CONSTANTS.VIEW_SOURCE_TYPE_DATA) {
                viewTypeText = SOURCE_TYPE_MODEL_DATA_LABEL;
            }
            else if(this.viewModeInfo.sourceType == DATA_DISPLAY_CONSTANTS.VIEW_SOURCE_TYPE_FUNCTION) {
                viewTypeText = SOURCE_TYPE_MODEL_CODE_LABEL;
            }
            else if(this.viewModeInfo.sourceType == DATA_DISPLAY_CONSTANTS.VIEW_SOURCE_TYPE_PRIVATE_CODE) {
                viewTypeText = SOURCE_TYPE_MODEL_PRIVATE_CODE_LABEL;
            }
            viewTypeClassName = "visiui_displayContainer_viewTypeModelClass";
        }
        else if(this.viewModeInfo.sourceLayer == DATA_DISPLAY_CONSTANTS.VIEW_SOURCE_LAYER_APP) {
            if(this.viewModeInfo.sourceType == DATA_DISPLAY_CONSTANTS.VIEW_SOURCE_TYPE_DATA) {
                viewTypeText = SOURCE_TYPE_APP_DATA_LABEL;
            }
            else if(this.viewModeInfo.sourceType == DATA_DISPLAY_CONSTANTS.VIEW_SOURCE_TYPE_FUNCTION) {
                viewTypeText = SOURCE_TYPE_APP_CODE_LABEL;
            }
            else if(this.viewModeInfo.sourceType == DATA_DISPLAY_CONSTANTS.VIEW_SOURCE_TYPE_OTHER_CODE) {
                viewTypeText = SOURCE_TYPE_APP_CODE_LABEL;
            }
            viewTypeClassName = "visiui_displayContainer_viewTypeAppClass";
        }

        let viewDescText;
        if(this.viewModeInfo.description) {
            viewDescText = this.viewModeInfo.description;
        }

        return {viewTitleText,hasViewSourceText,viewTypeText,viewTypeClassName,viewDescText};
    }

    _getViewSourceText() {
        let viewSourceText;
        if(this.viewModeInfo.sourceLayer == DATA_DISPLAY_CONSTANTS.VIEW_SOURCE_LAYER_MODEL) {
            viewSourceText = this.componentView.getName();
            if(this.viewModeInfo.suffix) viewSourceText += this.viewModeInfo.suffix;
        }
        else {
            viewSourceText = "";
        }
        return viewSourceText;
    }

    /** This method configures the toolbar for the view display. */
    _configureSizingElement() {

        //show the height controls
        if(this.dataDisplay.getUseContainerHeightUi()) {

            if(!this.showLessButton) { //use this as a proxy for other two
                this.showLessButton = uiutil.createElementWithClass("div","visiui_displayContainer_viewDisplaySizeButtonClass visiui_hideSelection",this.sizingElement);
                this.showLessButton.innerHTML = "less";
                this.showLessButton.onclick = () => this._showLess();
                this.showLessButton.title = "Descrease View Size";
                this.showMoreButton = uiutil.createElementWithClass("div","visiui_displayContainer_viewDisplaySizeButtonClass visiui_hideSelection",this.sizingElement);
                this.showMoreButton.innerHTML = "more";
                this.showMoreButton.onclick = () => this._showMore();
                this.showMoreButton.title = "Increase View Size";
                this.showMaxButton = uiutil.createElementWithClass("div","visiui_displayContainer_viewDisplaySizeButtonClass visiui_hideSelection",this.sizingElement);
                this.showMaxButton.innerHTML = "max";
                this.showMaxButton.onclick = () => this._showMax();
                this.showMaxButton.title = "Show Max View Size";
            }

            this.heightUiActive = true;
            this.sizingElement.style.display = "";
        }
        else {
            this.heightUiActive = false;
            this.sizingElement.style.display = "none";
        }
    }

    _showLess() {
        if((this.dataDisplay)&&(this.heightUiActive)) {
            this.dataDisplay.showLess();
            this._updateViewSizeButtons();
        }
    }

    _showMore() {
        if((this.dataDisplay)&&(this.heightUiActive)) {
            this.dataDisplay.showMore();
            this._updateViewSizeButtons();
        }
    }

    _showMax() {
        if((this.dataDisplay)&&(this.heightUiActive)) {
            this.dataDisplay.showMax();
            this._updateViewSizeButtons();
        }
    }

    _updateViewSizeButtons() {
        if(this.heightUiActive) {
            let showLessVisible = false, showMoreVisible = false, showMaxVisible = false;
            if((this.dataDisplay)&&(!this.isViewHidden)) {
                let resizeButtonFlags = this.dataDisplay.getHeightAdjustFlags();
                if(resizeButtonFlags & DATA_DISPLAY_CONSTANTS.RESIZE_SHOW_FLAG) {
                    if(resizeButtonFlags & DATA_DISPLAY_CONSTANTS.RESIZE_MODE_MAX_FLAG) {
                        showLessVisible = true;
                    }
                    else {
                        showLessVisible = true;
                        showMoreVisible = true;
                        showMaxVisible = true;
                    }
                }
            }

            //not currently implemented:
            //DATA_DISPLAY_CONSTANTS.RESIZE_DISABLE_LESS
            //DATA_DISPLAY_CONSTANTS.RESIZE_DISABLE_MORE
            //DATA_DISPLAY_CONSTANTS.RESIZE_DISABLE_MAX

            this.showLessButton.style.display = (showLessVisible) ? "" : "none";
            this.showMoreButton.style.display = (showMoreVisible) ? "" : "none";
            this.showMaxButton.style.display = (showMaxVisible) ? "" : "none";
        }
        
    }

    /** This method shold be called when the content loaded or frame visible state 
     * changes to manage the data display.
     * private */
    _updateDataDisplayLoadedState() {
        
        if((this.isComponentShowing)&&(this.isViewActive)) {
            if(!this.dataDisplayLoaded) {
                if(!this.dataDisplay) {
                    //the display should be created only when it is made visible
                    this.dataDisplay =  this.componentView.getDataDisplay(this,this.viewTypeName);
                    if(this.dataDisplay) {
                        this.dataDisplay.readUiStateData(this.savedUiState);
                        this._setDataContent(this.dataDisplay.getContent());
                        this._configureSizingElement();
                        this._updateDataDisplay();
                    }
                }
            
                if((this.dataDisplay)&&(this.dataDisplay.onLoad)) {
                    this.dataDisplay.onLoad();
                    this.dataDisplayLoaded = true;
                }
            }
        }
        else {
            if(this.dataDisplay) {
                if(this.dataDisplayLoaded) {
                    this.dataDisplayLoaded = false;
                    if(this.dataDisplay.onUnload) this.dataDisplay.onUnload();
                }
                
                //we will destroy the display is the destroyViewOnInactive flag is set, and we are inactive
                //but don't destroy a traniesnt display. It needs to be there to decide if it should be shown or hidden
                if((this.destroyViewOnInactive)&&(!this.isViewActive)&&(!this.viewModeInfo.isTransient)) {
                    //update the saved UI state
                    this.dataDisplay.addUiStateData(this.savedUiState);

                    this._cleanupDataDisplayUI();

                    //destroy the display
                    if(this.dataDisplay.destroy) this.dataDisplay.destroy();
                    this.dataDisplay = null;
                }
            }  
        }
        this._updateViewSizeButtons();
    }

    

    _updateDataDisplay() {
        //don't reload data if we are in edit mode. It will reload after completion, whether through cancel or save.
        if(this.inEditMode) return;

        this.dataDisplay.showData();
        this._updateViewSizeButtons();
    }

    _cleanupDataDisplayUI() {
        //reset any data display specific parts of the ui
        this.sizingElement.style.display = "none";
        this.heightUiActive = false;
        uiutil.removeAllChildren(this.viewDisplayElement);
        uiutil.removeAllChildren(this.viewContainer);
    }

    _deleteDataDisplay() {
        if(this.dataDisplay) {
            if(this.dataDisplay.destroy) {
                this.dataDisplay.destroy();
            }
            this.dataDisplay = null;
            this.dataDisplayLoaded = false;
        }
    }

    //====================================
    // Internal Methods
    //====================================

    /** This handles key input */
    _keyDownHandler(keyEvent,onSave,onCancel) {
        if((keyEvent.keyCode == 83)&&(keyEvent.ctrlKey)&&(!__OS_IS_MAC__)) {
            if(this.inEditMode) onSave();
            keyEvent.preventDefault();
            return true;
        }
        else if((keyEvent.keyCode == 83)&&(keyEvent.metaKey)&&(__OS_IS_MAC__)) {
            if(this.inEditMode) onSave();
            keyEvent.preventDefault();
            return true;
        }
        else if(keyEvent.keyCode == 27) {
            if(this.inEditMode) onCancel();
            keyEvent.preventDefault();
            return true;
        }
    }

    /** This sets the content for the window. If null (or otherwise false) is passed
     * the content will be set to empty.*/
    _setHeaderContent(contentElement) {
        uiutil.removeAllChildren(this.headerContainer);
        if(contentElement) {
            this.headerContainer.appendChild(contentElement);
        }
    }

    /** This sets the content for the window. */
    _setDataContent(contentElement) {
        //set the content
        this.viewContainer.appendChild(contentElement);
    }

}

/** This method returns the main dom element for the window frame. */
PageDisplayContainer.VIEW_CLOSED_IMAGE_PATH = "/closed_black.png";
PageDisplayContainer.VIEW_OPENED_IMAGE_PATH = "/opened_black.png";

const MESSAGE_CONTAINER_BASE_CLASS = "visiui_displayContainer_messageContainerClass";

const MESSAGE_TYPE_CLASS_MAP = {
    "none": "visiui_displayContainer_messageNone",
    "error": "visiui_displayContainer_messageError",
    "warning": "visiui_displayContainer_messageWarning",
    "info": "visiui_displayContainer_messageInfo"
};


const SOURCE_TYPE_MODEL_DATA_LABEL = "data";
const SOURCE_TYPE_MODEL_CODE_LABEL = "code";
const SOURCE_TYPE_MODEL_PRIVATE_CODE_LABEL = "private code";
const SOURCE_TYPE_APP_DATA_LABEL = "UI data";
const SOURCE_TYPE_APP_CODE_LABEL = "UI code - no access to other cells";

/** This component represents a json table object. */
class PageChildComponentDisplay {

    constructor(componentView, parentComponentDisplay) {
        this.componentView = componentView;
        this.parentComponentDisplay = parentComponentDisplay;

        this.editModeViews = [];
        this.inEditMode = false;
        
        //these are the header elements
        this.iconOverlayElement;
        this.mainElement = null;
        this.bannerContainer = null;

        this.titleBarNameElement = null;
        this.cellTypeLabel = null;
        
        this.displayContainerMap = null;
        
        this.isPageShowing = false;

        //make the container
        this.mainElement = uiutil.createElementWithClass("div","visiui_pageChild_mainClass",null);
        this.isHighlighted = false;
    
        //this is the window in which the component is displayed
        if(componentView) this.loadComponentDisplay();
        
        //connect to parent
        this.setIsPageShowing(this.parentComponentDisplay.getIsShowing());
        this.onShow = () => this.setIsPageShowing(true);
        this.onHide = () => this.setIsPageShowing(false);
        this.parentComponentDisplay.addListener(uiutil.SHOWN_EVENT,this.onShow);
        this.parentComponentDisplay.addListener(uiutil.HIDDEN_EVENT,this.onHide);
    }

    getElement() {
        return this.mainElement;
    }

    setComponentView(componentView) {
        this.componentView = componentView;
        this.loadComponentDisplay();
        this.updateChildDisplayStates();
    }

    getComponentView() {
        return this.componentView;
    }

    getPageDisplayContainer(viewType) {
        return this.displayContainerMap[viewType];
    }

    getDataDisplay(viewType) {
        let pageDisplayContainer = this.getPageDisplayContainer(viewType);
        if(pageDisplayContainer) {
            return pageDisplayContainer.getDataDisplay();
        }
        else {
            return null;
        }
    }

    componentUpdated(component) {

        if(component.isDisplayNameUpdated()) {
            this._setTitle();
        }

        if(component.isStateUpdated()) {
            this._setBannerState();
        }

        //update the content in instantiated view mode elements
        for(var viewType in this.displayContainerMap) {
            var displayContainer = this.displayContainerMap[viewType];
            displayContainer.componentUpdated(component);
        }
    }

    /** This gets the current window state, to reconstruct the view. */
    getStateJson() {
        let json = {};
        let dataPresent = false;
        
        //view state
        json.views = {};
        for(var viewType in this.displayContainerMap) {
            let displayContainer = this.displayContainerMap[viewType];
            let viewStateJson = displayContainer.getStateJson();
            if(viewStateJson) {
                json.views[viewType] = viewStateJson;
                dataPresent = true;
            }
        }
        
        if(dataPresent) return json;
        else return undefined;
    }

    /** This gets the current window state, to reconstruct the view. */
    setStateJson(json) {
        if(json) {

            //set view state
            if(json.views) {
                for(let viewType in json.views) {
                    let viewStateJson = json.views[viewType];
                    if(viewStateJson) {
                        let displayContainer = this.displayContainerMap[viewType];
                        if(displayContainer) {
                            displayContainer.setStateJson(viewStateJson);
                        }
                    }
                }
            }
        }
    }

    /** This will reload the given data display. */
    reloadDisplay(viewType) {
        if(this.displayContainerMap) {
            let displayContainer = this.displayContainerMap[viewType];
            if(displayContainer) {
                displayContainer.reloadDisplay();
            }
        }
    }

    /** This should be called by the component when it discards this display. */
    deleteDisplay() {
        if(this.isDestroyed) return; 

        //remove parent listeners
        if(this.parentComponentDisplay) {
            this.parentComponentDisplay.removeListener(uiutil.SHOWN_EVENT,this.onShow);
            this.parentComponentDisplay.removeListener(uiutil.HIDDEN_EVENT,this.onHide);
            this.parentComponentDisplay = null;
        }
        
        //discard the menu
        if(this.menu) {
            this.menu.destroy();
            this.menu = null;
        }

        //dispose any view elements
        for(var viewType in this.displayContainerMap) {
            var displayContainer = this.displayContainerMap[viewType];
            if(displayContainer) {
                displayContainer.destroy();
                delete this.displayContainerMap[viewType];
            }
        }

        //remove the dom elements
        if(this.mainElement) {
            this.mainElement.onclick = null;
            this.mainElement.remove();
        }
        if(this.bannerContainer) this.bannerContainer.remove();
        if(this.viewContainer) this.viewContainer.remove();
        if(this.titleBarContainer) this.titleBarContainer.remove();
        if(this.iconContainerElement) this.iconContainerElement.remove();
        if(this.icon) this.icon.remove();
        if(this.titleBarNameElement) this.titleBarNameElement.remove();
        if(this.cellTypeLabel) this.titleBarNameElement.remove();
        if(this.titleBarViewsElement) this.titleBarViewsElement.remove();

        this.isDestroyed = true;
    }

    /** This function sets this child display to highlighted. It is intended for when this display is
     * inside the current text selection. */
    setHighlight(isHighlighted) {
        if(this.isHighlighted != isHighlighted) {
            this.isHighlighted = isHighlighted;
            if(isHighlighted) {
                this.mainElement.classList.add("visiui_pageChild_highlighted");
            }
            else {
                this.mainElement.classList.remove("visiui_pageChild_highlighted");
            }
        }  
    }


    //===============================
    // Private Functions
    //===============================


    /** This is the standard window for the component.  
     * @private */
    loadComponentDisplay() {
        if(!this.componentView) return;

        //add the click handler, to select this node if it is clicked
        this.mainElement.onclick = () => {
            let name = this.componentView.getName();
            let parentComponentView = this.componentView.getParentComponentView();
            if(parentComponentView) {
                let command = parentComponentView.getSelectApogeeNodeCommand(name);
                if(command) {
                    let app = this.componentView.getApp();
                    app.executeCommand(command);
                }
            }
        };
        
        //add title bar
        this.addTitleBar();
        
        //add banner container
        this.bannerContainer = uiutil.createElementWithClass("div","visiui_pageChild_bannerContainerClass",this.mainElement);
        
        //add the view container
        this.viewContainer = uiutil.createElementWithClass("div","visiui_pageChild_viewContainerClass",this.mainElement);
        
        //add the view elements
        var settings = this.componentView.getTableEditSettings();
        var viewModes = settings.viewModes;
        
        this.displayContainerMap = {};  
        if(viewModes.length > 0) {
            for(var i = 0; i < viewModes.length; i++) {
                var viewModeInfo = viewModes[i];
                if((typeof(viewModeInfo) == "string")||(viewModeInfo instanceof String)) {
                    //legacy - when only name was stored, not view info
                    let viewName = viewModeInfo;
                    viewModeInfo = {};
                    viewModeInfo.name = viewName;
                    viewModeInfo.label = viewName;
                    viewModeInfo.isActive = (i == 0); //default is active
                }

                var displayContainer = new PageDisplayContainer(this, viewModeInfo);
                
                //add the view title element to the title bar
                this.titleBarViewsElement.appendChild(displayContainer.getViewSelectorContainer());
                
                //add the view display
                this.viewContainer.appendChild(displayContainer.getDisplayElement());
                
                //store the display container object
                this.displayContainerMap[viewModeInfo.name] = displayContainer;
            }
        }

        this._setTitle();
        this._setBannerState();
    }

    /** This makes the title bar, and installs it inline */
    addTitleBar() {
        
        this.titleBarContainer = uiutil.createElementWithClass("div","visiui_pageChild_titleBarClass",this.mainElement);

        //icon/menu
        var iconSrc = this.componentView.getIconUrl();
        if(!iconSrc) {
            iconSrc = uiutil.getResourcePath(uiutil.GENERIC_CELL_ICON);
        }

        this.iconContainerElement = uiutil.createElementWithClass("div", "visiui-pageChild-icon-container",this.titleBarContainer);
        this.icon = uiutil.createElementWithClass("img", "visiui-pageChild-icon visiui_hideSelection",this.iconContainerElement);
        this.icon.src = iconSrc; 
        this.iconOverlayElement = uiutil.createElementWithClass("div","visiui_pageChild_icon_overlay visiui_hideSelection",this.iconContainerElement);
        
        //cell name label (note - keep this selectable so users can copy the name)
        this.titleBarNameElement = uiutil.createElementWithClass("div", "visiui_pageChild_titleBarNameClass",this.titleBarContainer);

        //menu
        let menuItemCallback = () => {
            return this.componentView.getMenuItems();
        };
        let menuImage = uiutil.getResourcePath(uiutil.DOT_MENU_IMAGE);
        this.menu = Menu.createMenuFromImage(menuImage);
        this.menu.setAsOnTheFlyMenu(menuItemCallback);
        let menuElement = this.menu.getElement();
        //update the style of the menu element
        menuElement.style.verticalAlign = "middle";
        this.titleBarContainer.appendChild(menuElement);

        //views
        this.titleBarViewsElement = uiutil.createElementWithClass("div","visiui_pageChild_titleBarViewsClass",this.titleBarContainer);

        //cell type label
        this.cellTypeLabel = uiutil.createElementWithClass("div","visiui_pageChild_cellTypeLabelClass visiui_hideSelection",this.titleBarContainer);
        this.cellTypeLabel.innerHTML = this.componentView.getComponent().constructor.displayName;

    }

    setIsPageShowing(isPageShowing) {
        if(this.isPageShowing != isPageShowing) {
            this.isPageShowing = isPageShowing;
            this.updateChildDisplayStates();
        }
    }

    /** This method should be called when a given view type enters of exits edit mode */
    notifyEditMode(viewInEditMode,viewTypeName) {
        if(viewInEditMode) {
            if(this.editModeViews.indexOf(viewTypeName) < 0) {
                this.editModeViews.push(viewTypeName);
            }
        }
        else {
            let index = this.editModeViews.indexOf(viewTypeName);
            if(index >= 0) {
                this.editModeViews.splice(index,1);
            }
        }
        let inEditMode = (this.editModeViews.length > 0);

        if(inEditMode != this.inEditMode) this._setEditMode(inEditMode);
    }

    _setEditMode(inEditMode) {
        //set component edit mode
        this.inEditMode = inEditMode;
        if(inEditMode) {
            this.mainElement.classList.add("visiui_pageChild_editMode");
        }
        else {
            this.mainElement.classList.remove("visiui_pageChild_editMode");
        }
            
        //notify page
        if(this.componentView) {
            this.parentComponentDisplay.notifyEditMode(this.inEditMode,this.componentView);
        }
    }

    updateChildDisplayStates() {
        var componentBodyShowing = this.isPageShowing;
        for(var viewType in this.displayContainerMap) {
            var displayContainer = this.displayContainerMap[viewType];
            if(displayContainer) {
                //notify display container if component display body is loaded
                if(displayContainer.getIsComponentShowing() != componentBodyShowing) {
                    displayContainer.setIsComponentShowing(componentBodyShowing);
                }
            }
        }
    }

    /** This sets the given element as the icon overlay. If null or other [false} is passed
     * this will just clear the icon overlay. */
    setIconOverlay(element) {
        if(this.iconOverlayElement) {
            this.clearIconOverlay();
            if(element) {
                this.iconOverlayElement.appendChild(element);
            }
        }
    }

    clearIconOverlay() {
        if(this.iconOverlayElement) {
            uiutil.removeAllChildren(this.iconOverlayElement);
        }
    }

    _setTitle() {
        if(!this.componentView) return;

        let title = this.componentView.getDisplayName();
        this.titleBarNameElement.innerHTML = title;
    }

    _setBannerState() {
        if(!this.componentView) return;

        let bannerState = this.componentView.getBannerState();
        let bannerMessage = this.componentView.getBannerMessage();

        //update the banner
        var bannerDiv;
        if(bannerState == bannerConstants.BANNER_TYPE_NONE) {
            bannerDiv = null;
        }
        else {
            bannerDiv = getBanner(bannerMessage,bannerState);
        }
        uiutil.removeAllChildren(this.bannerContainer);
        if(bannerDiv) {
            this.bannerContainer.appendChild(bannerDiv);
        }
        
        //update the icon overlay
        var iconOverlay = getIconOverlay(bannerState,bannerMessage);
        if(iconOverlay) {
            this.setIconOverlay(iconOverlay);
        }
        else {
            this.clearIconOverlay();
        }
    }

}

/** This method returns the main dom element for the window frame. */
PageChildComponentDisplay.EXPAND_BUTTON_PATH = "/closed_gray.png";
PageChildComponentDisplay.CONTRACT_BUTTON_PATH = "/opened_gray.png";

/** This component represents a json table object. */
class LiteratePageComponentDisplay$1 {
    
    constructor(componentView) {
        //mixin initialization
        this.eventManagerMixinInit();

        this.componentView = componentView;

        this.childDisplayMap = {};
        this.editModeComponentInfos = [];
        this.inEditMode = false;

        this.isShowing = false;

        this.editorManager = this.componentView.getEditorManager();
        this.editorView = null;
        this.editorToolbarView = null;

        //elements
        this.contentElement = null;
        this.editorToolbarContainer = null;
        this.componentToolbarContainer = null;
        this.bannerContainer = null;
        this.editNoticeContainer = null;
        this.headerElement = null;

        //this is used if we have to prepopolate and child component displays
        this.standInChildComponentDisplays = {};

        //for cleanup
        this.elementsWithOnclick = [];
        this.isDestroyed = false;

        this.loadTabEntry();
    };

    getComponentView() {
        return this.componentView;
    }


    getTab() {
        return this.tab;
    }

    getEditorView() {
        return this.editorView;
    }

    closeTab() {
        if(this.tab) {
            this.tab.close();
            this.tab = null;
        }
    }

    getIsShowing() {
        return this.isShowing;
    }

    componentUpdated(component) {

        if(component.isMemberFieldUpdated("member","name")) {
            this.tab.setTitle(this.componentView.getName());
        }

        if(component.isFieldUpdated("editorState")) {
            let editorData = this.componentView.getEditorState();
            this.editorView.updateState(editorData);
            this._checkSelectionForNodeHighlights(editorData);
        }

        if(component.isStateUpdated()) {
            this._setBannerState();
        }
    }

    getChildComponentDisplay(name,createIfMissing) {
        //get id
        let folderComponent = this.componentView.getComponent();
        let folderMember = folderComponent.getParentFolderForChildren();
        let memberId = folderMember.lookupChildId(name);

        //lookup component
        if (memberId) {
            var modelManager = this.componentView.getApp().getModelManager();
            var childComponentId = modelManager.getComponentIdByMemberId(memberId);
            let childComponentDisplay = this.childDisplayMap[childComponentId];
            if((!childComponentDisplay)&&(createIfMissing)) {
                //we don't haven't added it yet, but we will pre-create it
                childComponentDisplay = new PageChildComponentDisplay(null, this);
                this.childDisplayMap[childComponentId] = childComponentDisplay;
            }
            return childComponentDisplay;
        }
        else {
            return null;
        }
    }


    /** This creates and adds a display for the child component to the parent container. */
    addChild(childComponentView) {

        //-----------------
        // Get component display
        //-----------------
        let childComponentDisplay;
        let componentId = childComponentView.getComponent().getId();

        //create a new component display for this child
        if(childComponentView.constructor.hasChildEntry) {
            //check if there is a component display already waiting, pre-created
            childComponentDisplay = this.childDisplayMap[componentId];
            if(childComponentDisplay) {
                //set up the standin component display
                childComponentDisplay.setComponentView(childComponentView);
            }
            else {
                childComponentDisplay = new PageChildComponentDisplay(childComponentView,this);
                this.childDisplayMap[componentId] = childComponentDisplay;
            }
        }

        if(childComponentDisplay) {
            //set the child's component display
            childComponentView.setComponentDisplay(childComponentDisplay);
        }
    }

    removeChild(childComponentView) {
        let componentId = childComponentView.getComponent().getId();
        delete this.childDisplayMap[componentId];

        //make sure this isn't listed as being in edit mode
        this.notifyEditMode(false,childComponentView);
    }


    /** This is to record any state in the tab object. */
    getStateJson() {
        return null;
    }

    /** This is to restore any state in the tab object. */
    setStateJson(json) {
    }

    /** This should be called when a child display enters or leaves edit mode. */
    notifyEditMode(viewInEditMode,componentView) {
        let componentId = componentView.getComponent().getId();
        let index = this.editModeComponentInfos.findIndex( editInfo => editInfo.id == componentId );
        if(viewInEditMode) {
            if(index < 0) {
                this.editModeComponentInfos.push(this._getEditInfo(componentView));
            }
        }
        else {
            if(index >= 0) {
                this.editModeComponentInfos.splice(index,1);
            }
        }
        let inEditMode = (this.editModeComponentInfos.length > 0);

        this._setEditMode(inEditMode);
    }

    //===============================
    // Private Functions
    //===============================

    /** This retrieves the format of data to store for tracking edit mode in cells. */
    _getEditInfo(componentView) {
        let component = componentView.getComponent();
        return {id: component.getId(), name: component.getName()}
    }

    /** This sets edit mode in the display. */
    _setEditMode(inEditMode) {
        //set component edit mode
        this.inEditMode = inEditMode;

        if(inEditMode) {
            let msg = "Cells being edited: " + this._getNameListFromEditInfos();
            this.editNoticeContainer.innerHTML = msg;
        }
        else {
            this.editNoticeContainer.innerHTML = "";
        }
            
    }

    /** This constructs the name list for the current edito components. */
    _getNameListFromEditInfos() {
        return this.editModeComponentInfos.map(editInfo => editInfo.name).join(", ");
    }


    /** @private */
    loadTabEntry() {
        let component = this.componentView.getComponent();
        this.tab = new Tab(component.getId());    

        //-----------------------
        //set the content
        //-----------------------
        this.createDisplayContent();

        if(this.tab.getIsShowing()) {
            this.tabShown();
        }
        else {
            this.tabHidden();
        }

        this.tabShownListener = () => this.tabShown();
        this.tabHiddenListener = () => this.tabHidden();
        this.tabClosedListener = () => this.tabClosed();
        this.beforeTabCloseHandler = () => this.beforeTabClose();
        this.tab.addListener(uiutil.SHOWN_EVENT,this.tabShownListener);
        this.tab.addListener(uiutil.HIDDEN_EVENT,this.tabHiddenListener);
        this.tab.addListener(uiutil.CLOSE_EVENT,this.tabClosedListener);
        this.tab.addHandler(uiutil.REQUEST_CLOSE,this.beforeTabCloseHandler);

        //------------------
        // set icon
        //------------------
        this.tab.setIconUrl(this.componentView.getIconUrl());

        //-----------------
        //set the tab title
        //-----------------
        this.tab.setTitle(this.componentView.getName());

        //-----------------
        // apply the banner state
        //-----------------
        this._setBannerState();
    }

    _setBannerState() {
        let bannerState = this.componentView.getBannerState();
        let bannerMessage = this.componentView.getBannerMessage();

        uiutil.removeAllChildren(this.bannerContainer);
        if(bannerState == bannerConstants.BANNER_TYPE_NONE) ;
        else {
            var banner = getBanner(bannerMessage,bannerState);
            this.bannerContainer.appendChild(banner);
        }

        if(this.tab) {
            var iconOverlay = getIconOverlay(bannerState,bannerMessage);
            if(iconOverlay) {
                this.tab.setIconOverlay(iconOverlay);
            }
            else {
                this.tab.clearIconOverlay();
            }
        }
    }

     /** @private */
    createDisplayContent() {

        //-----------
        //page header
        //------------
        this.headerElement = uiutil.createElementWithClass("div","visiui_litPage_header",null);
        this.tab.setHeaderContent(this.headerElement);

        this.editorToolbarContainer = uiutil.createElementWithClass("div","visiui_litPage_editorToolbar",this.headerElement);
        this.componentToolbarContainer = uiutil.createElementWithClass("div","visiui_litPage_componentToolbar",this.headerElement);
        this.bannerContainer = uiutil.createElementWithClass("div","visiui_litPage_banner",this.headerElement);
        this.editNoticeContainer = uiutil.createElementWithClass("div","visiui_litPage_editNotice",this.headerElement);
        this.initComponentToolbar();

        //-------------------
        //page body
        //-------------------
        this.contentElement = uiutil.createElementWithClass("div","visiui_litPage_body",null);
        this.tab.setContent(this.contentElement);

        let pageComponent = this.componentView.getComponent();
        let folder = pageComponent.getParentFolderForChildren();

        //show all children
        var appViewInterface = this.componentView.getAppViewInterface();
        var childrenIds = folder.getChildIdMap();
        for(var childName in childrenIds) {
            var childMemberId = childrenIds[childName];
            var childComponentView = appViewInterface.getComponentViewByMemberId(childMemberId);
            if(childComponentView) {
                this.addChild(childComponentView);
            }
        }
        
        this.initEditor();
    }

    initComponentToolbar() {

        //THIS IS BAD - IT IS ONLY TO GET THIS WORKING AS A TRIAL
        //MAKE A WAY TO GET COMPONENT GENERATORS FOR BUTTONS RATHER THAN READING A PRIVATE VARIABLE FROM APP
        let pageComponent = this.componentView.getComponent();
        var app = this.componentView.getApp();
        var appViewInterface = this.componentView.getAppViewInterface();
        

        let standardComponentNames = componentInfo.getStandardComponentNames();
        for(var i = 0; i < standardComponentNames.length; i++) {
            let componentName = standardComponentNames[i];

            let componentClass = componentInfo.getComponentClass(componentName);
            let componentViewClass = getComponentViewClass(componentClass.uniqueName);
            if(componentViewClass.hasChildEntry) {

                var buttonElement = uiutil.createElementWithClass("div","visiui_litPage_componentButton",this.componentToolbarContainer);
                //make the idon
                var imageElement = document.createElement("img");
                imageElement.src = uiutil.getResourcePath(componentViewClass.ICON_RES_PATH);
                var iconElement = uiutil.createElementWithClass("div","visiui_litPage_componentButtonIcon",buttonElement);
                iconElement.appendChild(imageElement);
                //label
                var textElement = uiutil.createElementWithClass("div","visiui_litPage_componentButtonText",buttonElement);
                textElement.innerHTML = componentClass.displayName;
                buttonElement.title = "Insert " + componentClass.displayName;
                //add handler
                buttonElement.onclick = () => {

                    this.editorView.focus();

                    var initialValues = {};
                    var parentMember = pageComponent.getParentFolderForChildren();
                    initialValues.parentId = parentMember.getId();

                    addComponent(appViewInterface,app,componentClass,initialValues,null,null);
                };

                //for cleanup
                this.elementsWithOnclick.push(buttonElement);
            }
        }

        //add the additional component item
        var buttonElement = uiutil.createElementWithClass("div","visiui_litPage_componentButton",this.componentToolbarContainer);
        var textElement = uiutil.createElementWithClass("div","visiui_litPage_componentButtonText",buttonElement);
        textElement.innerHTML = "Additional Components...";
        buttonElement.title = "Additional Cells to Insert";
        buttonElement.onclick = () => {

            this.editorView.focus();

            var initialValues = {};
            var parentMember = pageComponent.getParentFolderForChildren();
            initialValues.parentId = parentMember.getId();

            let appViewInterface = this.componentView.getAppViewInterface();

            //I tacked on a piggyback for testing!!!
            addAdditionalComponent(appViewInterface,app,initialValues,null,null);
        };
        //for cleanup
        this.elementsWithOnclick.push(buttonElement);

        this.componentToolbarContainer.appendChild(buttonElement);
    }


    initEditor() {
        
        //start with an empty component display
        var initialEditorState = this.componentView.getEditorState();
        
        let { editorView, toolbarView, plugins } = this.editorManager.createEditorView(this.contentElement,this,initialEditorState);
        this.editorView = editorView;
        this.editorToolbarView = toolbarView;

        this.contentElement.onclick = event => this.onClickContentElement(event);
        this.elementsWithOnclick.push(this.contentElement);

        //add the editor toolbar
        this.editorToolbarContainer.appendChild(this.editorToolbarView.getElement());

        //we need to call a command to set the plugins on the editor state
        let pageComponent = this.componentView.getComponent();
        var app = this.componentView.getApp();

        //we need to initialize the components in the editor state for this component
        let command = {};
        command.type = "literatePagePlugins";
        command.componentId = pageComponent.getId();
        command.plugins = plugins;

        //execute the command asynchronously - this may be triggered by another command (such as open workspace)
        setTimeout(() => app.executeCommand(command));
        
        
    }

    /** This is used to select the end of the document if the page is clicked below the document end. */
    onClickContentElement(event) {
        if(event.target == this.contentElement) {
            this.componentView.giveEditorFocusIfShowing();
            let command = this.componentView.getSelectEndOfDocumentCommand();
            let app = this.componentView.getApp();
            app.executeCommand(command);
        }    
    }

    /** This function sets any apogee nodes included in the selection to be highlighted. */
    _checkSelectionForNodeHighlights(editorData) {
        let { empty, from, to } = editorData.selection;
        if(empty) {
            from = -1;
            to = -1;
        }
 
        let document = editorData.doc;
        let schema = editorData.schema;
        //travers doc, finding apogee nodes and setting their selection state
        document.forEach( (node,offset) => {
            if(node.type === schema.nodes.apogeeComponent) {
                let inSelection = ((offset >= from)&&(offset < to));
                let nodeName = node.attrs["name"];
                this._setApogeeNodeHighlight(nodeName,inSelection);
            }
            //do not recurse into children
            return false;
        });

    }

    /** This function sets the highlight state for the given node. */
    _setApogeeNodeHighlight(childName,inSelection) {
        let childComponentDisplay = this.getChildComponentDisplay(childName,false);
        if(childComponentDisplay) childComponentDisplay.setHighlight(inSelection); 
    }
    

    /** This should be called by the parent component when it is discarding the 
     * page display.  
     * @protected */
    destroy() {
        if(this.isDestroyed) return;

        //close tab if it is still present
        if(this.tab) this.closeTab();

        //child components
        //we should probably have a less cumbesome way of doing this
        let pageComponent = this.componentView.getComponent();
        let folder = pageComponent.getParentFolderForChildren();
        var childIdMap = folder.getChildIdMap();
        var appViewInterface = this.componentView.getAppViewInterface();
        for(var childName in childIdMap) {
            var childMemberId = childIdMap[childName];
            var childComponentView = appViewInterface.getComponentViewByMemberId(childMemberId);
            if(childComponentView) {
                childComponentView.closeComponentDisplay();
            }
        }

        for(let memberId in this.childDisplayMap) {
            let childDisplay = this.childDisplayMap[memberId];
            let childComponentView = childDisplay.getComponentView();
            childComponentView.closeComponentDisplay();
        }
        this.childDisplayMap = [];

        //we need to initialize the components in the editor state for this component
        let command = {};
        command.type = "literatePagePlugins";
        command.componentId = pageComponent.getId();
        command.plugins = [];
        
        //execute the command asynchronously - this may be triggered by another command (such as close workspace)
        setTimeout(() => this.componentView.getApp().executeCommand(command));
        
        //editor view
        if(this.editorView) {
            this.editorView.destroy();
            this.editorView = null;
        }

        //editor toolbar
        if(this.editorToolbarView) {
            this.editorToolbarView.destroy();
            this.editorToolbarView = null;
        }

        //handler cleanmup
        this.elementsWithOnclick.forEach( element => {
            element.onclick = null;
        });

        //remove elements
        if(this.contentElement) this.contentElement.remove();
        if(this.editorToolbarContainer) this.editorToolbarContainer.remove();
        if(this.componentToolbarContainer) this.componentToolbarContainer.remove();
        if(this.bannerContainer) this.bannerContainer.remove();
        if(this.headerElement) this.headerElement.remove();

        this.isDestroyed = true;
    }

    /** @protected */
    tabShown() {
        this.isShowing = true;
        if(this.editorView) {
            this.editorView.focus();
            if(this.editorView.state) {
                let tr = this.editorView.state.tr;
                tr.scrollIntoView();
                setTimeout(() => {
                    //make sure editor view is still here
                    if(this.editorView) this.editorView.dispatch(tr);
                },0);
            }
        }
        this.dispatchEvent(uiutil.SHOWN_EVENT,this);
    }

    /** @protected */
    tabHidden() {
        this.isShowing = false;
        this.dispatchEvent(uiutil.HIDDEN_EVENT,this);
    }

    tabClosed() {
        //delete the page
        if(this.tabShownListener) {
            this.tab.removeListener(uiutil.SHOWN_EVENT,this.tabShownListener);
            this.tabShownListener = null;
        }
        if(this.tabHiddenListener) {
            this.tab.removeListener(uiutil.HIDDEN_EVENT,this.tabHiddenListener);
            this.tabHiddenListener = null;
        }
        if(this.tabClosedListener) {
            this.tab.removeListener(uiutil.CLOSE_EVENT,this.tabClosedListener);
            this.tabClosedListener = null;
        }
        this.componentView.closeTabDisplay();
        this.dispatchEvent(uiutil.CLOSE_EVENT,this);
    }

    beforeTabClose() {
        if(this.inEditMode) {
            let msg = "Please save or cancel the following cells: " + this._getNameListFromEditInfos();
            apogeeUserAlert(msg);
            return uiutil.DENY_CLOSE;
        }
        
        //anything besides deny close is ok
        return true;
    }
    
}

//add mixins to this class
apogeeutil$1.mixin(LiteratePageComponentDisplay$1,EventManager);

/** This is the data to load an empty page. */
LiteratePageComponentDisplay$1.EMPTY_PAGE_BODY = [];

/** This component represents a table object. */
class FolderComponentView extends ParentComponentView {

    constructor(appViewInterface,folderComponent) {
        super(appViewInterface,folderComponent);
    }

    instantiateTabDisplay() {
        return new LiteratePageComponentDisplay$1(this); 
    }

}

//======================================
// This is the component generator, to register the component
//======================================

FolderComponentView.componentName = "apogeeapp.PageComponent";
FolderComponentView.hasTabEntry = true;
FolderComponentView.hasChildEntry = false;
FolderComponentView.ICON_RES_PATH = "/icons3/pageIcon.png";
FolderComponentView.TREE_ENTRY_SORT_ORDER = ParentComponentView.FOLDER_COMPONENT_TYPE_SORT_ORDER;

/** This component represents a folderFunction, which is a function that is programmed using
 *apogee tables rather than writing code. */
class FolderFunctionComponentView extends ParentComponentView {
        
    constructor(appViewInterface,component) {
        //extend parent component
        super(appViewInterface,component);
    }

    instantiateTabDisplay() {
        return new LiteratePageComponentDisplay$1(this); 
    }

    //==============================
    // Child Display
    //==============================

    /**  This method retrieves the table edit settings for this component instance
     * @protected */
    getTableEditSettings() {
        return FolderFunctionComponentView.TABLE_EDIT_SETTINGS;
    }

}

//=======================
// Child View SEttings
//=======================

FolderFunctionComponentView.VIEW_MODES = [
];

FolderFunctionComponentView.TABLE_EDIT_SETTINGS = {
    "viewModes": FolderFunctionComponentView.VIEW_MODES,
};


//======================================
// This is the component generator, to register the component
//======================================

FolderFunctionComponentView.componentName = "apogeeapp.PageFunctionComponent";
FolderFunctionComponentView.hasTabEntry = true;
FolderFunctionComponentView.hasChildEntry = true;
FolderFunctionComponentView.ICON_RES_PATH = "/icons3/pageFunctionIcon.png";
FolderFunctionComponentView.TREE_ENTRY_SORT_ORDER = ParentComponentView.FOLDER_COMPONENT_TYPE_SORT_ORDER;


FolderFunctionComponentView.propertyDialogLines = [
    {
        "type":"textField",
        "label":"Arg List: ",
        "size": 80,
        "key":"argListString"
    },
    {
        "type":"textField",
        "label":"Return Val: ",
        "size": 40,
        "key":"returnValueString"
    }
];

//registration of the parent component views

registerComponentView(FolderComponentView);
registerComponentView(FolderFunctionComponentView);

//expose these apogee libraries globally so plugins can use them 
__globals__.apogeeutil = apogeeutil$1;
__globals__.apogeebase = apogeebase;
__globals__.apogee = apogee;
__globals__.apogeeapp = apogeeapp;
__globals__.apogeeui = apogeeui;
__globals__.apogeeview = apogeeview;

//some user message utilities
__globals__.apogeeUserAlert = (msg) => showSimpleActionDialog(msg,null,["OK"]);
__globals__.apogeeUserConfirm = (msg,okText,cancelText,okAction,cancelAction,defaultToOk) => showSimpleActionDialog(msg,null,[okText,cancelText],[okAction,cancelAction]);
__globals__.apogeeUserConfirmSynchronous = (msg,okText,cancelText,defaultToOk) => confirm(msg);

let appView;

/** This function starts the application */
__globals__.appInit = function(appConfigManager,includePathInfo) {
    initIncludePath(includePathInfo);
    appView = new ApogeeView("appContainer",appConfigManager);
};

/** This function can be used to detect if a save is needed. */
__globals__.getWorkspaceIsDirty = function() {
    return appView.getApp().getWorkspaceIsDirty();
};
